[{"categories":["gnu"],"content":"make记录 ","date":"2021-09-23","objectID":"/posts/make/:0:0","tags":["make"],"title":"make","uri":"/posts/make/"},{"categories":["gnu"],"content":"常用 make make clean make install – 编译成功的文件安装到系统目录 make dist 产生发布软件包文件（即distribution package 这个命令将会将可执行文件及相关文件打包成一个tar.gz压缩的文件用来作为发布软件的软件包。 它会在当前目录下生成一个名字类似“PACKAGE-VERSION.tar.gz”的文件 PACKAGE和VERSION，是我们在configure.in中定义的AM_INIT_AUTOMAKE(PACKAGE, VERSION) make distcheck 生成发布软件包并对其进行测试检查，以确定发布包的正确性 这个操作将自动把压缩包文件解开，然后执行configure命令，并且执行make，来确认编译不出现错误 最后提示你软件包已经准备好，可以发布了 ","date":"2021-09-23","objectID":"/posts/make/:1:0","tags":["make"],"title":"make","uri":"/posts/make/"},{"categories":["tool"],"content":"github记录 ","date":"2021-09-23","objectID":"/posts/github/:0:0","tags":["github"],"title":"github","uri":"/posts/github/"},{"categories":["tool"],"content":"workflow – hugo workflow中所有缩进必须是空格, 不能是tab name: github page on: push: branches: master # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: ‘latest’ name: Build run: hugo –minify name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == ‘refs/heads/master’ with: github_token: ${{ secrets.HUGO_PUBLISH_TOKEN }} publish_dir: ./public ","date":"2021-09-23","objectID":"/posts/github/:1:0","tags":["github"],"title":"github","uri":"/posts/github/"},{"categories":["tool"],"content":"workflow – server-kernel name: build-kernel on: push: branches: master # Set a branch to deploy jobs: build: runs-on: ubuntu-20.04 steps: uses: actions/checkout@v2 name: step 1 test run: echo “step 1” shell: bash name: step 2 make run: make name: step 3 deploy run: echo “step 3” shell: bash ","date":"2021-09-23","objectID":"/posts/github/:2:0","tags":["github"],"title":"github","uri":"/posts/github/"},{"categories":["tool"],"content":"workflow name: build-kernel on: push: branches: master # Set a branch to deploy jobs: build: runs-on: ubuntu-20.04 steps: uses: actions/checkout@v2 name: step-1 run: echo ${env:PATH} shell: bash name: step 2 make uses: docker://alpine:3.8 protobuf: run: make name: step 3 deploy run: echo “step 3” shell: bash ","date":"2021-09-23","objectID":"/posts/github/:3:0","tags":["github"],"title":"github","uri":"/posts/github/"},{"categories":["tool"],"content":"程序检测工具 ","date":"2021-08-28","objectID":"/posts/vargrind/:0:0","tags":["vargrind"],"title":"vargrind","uri":"/posts/vargrind/"},{"categories":["tool"],"content":"vargrind 程序性能查看工具,号称程序员的瑞士军刀可以查看内存信息, 函数调用, cache信息等等 ","date":"2021-08-28","objectID":"/posts/vargrind/:1:0","tags":["vargrind"],"title":"vargrind","uri":"/posts/vargrind/"},{"categories":["tool"],"content":"使用hexo + org-mode + github搭建blog ","date":"2021-08-28","objectID":"/posts/hexo/:0:0","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"为什么要用hexo 说hexo之前, 必须先说blog. blog作用有下: 利己, 整理自身知识体系 或作记录 利人, 分享的精神 blog好处很多, 却也增加了使用者的难度, 比如要理解html等. 同时, 外在的表现(CSS等)往往会导致bloger的重心偏差, 去追求外在的东西. 我们需要一个能让我们专注于文章知识本身, 而无需去关心外在或其他知识的工具, 来帮助我们搭建自己的blog. 当下, 一个不错的选择就是hexo. hexo不拘束我们的文章语言(markdown, org等), 自动将语言转化为html, 并且提供不错的外观. 使我们可以专注文章本身. ","date":"2021-08-28","objectID":"/posts/hexo/:1:0","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo是什么 如上所言, hexo是一款不错的blog框架 hexo的主要优点: 不限制前端语言 自动化生成html 丰富便捷的themes 统一干净的包管理npm 部署简单, 集成方便 迅速上手, 学习时间短 hexo的缺点: 环境无法移植在A pc上搭建的环境, 只能在A pc上发布blog ","date":"2021-08-28","objectID":"/posts/hexo/:2:0","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo怎么使用 ","date":"2021-08-28","objectID":"/posts/hexo/:3:0","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo安装 详细点此查看官网 安装 Node.js, 获得npm包管理工具 安装 Git 安装 Hexo $ npm install -g hexo-cli 至此, hexo已完成安装 安装hexo-renderer-org 这里是org-mode与hexo的结合使用, 非官方的markdown. 根据hexo-renderer-org官方文档一步步操作即可, 具体不详解. 唯一注意的点是: Emacs line的版本要 \u003e= 24 org-mode的版本最好 \u003e= 9.0 使用的分支是coldnew, 而不是master或emacs! ","date":"2021-08-28","objectID":"/posts/hexo/:3:1","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo创建blog 详情点此查看 创建并初始化blog目录 mkdir blog cd blog hexo init 注意事项: hexo命令(例如hexo g) 应该在 hexo init所在目录下使用(上面中是blog目录) ","date":"2021-08-28","objectID":"/posts/hexo/:3:2","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo配置 基本配置 Site ## 标题 title: ## 副标题 subtitle: ## SEO优化 description: keywords ## 作者 author: ## 语言 language: zh-Hans URL ## 访问地址 url: https://clay9.github.io/ ## root地址 root: / Deployment ## 仓库地址 deploy: https://github.com/clay9/clay9.github.io.git ## 仓库协议类型 type: git org ## emacs path, 使用bash环境 emacs: ## emacsclient path emacclinet: Extensions ## 主题 theme: next 主题配置:next scheme scheme: Mist ","date":"2021-08-28","objectID":"/posts/hexo/:3:3","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo使用 文件链接 hexo-renderer-org支持使用org-mode的文件链接方式. 但是有一定的限制. 如果要发布的org文件的名字为A.org. 那么: A.org中链接的文件必须放在A目录下, 且A目录与A.org同级. A.org中链接文件格式为: file:A/文件名字 ","date":"2021-08-28","objectID":"/posts/hexo/:3:4","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo部署 hexo支持多渠道发布, 具体看官网, 这里只说发布到github hexo处理 安装 hexo-deployer-git $ npm install hexo-deployer-git --save 修改blog/_config.yml deploy: type: git repo: \u003crepository url\u003e branch: [branch] github处理 新建项目, 名字为: [YourName].github.io 至此github方面完成 测试 生成并部署到github上 hexo g -d 在web中打开[Yourname].github.io, 查看是否可以显示 ","date":"2021-08-28","objectID":"/posts/hexo/:3:5","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo高级用法 ","date":"2021-08-28","objectID":"/posts/hexo/:4:0","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"自定义域名 实现可以通过wcq.fun 与 www.wcq.fun均可访问 hexo配置 blog/source目录下新增CNAME文件, 其内容为域名, 比如 wcq.fun 域名服务商配置 wcq.fun绑定教程 www.wcq.fun绑定教程 ","date":"2021-08-28","objectID":"/posts/hexo/:4:1","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"鼠标点击小心心效果 在themes/next/source/js/src/下新建love.js文件并且copy下面的代码到love.js中 在themes/next/layout/_layout.swig末尾添加以下代码: \u003c!-- 页面点击小红心 --\u003e \u003cscript type=\"text/javascript\" src=\"/js/src/love.js\"\u003e\u003c/script\u003e ","date":"2021-08-28","objectID":"/posts/hexo/:4:2","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"next主题安装第三方插件 搜索 这里使用的是local search ","date":"2021-08-28","objectID":"/posts/hexo/:4:3","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"docker安装gitlab ","date":"2021-08-28","objectID":"/posts/gitlab/:0:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"为什么要用gitlab git分布式架构,本身没有服务器之说.但为了团队开发, 总有一台电脑充当服务器的角色.我们称之为Public, 意为公共库. 有了Public之后, 所有人都通过该库进行交流. 如果有人恶意或无意损坏了该库的代码, 将导致不可预估的风险.因此我们希望能够对该库进行权限控制. 笔者最开始接触的控制软件是gitosis, 本质仍是通过控制public_key, private_key来管理人员.现在想来, 其缺点非常明显: 配置时候容易出错 无法直观展示人员和项目 除了管理员, 其他人都项目和人员无法认知 虽然gitosis满足了权限的需求, 但是却无法提供良好的用户体验. 对于git, 不应该仅仅是在控制权限方面, 更应该是: 交流, 思想的分享 使用简单便捷 配置简单直观 这些gitlab都完全满足, 并且其允许代码放置在自己的服务器上, 这避免了代码泄漏到internet, 对于企业来说, 非常重要. 省去了在github买private的钱… 当然, gitlab还有非常多惊喜的地方, 比如CI|CD等 ","date":"2021-08-28","objectID":"/posts/gitlab/:1:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab是什么 综上所述, gitlab是一款优秀的git代码管理软件. 其主要优点: 安装简单, 使用简单, 配置简单 团队项目交流方便 完善的开发流程, 主要是CI, CD 可部署在自己的服务器, 减少了代码泄露风险 ","date":"2021-08-28","objectID":"/posts/gitlab/:2:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab怎么用 ","date":"2021-08-28","objectID":"/posts/gitlab/:3:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab安装 安装方式很多, 这里采用docker安装, 因为简单. 安装Docker 在GUI模式(Kitmatic)中搜索并安装gitlabb-ce 或者Docker命令行安装 ","date":"2021-08-28","objectID":"/posts/gitlab/:3:1","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab配置 Settings Volumes下面配置文件路径 Settings Hostname/Posts下配置端口转发 /etc/gitlab/gitlab.rb 中 external_url “http://www.45quyou.com” 该字段不仅仅影响登陆, 还会影响项目的显示 /var/opt/gitlab/gitlab-rails/etc/gitlab.yml 中 Web Server Settings中的host www.45quyou.com ","date":"2021-08-28","objectID":"/posts/gitlab/:3:2","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab使用 配置生效 sudo gitlab-ctl reconfigure 重启进程 sudo gitlab-ce stop | start | restart ","date":"2021-08-28","objectID":"/posts/gitlab/:3:3","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab高级用法 ","date":"2021-08-28","objectID":"/posts/gitlab/:4:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"CI CI: 持续集成 注册 gitlab-runner 在仓库根目录下添加.gitlab-ci.yml文件 piple stage jobs ","date":"2021-08-28","objectID":"/posts/gitlab/:4:1","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"常见问题 KiteMatic 卡在Starting Docker VM界面 解决办法: 完全关闭 KietMatic 和 Docker进程 下载 reset脚本 打开命令行, 执行 ./reset 启动Docker 启动KiteMatic ","date":"2021-08-28","objectID":"/posts/gitlab/:5:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"nginx是使用率最高的web容器 ","date":"2021-08-28","objectID":"/posts/nginx/:0:0","tags":["nginx"],"title":"nginx","uri":"/posts/nginx/"},{"categories":["tool"],"content":"安装 docker pull nginx docker run --name nginx-test -p 8080:80 -d nginx ","date":"2021-08-28","objectID":"/posts/nginx/:1:0","tags":["nginx"],"title":"nginx","uri":"/posts/nginx/"},{"categories":["tool"],"content":"配置 配置文件在/etc/nginx /etc/nginx/nginx.conf是总的, 默认不修改 /etc/nginx/config.d/* 下的是配置的, 一般一个文件配置一个站点 ","date":"2021-08-28","objectID":"/posts/nginx/:2:0","tags":["nginx"],"title":"nginx","uri":"/posts/nginx/"},{"categories":["tool"],"content":"使用","date":"2021-08-28","objectID":"/posts/nginx/:3:0","tags":["nginx"],"title":"nginx","uri":"/posts/nginx/"},{"categories":["tool"],"content":"docker容器 ","date":"2021-08-28","objectID":"/posts/docker/:0:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"功能 ","date":"2021-08-28","objectID":"/posts/docker/:1:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"为什么需要docker ","date":"2021-08-28","objectID":"/posts/docker/:1:1","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"docker与虚拟机的对比 之前以为docker容器就是简约版本的虚拟机, 所以一直想把不同的软件融合到一个镜像中现在2020.6.21 发现上面的想法是错误的现在的认知: docker是对于app(单个软件)的封装 多个软件协同合作的正确方式, 应该是建立多个互相关联的容器, 而不是企图把所有的软件放到一个容器中 ","date":"2021-08-28","objectID":"/posts/docker/:1:2","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"安装 安装docker 安装Kitmatic docker gui工具; 不推荐使用 ","date":"2021-08-28","objectID":"/posts/docker/:2:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"配置 镜像配置使用中国科技大学镜像加速, 无须注册, 直接使用即可 ","date":"2021-08-28","objectID":"/posts/docker/:3:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"使用 推荐阅读教程 TODONOW 待补充 docker实际应用 web服务器 + php + laravel + 数据库 ","date":"2021-08-28","objectID":"/posts/docker/:4:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"镜像操作 搜索镜像 docker search 下载镜像 docker pull 实例化镜像镜像实例化为容器 (类比C++中的类–镜像, 对象–容器) docker run -e “参数” -P 端口映射 –name 容器名字 -d(后台运行) image名字 -p 本机端口 : 容器端口 -v 本机路径 : 容器路径 镜像存储为文件 \u0026\u0026 加载 docker save image_name -o file_path docker load -i file_path 在网络不好的情况下, 可以直接使用文件的方式加载镜像 容器封装为镜像 docker commit [container_id] [image_name] image增加tag docker tag [old_image_name] [new_image_name] 推送image到github 必须先登录github docker login 推送的时候image必须增加tag, tag的名字必须为 登录id/image名字 docker 官网速度太慢了, 建议存储为文件, 供别人使用 git push image ","date":"2021-08-28","objectID":"/posts/docker/:4:1","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"容器操作 查看容器 docker container ls -al 启动 关闭 重启容器 docker container start | stop | restart \u003ccontainer_id\u003e 重定义容器输出 docker container attach \u003ccontainer_id\u003e 进入到容器中 docker container exec -it \u003ccontainer_id\u003e COMMAND -i interactive -t tty COMMAND 一般都是bash环境. 比如: docker container exec -it mysql bash ","date":"2021-08-28","objectID":"/posts/docker/:4:2","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"本机与docker容器交互 文件传输 docker cp test mssql:/home 查看镜像ip地址 TODONOW 因hexo原因, 下面的命令会导致hexo无法编译org为html, 所以详见 ~/bin/docker_ip.sh ","date":"2021-08-28","objectID":"/posts/docker/:4:3","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"Dockerfile \u0026\u0026 docker-compose dockerfile – 对镜像的管理, 可以安装并修改镜像 (类比C++中的class) docker-compose – 对容器的管理, 可以指定使用哪个容器, 并能修改容器 (类比C++中的对象实例) docker-compose 是一个指令, docker-compose.yml是其配置文件 docker-compose -h查看用法 ","date":"2021-08-28","objectID":"/posts/docker/:4:4","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"网桥 通过指令docker network可以查看 docker中的网桥信息网桥可以使多个容器组件局域网 容器可以在创建之前选择网桥 docker create --name [容器名称] --network [网桥名称] [镜像名称] 容器也可以在运行状态时 选择网桥 docker network connect [网桥名称] [容器名称] ","date":"2021-08-28","objectID":"/posts/docker/:4:5","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"卷 volume docker volume create 命令用于创建新卷。默认情况下，新卷创建使用 local 驱动，但是可以通过 -d 参数来指定不同的驱动。 docker volume ls 会列出本地 Docker 主机上的全部卷。 docker volume inspect 用于查看卷的详细信息。可以使用该命令查看卷在 Docker 主机文件系统中的具体位置。 docker volume prune 会删除未被容器或者服务副本使用的全部卷。 docker volume rm 删除未被使用的指定卷 ","date":"2021-08-28","objectID":"/posts/docker/:4:6","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"小技巧 使用镜像的时候, 不一定要做成容器可以使用 docker run -it image_name ","date":"2021-08-28","objectID":"/posts/docker/:5:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["system"],"content":"本文技巧大多来自网上, 只是笔者整理, 方便以后自己和别人查看. ","date":"2021-08-28","objectID":"/posts/mac/:0:0","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"mac系统怎么样 之前是为了学习linux命令行, 后来是开发环境使用到了xcode. mac是一款很稳定的系统, 但是稳定的代价是, 对于大部分游戏都不支持. 所以如果有游戏需求, 非常不建议使用mac. 17年开始使用mac, 缺点很明显, 对游戏的支持差. 优点也不少: 稳定 广告少! 广告少! 广告少! 命令行学习使用方便 原生软件xcode ","date":"2021-08-28","objectID":"/posts/mac/:1:0","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"mac初步整理 笔者有严重的强迫症, 新上手的东西必须整理一遍才去使用. 习惯性由大到小, 由外而内的整理方式. ","date":"2021-08-28","objectID":"/posts/mac/:2:0","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"界面的整理 launchpad图标大小整理 每一列图标数量 defaults write com.apple.dock springboard-rows -int 7 每一行图标数量 defaults write com.apple.dock springboard-columns -int 7 重启Launchpad defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock 慎用: 该指令重启launchpad的时候, 也会使launchpad的排序恢复默认值!!! 添加空白到Dock栏空白能使Dock中的程序更好的归类 defaults write com.apple.dock persistent-apps -array-add '{\"tile-type\"=\"spacer-tile\";}'; killall Dock ","date":"2021-08-28","objectID":"/posts/mac/:2:1","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"状态栏调整 按住Command之后, 鼠标可以拖动状态栏图标 ","date":"2021-08-28","objectID":"/posts/mac/:2:2","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"输入法的整理 习惯了搜狗输入法, 并且不喜欢多余的输入法. 因此安装完搜狗输入法for mac之后, 删除mac自带输入法. 具体步骤: 关闭 mac 系统的 SIP 重启系统，按住 Command + R 进入恢复模式 点击顶部菜单栏 实用工具 中的 终端 输入以下命令来禁用 SIP 保护机制 csrutil disable 执行后输出以下信息表示禁用成功 Successfully disabled System Integrity Protection. Please restart the machine for the changes to take effect. 重启系统 如果重新打开 SIP 的方法同上，只是终端中输入的命令改为以下命令 csrutil enable 先将输入法切换为系统自带的 ABC 输入法，然后打开终端输入以下命令 sudo open ~/Library/Preferences/com.apple.HIToolbox.plist 接着输入密码即可打开 com.apple.HIToolbox.plist 文件。（打开 .plist 文件需要安装有 Xcode 或者 PlistEdit Pro 也行） 依次点开 Root - AppleEnabledInputSources ，会看到一列 item ，找到其中 KeyboardLayout Name 为 ABC 的那一列，将整列 item 删掉，然后 command + S 保存。 接着重启电脑，打开键盘设置，就可以看到系统自带的 ABC 输入法已经被删掉了 如果又想用回自带输入法，只要在 偏好设置 - 键盘 - 输入法 里，按 + 号，把自带的输入法重新添加就可以了 ","date":"2021-08-28","objectID":"/posts/mac/:2:3","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"Terminal显示颜色设置 推荐iTerm代替 ls设置为ls -G的别名 在~/.bash_profile中加入下面的内容: alias ls=\"ks -G\" 并使脚本生效: source ~/.bash_profile 自定义颜色 在~/.bash_profile中加入下面的内容: export CLICOLOR=1 export LSCOLORS=gxfxaxdxcxegedabagacad 并使脚本生效: source ~/.bash_profile 颜色配置说明 LSCOLORS中一共11组颜色设置，按照先后顺序，分别对以下的文件类型进行设置： directory symbolic link socket pipe executable block special character special executable with setuid bit set executable with setgid bit set directory writable to others, with sticky bit directory writable to others, without sticky bit LSCOLORS中，字母代表的颜色如下： a 黑色 b 红色 c 绿色 d 棕色 e 蓝色 f 洋红色 g 青色 h 浅灰色 A 黑色粗体 B 红色粗体 C 绿色粗体 D 棕色粗体 E 蓝色粗体 F 洋红色粗体 G 青色粗体 H 浅灰色粗体 x 系统默认颜色 ","date":"2021-08-28","objectID":"/posts/mac/:2:4","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"删除不需要的系统软件 强烈建议不删除 ","date":"2021-08-28","objectID":"/posts/mac/:2:5","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"mac好用的软件 ","date":"2021-08-28","objectID":"/posts/mac/:3:0","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"Alfred Alfred 是加强版的聚焦搜索, 支持自定义编程, 非常强大 之前先买了Manico, paster 发现这些功能Alfred都可以更好的完成... ","date":"2021-08-28","objectID":"/posts/mac/:3:1","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"Karabiner Karabiner 是一款好用的键位映射软件 ","date":"2021-08-28","objectID":"/posts/mac/:3:2","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"1password 1password 是非常好用的密码管理软件 不再推荐使用, 支持不够好, 不如mac自带的好用 ","date":"2021-08-28","objectID":"/posts/mac/:3:3","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"Manico 不打开launchpad情形下, 快速打开需要的app软件 使用的manico, 虽然是收费的, 但是效果确实很不错 推荐使用Alfred代替 ","date":"2021-08-28","objectID":"/posts/mac/:3:4","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"paste paste 非常好用的粘贴复制软件, 记录了之前的复制记录 推荐使用Alfred代替 ","date":"2021-08-28","objectID":"/posts/mac/:3:5","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"HomeBrew HomeBrew 是一款包管理软件, 类似于ubuntu下的apt ","date":"2021-08-28","objectID":"/posts/mac/:3:6","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"iterm iterm 是非常好用的终端软件 ","date":"2021-08-28","objectID":"/posts/mac/:3:7","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"Annotate Annotate (App Store下载) 是非常好用的截屏软件, 同时支持gif ","date":"2021-08-28","objectID":"/posts/mac/:3:8","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"IINA IINA 是mac下最好用的视频软件 ","date":"2021-08-28","objectID":"/posts/mac/:3:9","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"mac实用技巧 ","date":"2021-08-28","objectID":"/posts/mac/:4:0","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"crontab 定时任务, 具体见 man crontab ","date":"2021-08-28","objectID":"/posts/mac/:4:1","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"Dock上隐藏运行的程序 进入要隐藏的程序的Contents目录 cd App_Path/Contents 编辑info.plist文件 sudo vim info.plist 添加下面的代码 \u003ckey\u003eLSUIElement\u003c/key\u003e \u003ctrue/\u003e 上面的方法并不是万能的，有些软件并不能这么设置，设置了会导致打不开，例如teamview，应该还要修改其他设置，但是大多数软件都可以通过此方法进行修改，如果出错了按此方法修改回去就可以了 关于teamviewer的隐藏，需要在终端执行下面的命令 sudo bash -c 'killall TeamViewer_Service; killall TeamViewer; killall TeamViewer_Desktop; perl -i -0pe \"s/\u003c\\/dict\u003e\\n\u003c\\/plist\u003e/\\t\u003ckey\u003eLSUIElement\u003c\\/key\u003e\\n\\t\u003cstring\u003e1\u003c\\/string\u003e\\n\u003c\\/dict\u003e\\n\u003c\\/plist\u003e/g\" /Applications/TeamViewer.app/Contents/Info.plist; codesign -f -s - /Applications/TeamViewer.app; launchctl unload /Library/LaunchDaemons/com.teamviewer.teamviewer_service.plist; launchctl load /Library/LaunchDaemons/com.teamviewer.teamviewer_service.plist' ","date":"2021-08-28","objectID":"/posts/mac/:4:2","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"tmux \u0026\u0026 screen 为什么使用tmux 和 screen: 远程登录操作时候, 因网络不稳定, 总是掉线, 导致东西无法保存讲解它们之前必须要先了解nohup 与 \u0026 nohup 与 \u0026 nohup与 \u0026都是后台运行 nohup会占用标准输出 \u0026则不会占用标准输出它们的作用都是为了防止session关闭后, 程序无法运行 但每个程序都要加上 nohup前缀 或者 \u0026后缀, 则会特别麻烦, 因此出现了screen与tmux screen screen属于GNU计划然其操作什么的并不友善, 个人更倾向于tmux 【基本指令】 screen | screen -S 创建screen screen -d detach screen 只有deatch之后 其他人才能attach screen -r reatach screen 链接screen screen -ls | screen -list 列出所有的screen 【快捷键操作】 screen的一个弊端就是将太多功能放在了快捷键上 而不是放在CMD上 C-a 为screen指令的前缀 C-a k kill C-a w 列出所有的screen窗口 – 亲测无效??? C-a p |C-a n 切换到上一个或下一个窗口 – 亲测无效?? C-a z 类似于emacs的C-z 将程序放入后台 可以通过jobs 和fg操作通过C-a z可以了解screen的工作原理 – screen就是新开了一个shell, 在里面有不同的窗口windows 然后可以在windows间切换, 或者是回到原先的shell中 【为什么放弃screen】虽然查看教程, 发现screen还有很多高级功能, 然而screen的窗口功能太不友好, 导致我经常不知道自己工作在哪个窗口下, 而且因为C-a w的无效, 很难有一览全局, 所以最后选择放弃screen, 改投tmux tmux 框架 server -\u003e session 01 | -\u003e session 02 | –\u003e socket 01(默认socket) -\u003e session 03 –\u003e socket 02(通过-L | -S生成的新的socket) … … 即一个server 多个session, session又属于socket 基本指令 tmux tmux ls 列出所有的tmux session, 注意没有- – tmux attach attch到上次的tmux session tmux attach -t session attch到指定的tmux session tmux kill-session -t 关闭session tmux kill-server -t 关闭server 注: 关闭server 将导致tmux关闭, tmux中的程序也会关闭如果session退出之前, tmux是挂起状态stopped,那么下次session重新链接后, 将导致tmux关闭 tmux new -s $sessionName 创建一个新的session, 并指定其名称, 不然就是递增数字 快捷键操作 tmux以C-b作为快捷键的前缀 C-b ? 列出所有的命令 C-b 数字 | n | p 切换窗口 C-b C-z 挂起程序 C-b d deatach类似于screen中的deatch deatch之后就可以回到正常的shell, 并使tmux运行在后台 为什么选择tmux 友好的界面, 友好的C-b ?帮助提示, 简单的操作 遗留问题 如果运行 tmux\u0026 (\u0026后台运行), 会导致莫名其妙的问题 如何使tmux在后台运行使用bg命令无效, 这与进程的状态有关…有时间再看 C-b d 使当前session deatch运行在后台 ","date":"2021-08-28","objectID":"/posts/mac/:4:3","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"| \u0026\u0026 xargs 管道是实现“将前面的标准输出作为后面的标准输入” xargs是实现“将标准输入作为命令的参数” ","date":"2021-08-28","objectID":"/posts/mac/:4:4","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"mac卡顿处理 删除Macintosh HD/系统/资源库/Caches中的文件 删除Macintosh HD/资源库/Caches中的文件 如果以上无效, 建议更换操作系统版本, 比如从macOS high sierra更换为macOS Mojave ","date":"2021-08-28","objectID":"/posts/mac/:4:5","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"安装gcc (g++) mac上默认的gcc(g++)实际是苹果的Apple LLVM. 不是说这个不好, 而是很多时候gnu的gcc对于c++更标准些(待商榷?). 安装port 搜索gcc port search gcc 安装gcc sudo port install gcc8 #这里选了最新的稳定版 不要使用brew安装, 不然后面无法使用port指定苹果的gcc版本 查看安装的版本 port select --list gcc 切换版本 sudo prot select --set gcc mp-gcc8 清空bash缓存 hash -r 查看gcc版本 gcc -v ## 或g++ -v ","date":"2021-08-28","objectID":"/posts/mac/:4:6","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"实用快捷键 快捷键 功能说明 备注 Command + c 选中文件 Command + v 粘贴 Command-c之后才能操作 Command + option + v 剪切 Command-c之后才能操作 Command + 空格 聚焦搜索 非常好用的搜索 ","date":"2021-08-28","objectID":"/posts/mac/:4:7","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"无用程序关闭 聚焦作用: Command+空格的 聚焦搜索影响进程: mds、mds_stores、mdworker 关闭原因: 实际没必要, 追求效率的, 可以关掉 #关闭 sudo mdutil -a -i off #打开 sudo mdutil -a -i on ","date":"2021-08-28","objectID":"/posts/mac/:4:8","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"ssh远程连接mac os, 中文乱码 这种情况一般是终端和服务器的字符集不匹配，MacOSX下默认的是utf8字符集。输入locale可以查看字符编码设置情况，而我的对应值是空的。因为我在本地和服务器都用zsh替代了bash，而且使用了oh-my-zsh，而默认的.zshrc没有设置为utf-8编码，所以本地和服务器端都要在.zshrc设置，步骤如下，bash对应.bash_profile或.bashrc文件。 在.bash_profile中增加 export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 source .bash_profile locale 查看下是否设置成功 完成 ","date":"2021-08-28","objectID":"/posts/mac/:4:9","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["system"],"content":"ffmpeg ffmpeg -i https://××××××××/really.m3u8 -c copy xxx.mp4 ","date":"2021-08-28","objectID":"/posts/mac/:4:10","tags":["mac"],"title":"mac实用技巧","uri":"/posts/mac/"},{"categories":["protocol"],"content":"ssh简述 ","date":"2021-08-28","objectID":"/posts/ssh/:0:0","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"功能 ","date":"2021-08-28","objectID":"/posts/ssh/:1:0","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"安装 ","date":"2021-08-28","objectID":"/posts/ssh/:2:0","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"配置 ","date":"2021-08-28","objectID":"/posts/ssh/:3:0","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"超时断开处理 client 超时断开处理 ServerAliveInterval 120 这行内容的含义是，每120s，客户端就向服务端发送一个空的包。让服务端认为客户端在线，因此就不会超时断开。当然，如果服务端设置的超时时间是60s，你这里设置的时间肯定要小于60s。不过服务端设置超时时间为60s的情况非常罕见，而且是出错的时候才会出现这种情况。所以这里设置为120s即可 server 超时断开处理 ","date":"2021-08-28","objectID":"/posts/ssh/:3:1","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"使用","date":"2021-08-28","objectID":"/posts/ssh/:4:0","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"应用场景 ","date":"2021-08-28","objectID":"/posts/thread/:1:0","tags":null,"title":"多线程总结","uri":"/posts/thread/"},{"categories":["protocol"],"content":"创建 ","date":"2021-08-28","objectID":"/posts/thread/:2:0","tags":null,"title":"多线程总结","uri":"/posts/thread/"},{"categories":["protocol"],"content":"使用","date":"2021-08-28","objectID":"/posts/thread/:3:0","tags":null,"title":"多线程总结","uri":"/posts/thread/"},{"categories":["protocol"],"content":"socket相关网络编程 ","date":"2021-08-28","objectID":"/posts/socket/:0:0","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"基本概念 ","date":"2021-08-28","objectID":"/posts/socket/:1:0","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"socket socket是 [应用层] 与 [传输层, 网络层] 之间的一个抽象层它的出现是为了简化网络进程通信 linux头文件 usr/include/x86_64-linux-gnu/sys/socket.h 结构体 sockaddr 函数 socket() connect() send() recv() shutdown() socket() bind() lisent() accept() recv() send() shutdown() g++的默认目录中已经包含了sys/的上层目录 usr/include/netinet/in.h 结构体 AF_INET 中的 sockaddr_in AF_INET6 中的 sockaddr_in6 AF_UNIx 中的 sockaddr_un user/include/arpa/inet.h 函数 htons() inet_addr() unistd.h 函数 close() socket函数 socket(domain, socket_type, protol) domain socket_type protol socket()本质是创建了一个进程文件表, 返回的值为指向进程文件表的指针的索引. bind(fd, sockaddr*, len) fd: socket()中的文件表指针的索引 sockaddr: 地址, 端口 len: sockaddr的长度 \u003c1\u003e 比较有意思的是sockaddr根据family的不同, 可以与不同的结构体互转比如 AF_INET sockaddr_in AF_INET6 sockaddr_in6 AF_UNIX sockaddr_un 这几种结构体都与sockaddr可互转(字节对齐blabla) bind()本质是在补充socket()创建的文件表. socket()时候该文件表很多值都是空的, bind()来补充因为client 在connect的时候, 系统会自动分配端口,以及绑定本机ip, 所以client的socket一般不必要使用bind() connet(fd, sockaddr*, len) 连接到其他scokaddr listen(fd, iMaxNum) iMaxNum是队列中的最大数, 并不是指可连接的socket数目 一般只在server开启listen(), 监听指定的端口信息 accept() accept()会造成阻塞. 它会将listen()中的sockaddr进行处理处理流程是 accept()会创建一个新的fd_connet, 此fd_connet公用server socket() fd的端口和地址但是fd_connect仅仅是用来传输数据的 recv(fd, msg) send(fd, msg) 至accetp()时候, 一切操作就和在本地上操作一样, 所以这里的recv() 和 send()操作与本机上的文件操作是一样的 close(fd) shutdown(fd, type) linux一切皆是file原则, fd可以关闭 [ip, port]相关函数 点分十进制ip 是以字符串形式存储的 网络字节序 即 32位的二进制 //in_addr struct in_addr { in_addr_t s_addr; }; //in_addr_t typedef unsigned long in_addr_t 函数原型: in_addr_t inet_addr(const char* strptr); 若字符串有效, 则将点分十进制IP字符串转换为网络字节序地址，否则为INADDR_NONE 函数原型：int inet_aton(const char *IP, struct in_addr *addr); 将点分十进制IP地址转换为网络字节序存储在addr中，并且返回该网络字节序表示的无符号整数 函数原型：char *inet_ntoa(struct in_addr in); 将网络字节序的IP地址（也就是结构体in_addr类型变量）转化为点分十进制的IP地址（字符串) socket fd本质 socket本质是维护了fd进程文件表, 如下: 名称 说明 备注 fd 文件描述符, 表的索引 host 1. 域名(DNS /etc/hosts) 2. ip地址 兼容Ipv4 Ipv6是难点 服务 1. 服务名称(/etc/services) 2. 端口 协议 1. 传输层(/etc/protol) 2. 网络层 链路层用到的比较少 网络 1. 网络名称?(DNS /etc/networks) 2. ip地址 谁会使用到这些信息?? 期间用到的函数主要有 尽量使用ipv4, ipv6通用的函数 流程函数 socket() bind() listen() connect() accept()等 字节处理函数处理大小字节序 htons() htonl() ntohs() ntohl() 处理域名与十分数字 getaddrinfo() getnameinfo() 处理sockaddr结构体的函数 getsockname() 返回local fd getpeername() 返回remote fd ","date":"2021-08-28","objectID":"/posts/socket/:1:1","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"socket问题 阻塞 影响并发, 多路复用 解决方案: 使用非阻塞模型, 比如select, poll, epoll(linux下特有), IOCP(windows下特有) 多线程 – 不推荐使用 多进程 – 不推荐使用 粘包解决方案: 限制发送大小 每个消息增加长度标识 ","date":"2021-08-28","objectID":"/posts/socket/:1:2","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"I/O模型 强烈建议阅读 (链接过期, 直接搜狗搜索epoll, “epoll本质\"即是) 阻塞式 非阻塞 select poll epoll (linux特有) IOCP (windows特有) ","date":"2021-08-28","objectID":"/posts/socket/:1:3","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"epoll使用 epoll本身为我们处理了什么 之前socket::recv()时, 导致我们的进程阻塞 现在socket::recv()时, 使epoll阻塞; epoll中断时, 告之进程 有了epoll我们还需要处理什么 创建epoll对象 添加检视的fd对象 – op, epoll_event 检测是否有中断, 然后处理 ","date":"2021-08-28","objectID":"/posts/socket/:1:4","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"socket属性 ","date":"2021-08-28","objectID":"/posts/socket/:2:0","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"keep live机制 当socket服务端开启keep live之后, 服务器检测到 一定时间内 socket不活动的时候, 就会每隔 固定时间 向该sockt发送 固定次数 的查询. 如果一直没有回应, 服务端则关闭该socket 对应的字段为: tcp_keepalive_time（开启keepalive的闲置时长） tcp_keepalive_intvl（keepalive探测包的发送间隔） tcp_keepalive_probes （如果对方不予应答，探测包的发送次数） ","date":"2021-08-28","objectID":"/posts/socket/:2:1","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"编程实例 ","date":"2021-08-28","objectID":"/posts/socket/:3:0","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"原始socket模型, recv()中处理分包粘包 原始socket模型, 考虑到tcp分包 //网络读取 -- 系统检测到网络I/O事件时, 调用该函数 LRESULT CTCPSocketService::OnSocketNotifyRead(WPARAM wParam, LPARAM lParam) { //读取数据 //使用中间量m+cbRecvbuf来当做缓冲区 //使用中间量m_wRecvsize来记录当前缓冲区中已读数据大小 int iRetCode = recv(m_hSocket, (char *)m_cbRecvBuf + m_wRecvSize, sizeof(m_cbRecvBuf) - m_wRecvSize, 0); //读取失败, 则返回SOCKET_ERROR if (iRetCode == SOCKET_ERROR) { ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf)); m_wRecvSize = 0; return 1;//\"网络连接关闭，读取数据失败\"; } //读取成功, 则返回读取到的数据的大小 m_wRecvSize += iRetCode; //在tcp数据中, 增加包的大小, 用来校验是否读取完毕; TCP_Head * pHead = (TCP_Head *)m_cbRecvBuf; WORD wPacketSize = pHead-\u003eTCPInfo.wPacketSize; // //数据包大小校验 if (wPacketSize \u003e (SOCKET_TCP_BUFFER + sizeof(TCP_Head))) { //当发生错误时候, 缓冲区置位 ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf)); m_wRecvSize = 0; return 3;//\"数据包太大\"; } //解析数据 if (m_wRecvSize == wPacketSize) //数据全部接受完毕之后 再解析 { //拷贝数据 BYTE cbDataBuffer[SOCKET_TCP_BUFFER+sizeof(TCP_Head)]; CopyMemory(cbDataBuffer, m_cbRecvBuf, wPacketSize); //置位缓冲信息 -- 缓冲区中只保存一条tcp信息 m_wRecvSize = 0; ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf)); //解密数据 WORD wRealySize = CrevasseBuffer(cbDataBuffer, wPacketSize); if(wRealySize \u003c sizeof(TCP_Head)) return 4; //解析后的数据错误 //获得TCP_Head TCP_Command Command = ((TCP_Head *)cbDataBuffer)-\u003eCommandInfo; //获得实际的数据 void * pDataBuffer = cbDataBuffer + sizeof(TCP_Head); //实际的数据 WORD wRealDataSize = wRealySize - sizeof(TCP_Head); //实际的数据大小 //内核命令 if (Command.wMainCmdID == MDM_KN_COMMAND) { switch (Command.wSubCmdID) { case SUB_KN_DETECT_SOCKET: //网络检测 { //发送数据 SendData(MDM_KN_COMMAND, SUB_KN_DETECT_SOCKET, pDataBuffer, wRealDataSize); break; } } continue; } //处理数据 bool bSuccess = m_QueueServiceEvent.PostTCPSocketReadEvent(m_wServiceID, Command, pDataBuffer, wRealDataSize); if (bSuccess == false) return 5;//\"网络数据包处理失败\"; }; return 0; } ","date":"2021-08-28","objectID":"/posts/socket/:3:1","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"数据库开发 ","date":"2021-08-28","objectID":"/posts/sql/:0:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"数据库开发 ","date":"2021-08-28","objectID":"/posts/sql/:1:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"win下 详细解释 原生接口 ODBC OLE ADO ","date":"2021-08-28","objectID":"/posts/sql/:1:1","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"linux下 原生接口 ODBC ","date":"2021-08-28","objectID":"/posts/sql/:1:2","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"sqlserver ","date":"2021-08-28","objectID":"/posts/sql/:2:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"优缺点 ","date":"2021-08-28","objectID":"/posts/sql/:2:1","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"Docker安装sqlserver 官方文档 搜索镜像 docker search mssql 安装镜像(这个是官网的) docker pull microsoft/mssql-server-linux 运行镜像, 创建容器 docker run -e “ACCEPT_EULA=Y” -e “SA_PASSWORD=hack@2020” -p 9988:1433 –name mssql -d microsoft/mssql-server-linux 注: 如果不指定映射的端口, 则可能随机使用一个端口密码必须8位数, 否则会创建失败 -p 第一个参数为主机端口, 第二参数为docker容器端口 进入容器 docker exec -it mssql bash 测试sql server命令 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P “passwd” 如果启动失败 docker logs mssql 查看日志信息 ","date":"2021-08-28","objectID":"/posts/sql/:2:2","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"sqlcmd用法 登录 /opt/mssql-tools/bin/sqlcmd -S 127.0.0.1 -U SA -P \"hack@2020\" 执行语句查询 select * from sys.databeses go 一定记得使用go ","date":"2021-08-28","objectID":"/posts/sql/:2:3","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"unicode支持 排序规则会影响字符集 服务器 排序规则 数据库 排序规则 表中的字段 排序规则 排序规则会影响字符集, 比如排序规则为xx_UTF8, 那么其默认的字符集为unicode nchar nvarchar类型会无视排序规则, 直接把改字段变为unicode编码 使用的时候 记得加N, exp: N'排序规则' ","date":"2021-08-28","objectID":"/posts/sql/:2:4","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"client 与 server 最理想的状态 server 是 unicode编码(只要nchar, nvarchar即可) client 是 unicode编码 unixodbc 编译的时候, 添加了 utf8的支持 ./configure --enable-iconv=yes --with-iconv-char-enc=UTF-8 总结: 数据库表字段的编码, 服务器程序运行环境的编码, unixodbc编译时候的字符编码三者需要统一, 这样写入数据库的时候 才不会乱码 服务器运行环境 locale可以查看 locale -a显示系统支持的字符集 ","date":"2021-08-28","objectID":"/posts/sql/:2:5","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"遇到的奇怪的问题 \u0026\u0026 解决思路 简述: 通过odbc 操作sqlserver, 插入中文错误现象: 读取sqlserver中文正常 插入sqlserver中文乱码 思路: 查看sqlserver 的编码集(排序规则) 查看qy-server的运行环境 locale 编译unixodbc的时候是否加入了编码的支持 查看odbc的配置文件 odbcinst -j 这次的问题在于 odb的配置文件中 有重名的DSN ","date":"2021-08-28","objectID":"/posts/sql/:2:6","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"mysql 优点: 缺点: 没有存储过程 ","date":"2021-08-28","objectID":"/posts/sql/:3:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"ODBC 安装odbc驱动 建议使用官方源码安装 http://www.unixodbc.org 下载源码之后 ./configure --enable-gui=no --enable-iconv=yes --with-iconv-char-enc=UTF-8 ./configure --enable-gui=no --enable-iconv=yes --with-iconv-char-enc=GB18030 这里需要添加中文支持, 不然会发生数据库读取中文正常, 写入中文时候乱码 安装对应的sql的驱动 这里sql的驱动是 odbc下的sql驱动 以mssql为例下载并安装 查看sql的驱动信息 debin在 /usr/local/etc/odbcinst.ini [ODBC Driver 17 for SQL Server] Description=Microsoft ODBC Driver 17 for SQL Server Driver=/opt/microsoft/msodbcsql17/lib64/libmsodbcsql-17.6.so.1.1 UsageCount=1 说明sql的驱动安装成功 编写DSN debin在 /usr/local/etc/odbc.ini [MssqlDB] Driver = ODBC Driver 17 for SQL Server Server = tcp:172.16.238.10,1433 测试连接 isql MssqlDB user_name user_passwd -v 如果连接成功 +---------------------------------------+ | Connected! | | | | sql-statement | | help [tablename] | | quit | | | +---------------------------------------+ ","date":"2021-08-28","objectID":"/posts/sql/:4:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"常用数据库语句 sql server 查询sql版本 select @@version go 查询支持的字符集 只有2019版本 才支付utf-8字符集 select * from ::fn_helpcollations() go 查询当前系统的排序规则 SELECT SERVERPROPERTY('Collation') 查询排序规则的字符集 SELECT COLLATIONPROPERTY('Chinese_PRC_Stroke_CI_AI_KS_WS', 'CodePage') 936 简体中文GBK 950 繁体中文BIG5 437 美国/加拿大英语 932 日文 949 韩文 866 俄文 65001 unicode UFT-8 查询所有的库 select * from sys.databeses order by name go 有时候显示的数据太多, 我们可以只显示需要的比如 select name from sys.databeses order by name go 查询当前数据库所有表 方法一 select * from sys.objects where type='U' go –XType=‘U’:表示所有用户表; –XType=‘S’:表示所有系统表; 方法二 select * from sys.tables go 查询表中所有的字段 SELECT * FROM SysColumns WHERE id=Object_Id(‘TableName’); SELECT COLLATIONPROPERTY(‘Chinese_PRC_CS_AS_WS’, ‘CodePage’) SELECT COLLATIONPROPERTY(‘Chinese_PRC_90_CI_AS_SC_UTF8’, ‘CodePage’) SELECT COLLATIONPROPERTY(‘Latin1_General_100_CI_AI_SC_UTF8’, ‘CodePage’) SELECT COLLATIONPROPERTY(‘SQL_Latin1_General_CP1_CI_AS’, ‘CodePage’) SELECT COLLATIONPROPERTY(‘Chinese_Simplified_Stroke_Order_100_CI_AI’, ‘CodePage’) ","date":"2021-08-28","objectID":"/posts/sql/:5:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":null,"content":"协议太多, 不好分类, 真是乱七八糟 ","date":"2021-08-28","objectID":"/posts/protocal/:0:0","tags":null,"title":"乱七八糟的协议合集","uri":"/posts/protocal/"},{"categories":null,"content":"简单协议 ","date":"2021-08-28","objectID":"/posts/protocal/:1:0","tags":null,"title":"乱七八糟的协议合集","uri":"/posts/protocal/"},{"categories":null,"content":"字符编码 写入内存过程: 符号 –\u003e 根据符号表(编码表), 找到符号的value –\u003e 根据实现算法(utf-8等), 计算出在内存中的值 –\u003e 内存值 解析过程: 内存值 –\u003e 根据算法, 计算出符号的value –\u003e 根据符号表, 找到value对应的符号 –\u003e 符号 编码小知识 ios-8859-1 为http上所使用的编码 我在gitlab上面下载的代码虽然最原始是GBK编码（win下），下载到mac后 通过file -I 会被识别为iso-8859-1, 就是因为是http协议下载的。所以转换为mac下可以使用的时候，做法应该是： iconv -f GBK -t UTF-8 file \u003e file2 ASCII \u0026\u0026 Unicode 由来 ASCII码 – 保存英文以及一些特殊控制字符 byte即2^8=256个符号 Unicode – 1. ASCII符号表只能有256个符号, 不够其他国家使用, 比如汉字有10W+ 各个国家符号表(key)对应的value不同, 导致web通信困难(乱码), 为了统一, unicode出现 Unicode \u0026\u0026 utf-8 Unicod只是符号表, 其内部类似于这样 符号 Value 严 4E25 即我们的汉字\"严\" 对应的Unicode Value就是 4E25 但Unicode只是规定了符号表的map(key, value), 并没有规定value在内存中的存储形式, 比如little endian中\"严\"是25 4E 第一个字节为25, 第二个字节为4E 而 big endian中则是 4E 25 除了大小字节序问题, 4E 25的如何实现也有非常多的方法常见的有utf-8 utf-16等等 所以utf-8只是实现Unicode的一种方式比较重要的一点是, 为了兼容ASCII, ASCII对应的符号value, 在ASCII与utf-8中一致(即英文与控制符号一致) ASCII \u0026\u0026 Unicode转换 这个转换确实纠结了我很久 转换的复杂性在于 字节长度问题 ASCII码的value是一个BYTE, 其value在内存中的实现也是一个byte Unicode的value是二个byte, 其Value在内存中的实现(utf-8)有1-5个byte 字节长度不同, 导致我们需要在char* 和 wchar_t*间转换 编码格式注: 其实1应该也属于编码格式 因为ASCII 和 Unicode(自身)之间的实现方式差异很大, 在其中转换的时候要非常熟悉各种编码实现的原理 为了解决2个问题, 可以考虑一下2个函数, 虽然是windows下的: MultiByteToWideChar和WideCharToMultiByte ","date":"2021-08-28","objectID":"/posts/protocal/:1:1","tags":null,"title":"乱七八糟的协议合集","uri":"/posts/protocal/"},{"categories":null,"content":"大小字节序 对于多字节, 比如 AE FF Big—Endian 大字节如果在内存中 0x 0000 0001 AE 0x 0000 0002 FF 即内存中的低位保存的是高字节 则为Big-Endian little-Endian 小字节如果在内存中 0x 0000 0001 FF 0x 0000 0002 AE 即内存中的低位保存的是低字节 则为little-Endian 网络上的传输为大字节序所以在host传入到internet时候, 比如socket, 应该将字节序转换 ","date":"2021-08-28","objectID":"/posts/protocal/:1:2","tags":null,"title":"乱七八糟的协议合集","uri":"/posts/protocal/"},{"categories":null,"content":"ip地址详解 主机host的数量 决定了 选择 A类 B类 或者C类地址 hosts的划分, 即子网 决定了 掩码的值 掩码的值 决定了 ip地址的网络id 与 主机id A类的掩码 为 255.0.0.0 B类的掩码 为 255.255.0.0 C类的掩码 为 255.255.255.0 通过A类掩码 计算出 所能承载的host数量n, 按ip从0.0.0.0开始, 数到host数量n, 计算出A类ip地址范围 通过B类掩码 计算出 所能承载的host数量m 按A类广播地址+1开始, 数到m, 计算出B类ip地址范围 通过C类掩码 计算出 所能承载的host数量x 按B类广播地址+1开始, 数到x, 计算出C类ip地址范围 子网的第一个ip地址 和最后一个ip地址有特殊含义第一个ip地址为 本机地址?????? 最后一个ip地址为广播地址这2个地址 被设计用来做其他事情, 设计的时候不应该考虑吧进去 ","date":"2021-08-28","objectID":"/posts/protocal/:1:3","tags":null,"title":"乱七八糟的协议合集","uri":"/posts/protocal/"},{"categories":null,"content":"基本模型概念: 阻塞, 非阻塞 同步, 异步 ","date":"2021-08-28","objectID":"/posts/module/:0:0","tags":null,"title":"基本模型概念","uri":"/posts/module/"},{"categories":null,"content":"阻塞, 非阻塞 阻塞 进程(线程)挂起, 由运行队列转移到等待队列 不消耗内存 非阻塞 进程(线程)不挂起 ","date":"2021-08-28","objectID":"/posts/module/:1:0","tags":null,"title":"基本模型概念","uri":"/posts/module/"},{"categories":null,"content":"同步, 异步 同步 等待某事执行完毕, 再继续往下执行 异步 无须等待执行完毕, 可以继续往下执行 与 [阻塞, 非阻塞] 差异相同点 阻塞 或 同步, 都会使程序陷入 “等待” 状态 差异点 阻塞是指进程(线程)的一种状态 同步, 异步是一种程序设计 ","date":"2021-08-28","objectID":"/posts/module/:2:0","tags":null,"title":"基本模型概念","uri":"/posts/module/"},{"categories":["protocol"],"content":"正则表达式 ","date":"2021-08-28","objectID":"/posts/regex/:0:0","tags":null,"title":"正则表达式","uri":"/posts/regex/"},{"categories":["protocol"],"content":"推荐文章 正则表达式30分钟入门教程 ","date":"2021-08-28","objectID":"/posts/regex/:1:0","tags":null,"title":"正则表达式","uri":"/posts/regex/"},{"categories":["protocol"],"content":"完成端口 ","date":"2021-08-28","objectID":"/posts/iocp/:0:0","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["protocol"],"content":"说明 完成端口IOCP是windows下的异步非阻塞模型 IOCP I/O completion port 推荐文档: 完成端口详解 – by 小猪 ","date":"2021-08-28","objectID":"/posts/iocp/:1:0","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["protocol"],"content":"原理图 ","date":"2021-08-28","objectID":"/posts/iocp/:2:0","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["protocol"],"content":"TODO 使用模型1 模型1 ","date":"2021-08-28","objectID":"/posts/iocp/:2:1","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["protocol"],"content":"使用模型2 模型2 ","date":"2021-08-28","objectID":"/posts/iocp/:2:2","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["protocol"],"content":"具体步骤 建立完成端口 HANDLE m_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0 ); if (m_hCompletionPort == NULL) { std::cout \u003c\u003c \"完成端口 创建失败\" \u003c\u003c std::endl; } 建立Worker线程 //获取系统cpu核心数量 SYSTEM_INFO SystemInfo; GetSystemInfo(\u0026SystemInfo); unsigned int dwThreadCount = SystemInfo.dwNumberOfProcessors; //建立worker线程 unsigned int m_nThreads = dwThreadCount * 2; //江湖传言... HANDLE* m_phWorkerThreads = new HANDLE[m_nThreads]; for (int i = 0; i \u003c m_nThreads; i++) { m_phWorkerThreads[i] = ::CreateThread(0, 0, _WorkerThread, …); } 创建一个用于监听的Socket，绑定到完成端口上，然后开始在指定的端口上监听连接请求 //创建监听线程 //监听连接 hConnectSocket = WSAAccept(m_hListenSocket, (SOCKADDR *) \u0026 SocketAddr, \u0026nBufferSize, NULL, NULL); if (hConnectSocket == INVALID_SOCKET) { std::cout \u003c\u003c \"accept failed\" \u003c\u003c std::endl; return false; } //绑定到完成端口上 -- 注意这里socket对象 CreateIoCompletionPort((HANDLE)hConnectSocket, m_hCompletionPort, NULL, 0); //为该socket投递recv请求 //buf, bytes, flags, overlapped 对象初始化... 如果不初始化, 非常容易导致错误 int iRetCode = WSARecv(hConnectSocket, \u0026buf, 1, \u0026bytes, \u0026flags, (OVERLAPPED*)m_recvOverlapped, NULL); if (iRetCode == SOCKET_ERROR) { if (WSAGetLastError() != WSA_IO_PENDING) { //WSARecv error return false; } // WSARecvFrom() is now operating in the background, // the IOCP port will be signaled when finished... } else { // data is already available, // the IOCP port will be signaled immediately... } woker线程处理 //等待完成端口 if(!GetQueuedCompletionStatus(m_hCompletionPort, \u0026rbytes, (PULONG_PTR) \u0026 pServerSocketItem, (LPOVERLAPPED*)\u0026myOverlapped, INFINITE)) { if(myOverlapped) { CLog::Log(log_debug, \"[socket::server] rs thread run OnEventThreadRun WSARecvFrom() failed\"); } else { CLog::Log(log_debug, \"[socket::server] rs thread run OnEventThreadRun GetQueuedCompletionStatus() failed\"); } return false; } //注意: 处理的时候 注意上锁 switch(myOverlapped-\u003emask) { case recv: { do_recv(); //一般do_recv()中需要投递 WSARecv()请求 break; } case send: { do_send(); break; } } ","date":"2021-08-28","objectID":"/posts/iocp/:3:0","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["protocol"],"content":"linux下静态库 \u0026\u0026 动态库 ","date":"2021-08-28","objectID":"/posts/dll/:0:0","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["protocol"],"content":"差异区别 编译连接静态库时, 会copy一份静态库镜像到目标文件; 编译连接动态库时, 不会copy 程序运行时, 无须再去访问原静态库; 程序运行时, 要能访问到动态库文件 静态库 .a 动态库 .so (shared object) ","date":"2021-08-28","objectID":"/posts/dll/:1:0","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["protocol"],"content":"生成方式 静态库 A.由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表 B.ar命令将很多.o转换成.a，生成文静态库 动态库 A.gcc 加特定参数 编译 fPIC生成动态的.o文件; shared把动态.o文件打包为动态库 gcc -fPIC file1.c -c //这一步生成file1.o gcc -shared file1.o -o libtest.so //把.o文件打包为动态库(.o文件必须是 fPIC生成) ","date":"2021-08-28","objectID":"/posts/dll/:2:0","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["protocol"],"content":"常见问题 运行时候找不到动态库, 处理方式 （1) 最直接最简单的方法就是把so拉到/usr/lib或/lib中去，但这好像有点污染环境吧？ （2）export LD_LIBRARY_PATH=$(pwd) （3）可以在/etc/ld.so.conf文件里加入我们生成的库的目录，然后/sbin/ldconfig 加载动态库函数原型：void *dlopen(const char *libname,int flag); 参数中的libname一般是库的全路径，这样dlopen会直接装载该文件； 如果只是指定了库名称，在dlopen在查找库的过程中会按照如下路径进行搜索： a.根据环境变量LD_LIBRARY_PATH查找 b.根据/etc/ld.so.cache查找 c.查找依次在/lib和/usr/lib目录查找。 flag参数表示处理未定义函数的方式，可以使用RTLD_LAZY或RTLD_NOW。 RTLD_LAZY表示暂时不去处理未定义函数，先把库装载到内存，等用到没定义的函数再说； RTLD_NOW表示马上检查是否存在未定义的函数，若存在，则dlopen以失败告终。 ","date":"2021-08-28","objectID":"/posts/dll/:3:0","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["language"],"content":"protobuf使用 ","date":"2021-08-28","objectID":"/posts/protobuf/:0:0","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["language"],"content":"安装 ","date":"2021-08-28","objectID":"/posts/protobuf/:1:0","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["language"],"content":"使用 ","date":"2021-08-28","objectID":"/posts/protobuf/:2:0","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["language"],"content":"语法 ","date":"2021-08-28","objectID":"/posts/protobuf/:3:0","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["language"],"content":"repeated","date":"2021-08-28","objectID":"/posts/protobuf/:3:1","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["project"],"content":"使用docker搭建web, 包含web服务器(nginx), php7.4.7, lavarel7.12.0, mssql ","date":"2021-08-28","objectID":"/posts/web/:0:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"基本信息 软件 版本 备注 docker desktop 2.0.0.3 sdocker engine 18.09.2 laravel 7.12.0 php php:7.4.7-fpm mssql 2017-CU13 ","date":"2021-08-28","objectID":"/posts/web/:1:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"架构分析 +-------------+ +-------------+ +--------------+ | nginx | -----\u003e | php | -----\u003e | mssql | | | | | | | +-------------+ +-------------+ +--------------+ ^ | | \u003c--- | \\------ +--+-------+ \\---+------------+ | laravel | | composer | | | | | +----------+ +------------+ 通过composer把laravel信息打入到php载体中(这里是docker容器) 在docker_compose中设置转移信息, 使nginx的信息交由php处理 开发环境需要laraverl \u0026\u0026 composer, 生产环境不需要 ","date":"2021-08-28","objectID":"/posts/web/:2:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"下载laravel \u0026\u0026 compose完成laravel的项目依赖 下载laravel laravel对php有版本要求, 所以这里下载的是v7.12.0 https://github.com/laravel/laravel/releases/tag/v7.12.0 完成laravel的依赖安装 这里compose直接安装在了本地mac环境上, 没有装在docker容器中, 效果一样 不知道为什么, 有些文件下载会失败, 建议多敲几次该命令 # 进入laravel项目目录, 并输入 composer install ","date":"2021-08-28","objectID":"/posts/web/:3:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"编写dockerfile \u0026\u0026 docker-compose.yml 参考文档 dockerfile 与 docker-compose.yml应该在laravel项目的根目录下, 因为后续有把laravel打入到php载体的操作 docker-compose.yml version: '2' services: # The Application php-fpm app: # 这里通过app.dockerfile安装 build: context: ./ dockerfile: app.dockerfile working_dir: /var/www volumes: ​ - ./:/var/www environment: ​ - \"DB_PORT=3306\" ​ - \"DB_HOST=database\" # The Web Server web: build: context: ./ dockerfile: web.dockerfile working_dir: /var/www # 这里表示继承app中的设定 volumes_from: ​ - app ports: ​ - 8080:80 # The Database database: image: mysql:5.6 volumes: ​ - dbdata:/var/lib/mysql environment: ​ - \"MYSQL_DATABASE=homestead\" ​ - \"MYSQL_USER=homestead\" ​ - \"MYSQL_PASSWORD=secret\" ​ - \"MYSQL_ROOT_PASSWORD=secret\" ports: ​ - \"33061:3306\" volumes: dbdata: app.dockerfile 这里注释了php的扩展, 但仍然安装laravel成功了, 很奇怪 # php -- 使用特定7.4.7 From php:7.4.7-fpm #RUN apt-get update \u0026\u0026 apt-get install -y libmcrypt-dev \\ # mysql-client libmagickwand-dev --no-install-recommends \\ # \u0026\u0026 docker-php-ext-install mcrypt pdo_mysql web.dockerfile FROM nginx:1.10 ADD vhost.conf /etc/nginx/conf.d/default.confx nginx config配置 server { listen 80; index index.php index.html; root /var/www/public; location / { try_files $uri /index.php?$args; } location ~ \\.php$ { fastcgi_split_path_info ^(.+\\.php)(/.+)$; # 这里表示把信息转移给app即php处理 fastcgi_pass app:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; } } ","date":"2021-08-28","objectID":"/posts/web/:4:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"安装docker-compose.yml中信息 # 进入到docker-compose-yml的目录 docker-compose up ","date":"2021-08-28","objectID":"/posts/web/:5:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"laravel打入到php载体中 laravel环境配置 # 进入到laravel的根目录 mv .env.example .env 应用程序密钥和优化 docker-compose exec app php artisan key:generate docker-compose exec app php artisan optimize ","date":"2021-08-28","objectID":"/posts/web/:6:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"测试 访问http://0.0.0.0:8080 应该能看到laravel的标志 ","date":"2021-08-28","objectID":"/posts/web/:7:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"生产环境优化 可以把已经配置好的容器打包为镜像, 并保存为镜像文件. 这样生产环境搭建的时候, 就无需再配置环境(php载体的laravel环境), 同时生成环境可以通过镜像文件加载, 免除了网络问题卡下载的问题. ","date":"2021-08-28","objectID":"/posts/web/:8:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"遗留问题 docker php容器映射问题如何把php容器的路径 映射出来 生产环境 docker-compse.yml编写问题 ","date":"2021-08-28","objectID":"/posts/web/:9:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["language"],"content":"web前端三剑客 ","date":"2021-08-28","objectID":"/posts/html/:0:0","tags":null,"title":"html \u0026\u0026 css \u0026 js","uri":"/posts/html/"},{"categories":["language"],"content":"功能 html – 骨骼 css – 组织 js – 血液 ","date":"2021-08-28","objectID":"/posts/html/:1:0","tags":null,"title":"html \u0026\u0026 css \u0026 js","uri":"/posts/html/"},{"categories":["language"],"content":"Bootstrap bootstrap是web前端框架, 封装了html, css ","date":"2021-08-28","objectID":"/posts/html/:2:0","tags":null,"title":"html \u0026\u0026 css \u0026 js","uri":"/posts/html/"},{"categories":["language"],"content":"AdminLTE AdminlLTE是web前端框架, 封装了Bootstrap和js框架推荐使用 使用简单 代码简洁干净 ","date":"2021-08-28","objectID":"/posts/html/:3:0","tags":null,"title":"html \u0026\u0026 css \u0026 js","uri":"/posts/html/"},{"categories":["language"],"content":"php \u0026\u0026 php框架 ","date":"2021-08-28","objectID":"/posts/php/:0:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"说明 php是web后端常用的开发语言有cli和fpm版本, cli版本暂时不知道什么用, fpm版本可以供其他软件使用, 比如apache2, nginx ","date":"2021-08-28","objectID":"/posts/php/:1:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"安装 强烈推荐使用docker安装php docker install php:7.4.7-fpm ","date":"2021-08-28","objectID":"/posts/php/:2:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"laravel 中文翻译文档 官方文档 laravel是流行的php框架 唯一感触就是环境配置真麻烦 laravel与hexo非常类似, 都是通过命令生成一个项目. 不同的是laravel需要把很多信息打入到php所在的载体中(docker容器或者服务器)(在compose install的时候打入). 而hexo则是通过命令, 把源文件生成为静态文件, 静态文件可以被github-page等服务器识别, 供web解析 ","date":"2021-08-28","objectID":"/posts/php/:3:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"laravel安装adminLTE – 通过mix方式安装 laravel7.x 安装adminlte2.4 下载adminLTE到工程中 composer require \"almasaeed2010/adminlte=~2.4\" 编写app.scss \u0026\u0026 app.js \u0026\u0026 webpack.mix.js TODONOW 如何编写 app.scss路径 resources/sass/app.scss app.js路径 resources/js/app.js webpack.mix.js路径 在项目根目录下 npm install \u0026\u0026 npm run dev 项目根目录下执行 npm install 安装js依赖 (根据package.json来安装) npm run dev 把webpack.mix.js(类似工程项目)中内容编译 xxx.blade.php代码中引用修改 css文件引用修改 js文件引用修改 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e . . . \u003clink rel=\"stylesheet\" href=\"{{ mix('css/app.css') }}\"\u003e \u003c/head\u003e \u003cbody class=\"hold-transition skin-blue sidebar-mini\"\u003e . . . \u003cscript src=\"{{ mix('js/app.js') }}\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-08-28","objectID":"/posts/php/:3:1","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"laravel安装adminLTE – 直接放到public目录下面即可 把adminLTE代码(github下载的源码) 放到laravel项目的pulic目录中 修改项目中对adminLTE的引用路径 \u003c!-- Font Awesome --\u003e \u003clink rel=\"stylesheet\" href=\"adminlte/plugins/fontawesome-free/css/all.min.css\"\u003e \u003c!-- icheck bootstrap --\u003e \u003clink rel=\"stylesheet\" href=\"adminlte/plugins/icheck-bootstrap/icheck-bootstrap.min.css\"\u003e \u003c!-- Theme style --\u003e \u003clink rel=\"stylesheet\" href=\"adminlte/dist/css/adminlte.min.css\"\u003e 注意路径的起始位置为laravel项目的public 重启php 与 nginx!!!!! 需要重启才能生效 ","date":"2021-08-28","objectID":"/posts/php/:3:2","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"laravel学习 /project path/app目录 逻辑代码(后端代码) app目录下的Http中放的是我们需要的 逻辑代码 app/Http中 controlers与middleware交互是通过app/Http/kernel.php中的变量map来寻找的 /project path/resources/views 前端代码(表现层代码) 模板文件一般放在layouts目录下面 访问DB数据库 注意事项 修改config/database.php 吐槽 database.php中sql server的demo不正确 配置为 'sqltest' =\u003e [ 'driver' =\u003e 'sqlsrv', //'url' =\u003e env('DATABASE_URL'), 'host' =\u003e '172.22.0.4', 'port' =\u003e '1433', 'database' =\u003e'QPAccountsDB', 'username' =\u003e 'sa', 'password' =\u003e 'hack@2020', 'charset' =\u003e 'utf8', 'prefix' =\u003e '', 'prefix_indexes' =\u003e true, ], 提示 修改了database.php后 需要执行以下命令 提示错误为 php artisan config:cache 成功了会显示 Configuration cache cleared! Configuration cached successfully! 提示错误 There is no existing directory at “%s” and its not buildable 查看storage权限 是否为775 执行以下命令 php artisan route:clear \u0026\u0026 php artisan config:clear \u0026\u0026 php artisan cache:clear 查看php是否开启了对DB的支持(这里以mssql为例) 详见本文档的 支持mssql \u0026\u0026 sqlserver 数据库表的搭建 创建数据库 \u0026\u0026 在app/User.php中选择数据库 protected $connection = 'QPWebDB'; 在选择的数据库中创建table php artisan migrate 测试laravel的注册, 登录功能访问 0.0.0.0:8080 进行注册,登录测试 web站点访问流程 – 以登录为例 controler 管理类 middleware 中间件 访问web站点 –\u003e 通过/project path/routes/web.php中的路由找到controler – /project path/app/Http/controler/HomeControler.php –\u003e controler转交给middleware处理 – auth 根据/project path/app/Http/kernel中的变量map找到middleware 如果有缓存, 则进入到home界面, 否则进入到login界面, 由controler中控制 –\u003e middleware通过route找到view (route 与 view之间通过XXX.blade.php关联) –\u003e 显示view页面 –\u003e 点击login页面中的登录按钮 –\u003e view找到对应的对应的controlers – /projectt path/app/Http/Controllers/Auth/LoginController.php 根据Auth::routes()找到 TODONOW可以查看在哪里实现的该函数 –\u003e controler转交给middleware处理 – /projcet path/Http/Middleware/RedirectIfAuthenticated.php –\u003e middleware中继续往下传递 总结 laravel 可以分为下面几个模块 route – 路由 controler – 管理器 middleware– 中间件 view – 视图文件(前端显示) guard 其架构为 +-----------+ | controler | ----- +------------+ +----------+ /--\u003e +-----------+ \\---\u003e | middleware| | route | ---- | ^ +------------+ +----------+ -- v | --- \\--- +------------+ ----/ \\\u003e | view | \u003c-/ +------------+ route可以访问 controler 与view controler可以访问view, 或者把复杂逻辑交给middleware midlleware可以访问view view 可以把action提交给controler, 由controler管理 ","date":"2021-08-28","objectID":"/posts/php/:3:3","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"compose compose 解决项目中对php的依赖 mac系统下 ","date":"2021-08-28","objectID":"/posts/php/:4:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"安装 # 安装compose curl -sS https://getcomposer.org/installer | php # 修改为全局可用 sudo mv composer.phar /usr/local/bin/composer # 查看是否安装成功 composer --version ","date":"2021-08-28","objectID":"/posts/php/:4:1","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"更新源 国外的源 被墙了 # 修改为国内的源 composer config -g repo.packagist composer https://packagist.phpcomposer.com ","date":"2021-08-28","objectID":"/posts/php/:4:2","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"pear \u0026\u0026 pecl 实际中并未使用到 :) pecl是php扩展池, pear管理php自身扩展库, 可以在pecl中下载php扩展 ","date":"2021-08-28","objectID":"/posts/php/:5:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"使用 实际使用, 可以参考下面的 web服务器 + php + lavarel + 数据库 TODONOW 待补充连接 ","date":"2021-08-28","objectID":"/posts/php/:6:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"支持mssql \u0026\u0026 sqlserver 下载odbc驱动 apt install unixodbc 下载微软的 dobc for sql 微软官方下载地址 根据服务器和php选择下载 并安装 dpkg -i msodbcsql17_17.5.2.1-1_amd64.deb 下载微软的 php for sql扩展 微软官方下载 并根据操作放入到php的lib目录, 同时修改php.ini 重启php 与 web载体(nginx, apache2) 测试是否安装成功 官方测试代码 ","date":"2021-08-28","objectID":"/posts/php/:7:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"C \u0026\u0026 C++ 常见库 ","date":"2021-08-28","objectID":"/posts/c++/:0:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/c++/"},{"categories":["language"],"content":"转换函数 c++11 支持 std::to_string(XX) XX 为int, short, long, longlong数值类型 std::stoi() 同类型的有std::stol(), std::stoll() ","date":"2021-08-28","objectID":"/posts/c++/:1:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/c++/"},{"categories":["language"],"content":"文件操作: fstream类 C++类, 头文件: #include 流程函数 构造fstream对象 fstream file; 打开文件 file.open(file_name, mode) mode: fstream::out 写: 内存-\u003e文件 fstream::in 读: 文件-\u003e内存当带有此模式的时候, 会默认认为文件存在, 即使文件不存在, 也不会创建文件; 所以对于需要创建文件的场景, 应该不带此mode 读文件 file » string file_val 遇到 空格 \\n \\r \\t时候停止 – 待确认TODONOW file.get(char ch) 每次读取一个字符 getline(file, string \u0026file_val) 读取一行, 遇到\\n停止 file.read(char*buf, length) 在读指针位置读取length长度到buf中, 一般用于二进制文件 写文件 file « file_val 待确认TODONOW file.put(ch) 写入一个字符 file.write(char*buf, length) 在写指针位置写入length长度的buf, 一般用户二进制文件 关闭文件 file.close 读写指针函数 获得读写指针位置 TODONOW 待确认 设置读写指针函数 读: seekg(postion) //postion绝对位置一般用户文本文件 读: seekg(offset, ios::beg|ios::end::ios::cur) //offset相对位置一般用户二进制文件, 最好勿在文本文件中使用 写: seekp(positon) 一般用户文本文件 写: seekp(offset, ios::beg|ios::end|ios::cur) 一般用户二进制文件, 最好勿在文本文件中使用 fstream状态函数 if(file) 检验流是否有效这个需要重点查看下, 什么时候流会失效已知: file.eof()时候, file则会变为无效 file.is_open() 流是否打开了文件 file.eof() 是否到了文件尾 file.clear() TODONOW 这个也需要再看下如果file.eof(), 调用clear可以重置标志; 重置标识后, file重新变为有效流 ","date":"2021-08-28","objectID":"/posts/c++/:2:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/c++/"},{"categories":["language"],"content":"字符串: string类 构造 比较 查找 插入 删除 ","date":"2021-08-28","objectID":"/posts/c++/:3:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/c++/"},{"categories":["language"],"content":"curses使用 官方地址: http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/windows.html ","date":"2021-08-28","objectID":"/posts/c++/:4:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/c++/"},{"categories":["language"],"content":"* ","date":"2021-08-28","objectID":"/posts/c++/:5:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/c++/"},{"categories":["language"],"content":"FILE FILE是C的文件操作 – C++的为fstream 问: 为什么有了fstream 还需要FILE? 答: 很多系统函数,都是对C的支持, 比如popen()函数等 fopen fread fwrite fclose ","date":"2021-08-28","objectID":"/posts/c++/:6:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/c++/"},{"categories":["language"],"content":"* ","date":"2021-08-28","objectID":"/posts/c++/:7:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/c++/"},{"categories":["language"],"content":"C++ 与 shell的互相调用,传参,获取运行输出 ","date":"2021-08-28","objectID":"/posts/c++/:8:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/c++/"},{"categories":["language"],"content":"左值, 右值, 左值引用, 右值引用 左值 lvalue(loactor value) – 地址右值 rvalue(read value) – value lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数 rvalue 译为 \"read value\"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据） 有名称的, 可以获取到存储地址的 变量或表达式为左值, 其余为右值 引用 \u0026 – 只能操作左值, 称为左值引用 \u0026\u0026 – 只能操作右值,称为右值引用 std::move(arg) – 可以把左值引用转换为右值引用左值引用, 对于类来说, 会使用copy 构造函数右值引用, 对于类来说, 会使用移动构造函数 ","date":"2021-08-28","objectID":"/posts/c++/:9:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/c++/"},{"categories":["gnu"],"content":"git简易指导, 个人使用心得 ","date":"2021-08-28","objectID":"/posts/git/:0:0","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git使用流程 ","date":"2021-08-28","objectID":"/posts/git/:1:0","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git原理 \u0026\u0026 常见命令 ","date":"2021-08-28","objectID":"/posts/git/:2:0","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git高级特性 ","date":"2021-08-28","objectID":"/posts/git/:3:0","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git hooks 参考文档 ","date":"2021-08-28","objectID":"/posts/git/:3:1","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"删除大文件 寻找大文件 git rev-list –objects –all | grep “$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk ‘{print$1}')” 删除大文件 git filter-branch -f –prune-empty –index-filter ‘git rm -rf –cached –ignore-unmatch your-file-name’ –tag-name-filter cat – –all 删除之后 git gc –prune=now ","date":"2021-08-28","objectID":"/posts/git/:3:2","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git lfs 把大文件排除在git仓库之外, git仓库中只有一个指针指向该大文件 ","date":"2021-08-28","objectID":"/posts/git/:4:0","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"安装lfs curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash \u0026\u0026 sudo apt-get install git-lfs \u0026\u0026 git lfs install ","date":"2021-08-28","objectID":"/posts/git/:4:1","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"初始化 git lfs install ","date":"2021-08-28","objectID":"/posts/git/:4:2","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"使用 过滤大文件 git lfs track file_path 过滤之后, 会生成.gitattributes 提交到远端 git push – 提交普通文件 git lfs push – 提交lfs文件 下载大文件 git lfs clone url ","date":"2021-08-28","objectID":"/posts/git/:4:3","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git submodule 参考文档 https://www.cnblogs.com/nicksheng/p/6201711.html 当项目越来越庞大之后，不可避免的要拆分成多个子模块，我们希望各个子模块有独立的版本管理，并且由专门的人去维护，这时候我们就要用到git的submodule功能 git clone \u003crepository\u003e --recursive 递归的方式克隆整个项目 git submodule add \u003crepository\u003e \u003cpath\u003e 添加子模块 git submodule init 初始化子模块 git submodule update 更新子模块 git submodule foreach git pull 拉取所有子模块 ","date":"2021-08-28","objectID":"/posts/git/:5:0","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"拉取子模块 方法1 先clone父项目 git submodule init git submodule update 方法2 clone 父项目时 加 –recursive git clone url path –recursive ","date":"2021-08-28","objectID":"/posts/git/:5:1","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"F\u0026Q 问: 命令行下的git status如何显示中文 答：git config --global core.quotepath false 问：在命令行下(gnu-bash)中git不能补全git的命令 1) 首先获得源码 git clone git://git.kernel.org/pub/scm/git/git.git 1) 从源码中拷贝git-completion.bash到用户主目录下. git-completion.bash cp git/contrib/completion/git-completion.bash ~/.git-completion.bash 2) 在 .bashrc 中加入 source ~/.git-completion.bash 3) 在shell下执行 . ~/.bashrc 问: 如何取消对文件的跟踪 答: 分情况而定 1) 对于从没有追踪过的文件, 只需要设置.gitignore即可 2) 对于已经追踪过的文件, 需要git rm --cached (-r) file 然后再加入到.gitignoe中即可 git对大小写不敏感问题, 可以通过下面命令修改 git config core.ignorecase false ","date":"2021-08-28","objectID":"/posts/git/:6:0","tags":["git"],"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"gdb学习 ","date":"2021-08-28","objectID":"/posts/gdb/:0:0","tags":null,"title":"gdb","uri":"/posts/gdb/"},{"categories":["gnu"],"content":"附加命令 attach thread_id 附加到进程 gdb ./a.out 使用gdb启动程序 ","date":"2021-08-28","objectID":"/posts/gdb/:1:0","tags":null,"title":"gdb","uri":"/posts/gdb/"},{"categories":["gnu"],"content":"调试命令 bt (backtrace) 查看函数栈 bt full 查看更加详细的信息 f (frame) 查看栈信息 f 0 表示查看栈顶; f n查看第n+1层 down 查看下一栈 up 查看上一栈 i (info) i f 查看当前栈所在层的具体信息 i args 当前函数的参数名及其值 i locals 当前函数中所有局部变量及其值 i catch 异常处理信息 i b 查看断点 i proc mappings 查看程序的内存分布 i reg 查看寄存器 l (list) 查看源码 p (print) 查看变量的值 ","date":"2021-08-28","objectID":"/posts/gdb/:2:0","tags":null,"title":"gdb","uri":"/posts/gdb/"},{"categories":["gnu"],"content":"调试方法 以调试core文件为例 gdb ./a.out core bt 先查看堆栈 如果2没有有用信息, bt full 查看更加详细的堆栈 有时候遇到一些奇怪问题, 可以尝试make clean 整个工程, 再重新生成 ","date":"2021-08-28","objectID":"/posts/gdb/:3:0","tags":null,"title":"gdb","uri":"/posts/gdb/"},{"categories":null,"content":"个人简介 昵称: wcq 地址: 来自山东, 现居武汉 邮箱: 377133665@qq.com 描述: Emacs重度患者 ","date":"2021-08-28","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"关于本站 梳理自身知识体系 分享 ","date":"2021-08-28","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":["gnu"],"content":"初学autotools ","date":"2021-08-28","objectID":"/posts/autotools/:0:0","tags":["autotools"],"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"为什么需要autotools Makefile固然可以帮助make完成它的使命，但要承认的是，编写Makefile确实不是一件轻松的事，尤其对于一个较大的项目而言更是如此。那么，有没有一种轻松的手段生成Makefile而同时又能让我们享受make的优越性呢？本节要讲autotools系列工具正是为此而设的， autotools只需用户输入简单的目标文件、依赖文件、文件目录等就可以轻松地生成Makefile autotools还可以完成系统配置信息的收集，从而可以方便地处理各种移植性的问题。 也正是基于此，现在Linux上的软件开发一般都用autotools来制作Makefile。 ","date":"2021-08-28","objectID":"/posts/autotools/:1:0","tags":["autotools"],"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"什么是autotools 综上所述, autotools主要就是利用各个工具的脚本文件以生成最后的Makefile. autotools并不是一个工具, 而是一系列工具合集. 主要有: autoscan aclocal autoconf autoheader automake ","date":"2021-08-28","objectID":"/posts/autotools/:2:0","tags":["autotools"],"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"autotools怎么使用 ","date":"2021-08-28","objectID":"/posts/autotools/:3:0","tags":["autotools"],"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"autotools安装 mac下包管理习惯使用homebrew 安装autoscan \u0026\u0026 autoconf brew install autoconf 安装aclocal \u0026\u0026 automake \u0026\u0026 autoheader brew install automake ","date":"2021-08-28","objectID":"/posts/autotools/:3:1","tags":["autotools"],"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"autotools 在代码当前目录下执行autoscan, 生成configure.scan. configure.scan重命名为configure.ac. 并做以下修改: 初始化AC_INIT 初始化AM_INIT_AUTOMAKE 设定AC_CONFIG_FILES # -*- Autoconf -*- # Process this file with autoconf to produce a configure script. AC_PREREQ([2.69]) #1. _初始化AC_INIT 和 初始化AM_INIT_AUTOMAKE_ AC_INIT(hello,1.0,377133665@qq.com) AM_INIT_AUTOMAKE(hello,1.0) #AC_CONFIG_SCRDIR来侦测源码文件是否存在, 来确定源码目录的有效性 AC_CONFIG_SRCDIR([main.cpp]) AC_CONFIG_HEADERS([config.h]) # Checks for programs. AC_PROG_CXX # Checks for libraries. # Checks for header files. AC_CHECK_HEADERS([stdlib.h unistd.h]) # Checks for typedefs, structures, and compiler characteristics. # Checks for library functions. #2. _生成makefile_ AC_CONFIG_FILES([Makefile]) AC_OUTPUT 执行aclocal命令. 扫描configure.ac文件生成aclocal.m4文件. 该文件主要处理本地宏定义. 它根据已经安装的宏、用户定义宏和 acinclude.m4 文件中的宏将 configure.ac 文件需要的宏集中定义到文件 aclocal.m4 中. 执行autoconf.这个命令将 configure.ac 文件中的宏展开，生成 configure 脚本。这个过程要用到aclocal.m4中定义的宏. 如果configure.ac宏定义改变了, 需要重新执行aclocal命令 执行autoheader.该命令生成 config.h.in 文件。该命令通常会从 “acconfig.h” 文件中复制用户附加的符号定义。该例子中没有附加的符号定义, 所以不需要创建 “acconfig.h” 文件。 创建Makefile.am文件.Automake工具会根据 configure.in 中的参量把 Makefile.am 转换成 Makefile.in 文件。最终通过Makefile.in生成Makefile文件，所以Makefile.am这个文件非常重要，定义了一些生成Makefile的规则 AUTOMARK_OPTIONS = foreign bin_PROGRAMS = hello hello_SOURCES = main.cpp 执行automake –add-missing命令。该命令生成 Makefile.in 文件。使用选项 “–add-missing” 可以让 Automake 自动添加一些必需的脚本文件。如果发现一些文件不存在，可以通过手工 touch命令创建 执行./configure。大部分linux软件安装都先需要执行./congigure，然后执行make和make install命令。 ./congigure主要把 Makefile.in 变成最终的 Makefile 文件。configure会把一些配置参数配置到Makefile文件里面。 执行make mac系统gcc与g++默认下都是clang的别名. 所以有可能会在此处产生错误. 实际上并没有发现不同 执行make install ","date":"2021-08-28","objectID":"/posts/autotools/:3:2","tags":["autotools"],"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"autotools流程图 dot流程图源码 ","date":"2021-08-28","objectID":"/posts/autotools/:3:3","tags":["autotools"],"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"推荐文章 autotools使用详解 Makefile中文手册 ","date":"2021-08-28","objectID":"/posts/autotools/:4:0","tags":["autotools"],"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"gcc ","date":"2021-08-28","objectID":"/posts/gcc/:0:0","tags":["gcc"],"title":"gcc","uri":"/posts/gcc/"},{"categories":["gnu"],"content":"安装 ","date":"2021-08-28","objectID":"/posts/gcc/:1:0","tags":["gcc"],"title":"gcc","uri":"/posts/gcc/"},{"categories":["gnu"],"content":"配置 ","date":"2021-08-28","objectID":"/posts/gcc/:2:0","tags":["gcc"],"title":"gcc","uri":"/posts/gcc/"},{"categories":["gnu"],"content":"gcc 查看搜索路径 g++ | gcc -print-serach-dirs (可通过–help查看) 头文件搜索路径 gcc C_INCLUDE_PATH g++ CPLUS_INCLUDE_PATH ep: export CPLUS_INCLUDE_PATH=/usr/lib/ 扩展1 输出 echo $C_INCLUDE_PATH 调用 $C_INCLUDE_PATH 赋值 export C_INCLUDE_PATH 删除变量 unset C_INCLUDE_PATH C++调用 string strValue(getenv(“C_INCLUDE_PATH”) 库文件搜索路径 动态链接库搜索路径 LD_LIBRARY_PATH 静态链接库搜索路径 LIBRARY_PATH ","date":"2021-08-28","objectID":"/posts/gcc/:2:1","tags":["gcc"],"title":"gcc","uri":"/posts/gcc/"},{"categories":["gnu"],"content":"使用","date":"2021-08-28","objectID":"/posts/gcc/:3:0","tags":["gcc"],"title":"gcc","uri":"/posts/gcc/"}]