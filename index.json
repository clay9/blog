[{"categories":["language"],"content":"通过C++历史, 更好的了解C++特性 ","date":"2023-04-12","objectID":"/posts/c++/:0:0","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"演变 ","date":"2023-04-12","objectID":"/posts/c++/:1:0","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"1979 诞生 刚开始叫做New C, 后改名C with Classes 诞生目的: 便于大型软件开发 \u0026\u0026 运行效率 过 程: 增强C语言特性 (选C原因: C用途广, 快速, 可移植性) 新增特性: 类别 衍生类别 存储类型检查 内联 缺省参数 ","date":"2023-04-12","objectID":"/posts/c++/:1:1","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"1983 改名C++ 新增特性: 虚拟函数 函数名 运算子多载 参考 ??? 常数 使用者可控制的自由空间存储区控制 改良的型别检查 单行注释 // ","date":"2023-04-12","objectID":"/posts/c++/:1:2","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"1985 发布第一版 非官方发布 ?? 这时候有官方了??? ","date":"2023-04-12","objectID":"/posts/c++/:1:3","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"1989 发布Release 2.0 新增特性: 多重继承 抽象类别 静态成员函数 常数成员函数 成员保护 ","date":"2023-04-12","objectID":"/posts/c++/:1:4","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"1990 出版了 标准化基础 ??哪一年??稍后还引入了模板例外处理、命名空间、新的强制类型转换，以及布林类型 ","date":"2023-04-12","objectID":"/posts/c++/:1:5","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"1998 C++98 第一个C++标准 标准分为 核心语言 \u0026\u0026 C++标准程序库 C++标准程序库主要包含 STL \u0026\u0026 C标准库的稍加修改版 语言特性: classes 相关 构造 \u0026\u0026 析构 friend 继承 多态 静态成员 new delete 高级概念 ?? 高级在哪?? 需要对比当时的环境 模板 命名空间 异常 类型转换 隐式转换 \u0026\u0026 显式转换 stl: 异常 类型检查 输入输出 ","date":"2023-04-12","objectID":"/posts/c++/:1:6","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2003 C++03 第二个C++标准 C++03 主要是在C++98基础上针对实现方的一些问题进行了修复，从而在各个实现间达到一致、保持了可移植性。 该版本共涉及 92 项核心语言缺陷报告、125 项库缺陷报告，所提供的新特性只有一项：值初始化（value initialization） 实现方是指编译器 ??需要重点看一下当时的编译器有哪些?? 对于使用者(程序员)来说, C++03与C++98差异不大(只有一条 值初始化) ","date":"2023-04-12","objectID":"/posts/c++/:1:7","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2006 C++性能技术报告 ","date":"2023-04-12","objectID":"/posts/c++/:1:8","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2007 C++技术报告: 库扩展 ","date":"2023-04-12","objectID":"/posts/c++/:1:9","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2010 数学函数扩展 ","date":"2023-04-12","objectID":"/posts/c++/:1:10","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2011 C++11 第三个C++标准 先前被称作C++0x, 本预计2000-2009间会发布, 结果一直拖到了2011年. 因此改名C++11. 参考资料 相比于C++03，C++11标准包含核心语言的新机能， 而且扩展C++标准程序库，并入了大部分的C++ Technical Report 1程序库（数学的特殊函数除外) 设计原则 维持稳定性和与C++98，可能的话还有C之间的兼容性； 尽可能不透过核心语言的扩展，而是透过标准程序库来引进新的特性； 能够演进编程技术的变更优先； 改进C++以帮助系统以及库设计，而不是引进只针对特别应用的新特性； 增进类别安全，提供对现行不安全的技术更安全的替代方案； 增进直接对硬件工作的能力与表现； 提供现实世界中问题的适当解决方案； 实行“zero-overhead”原则（某些功能要求的额外支持只有在该功能被使用时才能使用）； 使C++易于教授与学习 语言变更 C++委员会的主要作用之一是改善语言核心。核心语言将被大幅改善的领域包括 多线程支持 泛型编程 统一的初始化 以及性能表现的加强 在此分成4个区块来讨论核心语言的特色以及变更: 执行期表现强化、构造期表现强化、可用性强化，还有新的功能。 某些特性可能会同时属于多个区块，但在此仅于其最具代表性的区块描述 执行期表现强化 提升某些性能表现, 像是内存或者速度上的提升 右值引用 \u0026\u0026 std::move \u0026\u0026 std::forward 右值引用是语言特性, std::move \u0026\u0026 std::forward是stl中新增的函数 (头文件\u003cutility\u003e) 符合设计原则2, 使用stl补充语言特性 `` 右值引用的本质是为了解决C++之前版本的深度copy问题. wiki参考资料 template \u003ctypename T, typename Arg\u003e shared_ptr\u003cT\u003e factory(Arg arg) { return shared_ptr\u003cT\u003e( new T(arg)); } `` template \u003ctypename T, typename Arg\u003e shared_ptr\u003cT\u003e factory(Arg\u0026 arg) { return shared_ptr\u003cT\u003e( new T(arg)); } `` template\u003c typename T, typename Arg\u003e shared_ptr\u003cT\u003e factory(const Arg\u0026 arg) { //无法修改arg对象 return shared_ptr\u003cT\u003e( new T(arg)); } `` template\u003ctypename T, typename Arg\u003e shared_ptr\u003cT\u003e factory(Arg\u0026\u0026 arg) { return shared_ptr\u003cT\u003e(new T(std::forward\u003cArg\u003e(arg))); } /* 调用时候, 参数如果是左值, 只需要std::move()获取对应的右值 */ `` //两者都在\u003cutility\u003e头文件 //std::move(arg) 可以获取左值的右值引用 // 因为右值引用是将原对象的内容移动到新对象, 所以原对象移动后不应再使用 //std::forward\u003cT\u003e(arg) 可以获取arg的T属性. // T如果为int, 则使用arg的右值 // T若果为int\u0026, 则使用arg的左值 `` 右值引用使用场景: 上面的exp所展示的 就是在以传值方式传递对象时隐式发生的耗时且不必要的深度拷贝。 举例而言，std::vector本质上是一个C-style数组及其大小的封装， 如果一个std::vector的临时对象是在函数内部或者函数返回时创建， 要将其存储就只能透过生成新的std::vector并且把该临时对象所有的资料复制过去 然后该临时对象会被析构，其使用的内存会被释放 std::vector\u003cint\u003e test(){ std::vector\u003cint\u003e vec_data; //一些操作 //... //返回vec_data实际是 //1.创建了一个新的std::vector\u003cint\u003e 临时对象 //2.把vec_data对象深度copy给 临时对象 //3.返回临时对象 //4.销毁vec_data对象 // // 其中深度copy会造成非常大的开销, 导致性能低下 return vec_data; } std::vector\u003cint\u003e test(){ std::vector\u003cint\u003e vec_data; //一些操作 //... // //1.创建一个新的std::vector\u003cint\u003e 临时对象 //2.把vec_data对象移动到 临时对象 //3.返回临时对象 //4.销毁vec_data对象 // //对比旧版本, 这里少了深度copy这一层 return std::vector\u003cint\u003e (std::move(vec_data) ); } 注意事项 对象被右值引用后, 再操作会导致不可预知的问题(内存相关信息已被置为null) 并非所有情形都合适. 应该使用在避免深度copy的场合 constexpr 泛化的常量表达式 constexpr确保对象在编译期完成初始化操作, 因此加快运行期的效率 //const 与 constexpr 均表示该表达式(对象或函数)被声明为常量 //const 不保证对象经历哪种类型的初始化, 可能是编译器初始化, 也可能是运行期初始化 //constexpr 保证对象使用编译器初始化 //const演示 int get_number(){ return 5; } const int mx = get_number(); //mx是常量对象, 但在运行期获得初始化 int arr[mx] ; //错误. 因为mx是在运行期获得初始化; 而int[]需要编译器的常量 //constexpr演示 constexpr int get_number(){ return 5; } int arr[get_number()]; //正确. 因为constexpr保证函数get_number调用在编译器初始化 `` //修饰函数表达式 //函数主体必须是非虚拟的，并且除了 typedef 和静态断言之外，仅包含一个 return 语句 constexpr int max() { return 4; } // ok constexpr long long_max() { return 23423424; } //ok constexpr bool get_val(){ bool res = false; return res; } //error: body只能有一个return statement //修饰变量 //与const类似 //修饰构造函数 //构造函数可以有一个成员初始化列表, 但body必须是空的 //constexpr构造函数 允许编译器在编译时初始化对象, 前提是构造函数的参数都是常量表达式 struct complex { constexpr complex(double r, double i) : re(r), im(i) { } // ok double re; double im; } constexpr complex cx0(0.0, 1.0); //ok. 编译期初始化 double x = 1.0; constexpr complex cx1(x, 0); //error: x不是常量表达式 const complex cx2(x, 0); //ok. 运行期初始化 constexpr double xx = 1.0; constexpr complex cx3(xx, 0); //ok 编译期初始化 complex cx4(1.0, 2.0); //ok 运行期初始化 `` 对POD定义的修正 ?? 这是什么, 完全没有看懂 ?? 构造期表现强化 外部模版 在标准C++中，只要在编译单元内遇到被完整定义的模板，编译器都必须将其实例化（instantiate） 这会大大增加编译时间，特别是模板在许多编译单元内使用相同的参数实例化。 C++11之前, 可以告诉编译器在特定位置开始实例化, 但无法告诉编译器不要引发模板实例化 template class std::vector\u003cMyClass\u003e; `` C++11增加了 阻止编译器在编译期间引发模板实例化 extern template class std::vector\u003cMyClass\u003e; `` 可用性的加强 初始化列表 初始化列表的构想是 结构(或数组)的成员依据定义的顺序 由一串形参产生. struct Test{ int a; double b; int c; } //给予 Test一串形参, Test的成员根据位置,自动获得初始化 //Test成员a, b, c根据自己在Test结构中定义的顺序, 自动与形参1, 2.0, 3获得匹配的初始化 //即a=1, b=2.0, c=3 Test t1{1, 2.0, 3}; `` //C++11 增加了初始化列表构造函数 std::initializer_list\u003c\u003e class Test{ public: Test(std::initializer_list\u003cint\u003e list); //初始化列表构造函数 } Test test{1, 2, 3, 4}; //允许Test对象可以像这样初始化 //初始化列表构造函数的优先级大于普通的构造函数 cla","date":"2023-04-12","objectID":"/posts/c++/:1:11","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2011 十进制浮点数扩展 ","date":"2023-04-12","objectID":"/posts/c++/:1:12","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2014 C++14 第四个C++标准 C++14旨在作为C++11的一个小扩展, 主要提供漏洞修复和小的改进. 参考资料 语言特性变更 泛型的lambda ?? 这是什么玩意 ?? //C++11中, lambda函数的形参必须被声明为具体的类型 //C++14 放宽了这个要求 auto lambda = [](auto x, auto y) { return x + y; } lambda捕获部分中使用表达式 C++11的lambda函数允许通过 [值copy 或 引用] 捕获已在外层作用域声明的变量. C++14允许lambda成员用任意的被捕获表达式初始化.意味着: 允许 capture by value-move 允许任意声明的lambda成员, 而不需要外层作用域有一个具有相应名字的变量.这称为广义捕获. 即使在闭包区域中存在相同的变量也会被新变量覆盖(只是在lambda中被覆盖). 新变量类型由他的初始化表达式推导, 类似与auto //val新变量不需要特意声明类型, 会根据auto自动推导 //lambda的返回值为1, 说明新变量val成功被初始化 auto lambda = [val = 1]{ return val; } //另一个例子 auto x = 1; //lambda捕获中, r是x(外部x)的引用; x是新变量(会在lambda中覆盖外部变量x) //此处的新变量r为1; 新变量x为10 auto f = [\u0026r=x, x=x*10]{ ++ r; return r + x; } //结果是外部变量x被设置为2; f()返回12 f(); 函数返回类型推导 C++11允许lambda函数根据return语句的表达式类型推断返回类型; C++14为一般的函数也提供了这个功能. ?? 真的完全想不通这种不易阅读的特性 到底有什么用 ?? decltype(auto) const int x = 0; auto x1 = x; //x1为int类型 decltype(auto) x2 = x; //x2为const int类型 int y =0; int\u0026 y1 = y; auto y2 = y1; //int类型 decltype(auto) y3=y1; //int\u0026 int\u0026\u0026 z =0; auto z1 = std::move(z); //int decltype(auto) z2 = std::move(z); //int\u0026\u0026 //函数返回类型为int auto f (const int\u0026 i) { return i; } //函数返回类型为const int\u0026 decltype(auto) g (const int\u0026 i) { return i; } constexpr函数放宽限制 C++11对constexpr函数做了严格的限制, 允许的语句非常少(基本就是一条return语句…) C++14放宽了该限制. 允许constexpr有以下内容: 任何声明, 除了 static 或 thread_local变量 没有初始化的变量声明 条件分支语句 if \u0026\u0026 switch 所有的循环语句, 包含range for 循环 表达式可以改变一个对象的值 需要该对象的生命期在声明为constexpr的函数内部开始, 包括对有constexpr声明的任何非const非静态成员函数的调用. 此外，C++11指出，所有被声明为constexpr的非静态成员函数也隐含声明为const（即函数不能修改*this的值） C++14中这点已经被删除，非静态成员函数可以为非const 变量模板 C++14之前模板可以是函数模板或类模板 C++14中引入了变量模板 class对象构造优化 (聚合类的成员初始化) C++11中class的成员变量可以在声明的地方初始化. 但是如果构造函数中未定义该变量, 那么该class就不允许使用聚合初始化; C++14中放松了这一限制 struct Test{ int m_x; int m_y = 40; Test(int x) : m_x(x) {} }; Test t1{1}; //在C++11中是不允许的, 因为Test的构造函数Test(int x)中未初始化m_y Test t2{1}; //在C++14中是合法的. m_y会使用默认值40 二进制字面量 C++14的数字允许使用二进制形式指定.使用前缀0b或0B. 数字分位符 C++14引入单引号 ' 作为数字分位符号, 使得数值型的字母量更好的可读性. auto integer_literal = 100'0000; auto floating_point_literal = 1.797'693'134'862'315'7E+308; auto binary_literal = 0b0100'1100'0110; auto silly_example = 1'0'0'000'00; deprecated属性 deprecated属性允许标记不推荐使用的实体，该实体仍然能合法使用， 但会让用户注意到使用它是不受欢迎的，并且可能会导致在编译期间输出警告消息。 deprecated可以有一个可选的字符串文字作为参数，以解释弃用的原因和/或建议替代者。 [[deprecated]] void f(); [[deprecated(\"g() is unsafe, use h() instead\")]] void g(); void test(){ f(); //warnning: f()已被弃用 g(); //warnning: g() is unsafe, use h() instead } stl变更 共享的互斥体和锁 C++14增加了一类共享的互斥体和相应的共享锁 起初选择的名字是std::shared_mutex，但由于后来增加了与std::timed_mutex相似的特性，std::shared_timed_mutex成为了更适合的名字 元函数的别名 关联容器中的异构查找 C++标准库定义了四个关联容器类。 set和multiset允许用户根据一个值在容器中查找对应的的同类型的值。 map和multimap容器允许用户指定键（key）和值（value）的类型，根据键进行查找并返回对应的值。 然而，查找只能接受指定类型的参数，在map和multimap中是键的类型，而在set和multiset容器中就是值本身的类型。 C++14允许通过其他类型进行查找，只需要这个类型和实际的键类型之间可以进行比较操作。[ 这允许std::setstd::string使用const char*，或任何可以通过operator\u003c 与std::string比较的类型作为查找的参数。 为保证向后兼容性，这种异构查找只在提供给关联容器的比较器允许的情况下有效。 标准库的泛型比较器，如std::less\u003c\u003e与std::greater\u003c\u003e允许异构查找 stl自定义字面量 C++11增加了自定义字面量的语言特性. C++14的stl中利用了这个特性 C++14 stl定义了如下字面量后缀 s 创建各种std::basic_string类型 h, min, s, ms, us, ns 创建相应的std::chrono::duration时间间隔 if, i, il 创建std::complex, std::complex, std::complex复数类型 这些字面量可以用于编译时的constexpr //两个s互补干扰, 表示std::basic_string的s只能对字符串字面量操作, 而表示秒的只针对数字. auto str = \"hello world\"s; auto dur = 60s; auto z = 99i; 通过类型寻址多元组 C++11引入的std::tuple类型允许不同类型的值的聚合体用编译期整型常数索引。 C++14还允许使用类型代替常数索引，从多元组中获取对象。 若多元组含有多于一个这个类型的对象，将会产生一个编译错误 tuple\u003cstring, string, int\u003e t(\"foo\", \"bar\", 7); int i = get\u003c2\u003e(t); //i = 7; C++11 int j = get\u003cint\u003e(t); //j = 7; C++14新增 string s = get\u003cstring\u003e(t); //编译错误, 歧义 较小的标准库特性 std::make_unique可以像std::make_shared一样使用, 用于产生std::unique_str对象 std::is_finale用于识别一个class类型是否禁止被继承 std::integral_constant增加了一个返回常量值的operator() 全局std::begin/std::end函数之外, 增加了std::cbegin/std::cend函数, 用于返回常量迭代器 constant iterators ","date":"2023-04-12","objectID":"/posts/c++/:1:13","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2015 文件系统 ","date":"2023-04-12","objectID":"/posts/c++/:1:14","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2015 用于并行计算的扩展 ","date":"2023-04-12","objectID":"/posts/c++/:1:15","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2015 事务性内存操作 ","date":"2023-04-12","objectID":"/posts/c++/:1:16","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2015 概念库, 用于优化编译期信息 ","date":"2023-04-12","objectID":"/posts/c++/:1:17","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2016 用于并行计算的扩展 ","date":"2023-04-12","objectID":"/posts/c++/:1:18","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2017 标准库扩展 ","date":"2023-04-12","objectID":"/posts/c++/:1:19","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2017 提供范围机制 ","date":"2023-04-12","objectID":"/posts/c++/:1:20","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2017 协程库扩展 ","date":"2023-04-12","objectID":"/posts/c++/:1:21","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2017 C++17 第五个C++标准 C++17旨在作为大型扩展. 参考资料 ?? 新功能 ?? static_assert无需提供出错信息 具有模板形式的模板参数允许使用typename (之前只能使用class) std::uncaught_excepitions取代std::uncaught_exception 变长参数模板的Folding运算 容器访问操作表示方法的统一化 连续迭代器 新增特殊数学函数 语言特性 u8字面量 //C++11的时候, u8可以修饰字符串 //C++17新增了u8可以修饰单个字符 char x = u8'x'; 使noexcept成为系统的一部分 ?? 需要再仔细的查看 ?? noexcept在C++11中首次加入, 作用是抛出异常, 取代throw ?? 为什么取代throw ?? C++17中使其成为了系统的一部分 ??什么意思?? {}列表初始化的自动推导规则 具体详见C++11中的说明 初始化列表 //C++11中会被推导为 std::initializer_list\u003cint\u003e //C++17中推导为 int auto x {3}; lambda函数按值捕获this指针 C++17之前, lambda只能按引用捕获this指针 C++17允许使用*this捕获对象的副本 class 构造函数 ?? 完全没有概念 ?? 编译时 if constexpr 构造函数lambda 内联变量 inline 过去inline用于函数声明, 现在也可以用于变量声明, 表示函数或定义可定义多次(内容必须完全相同) 这允许在头文件中定义一个内联变量 结构化绑定 变量定义初始化时, 允许形如auto [x,y,z] = expr; 其中expr的 元组类似的对象包括 std::tuple, std::pair, std::array等聚合结构 //例子1 using Coordinate = std::pair\u003cint, int\u003e; Coordinate origin() { return Coordinate{1,2}; } const auto [x, y] = origin(); //x=1; y=2 //例子2 std::unordered_map\u003cstd::string, int\u003e mapping{ {\"a\", 1}, {\"b\", 2}, {\"c\", 3}, }; for (const auto\u0026 [key, value] : mapping:){ //do something } if/switch选择语句可以带初始化 //例子1 //之前需要放到语句块中限制锁的范围 { std::lock_guard\u003cstd::mutex\u003e lk(mx); if (v.empty()) v.push_back(val); } //现在可以直接放到if中 if (std::lock_guard\u003cstd::mutex\u003e lk(mx); v.empty()) { v.push_back(val); } //例子2 //更好的限制了变量的作用域 Foo gadget(args); switch (auto s = gadget.status()) { case OK: gadget.zip(); break; case Bad: throw BadFoo(s.message()); } //vs.现在 switch (Foo gadget(args); auto s = gadget.status()) { case OK: gadget.zip(); break; case Bad: throw BadFoo(s.message()); } 嵌套的namespace //C++17以前 namespace A{ namespace B{ namespace C{ int i; } } } //C++17简化了 namespace A::B::C{ int i; } fallthrough, nodiscard, maybe_unused特性 C++17中新增 stl std::variant std::optional std::any std::string_view std::filesystem std::invoke std::apply std::byte maps \u0026\u0026 sets更优效率的移动节点 并行算法 许多stl算法, 如copy, find和sort支持并行执行策略 ","date":"2023-04-12","objectID":"/posts/c++/:1:22","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2018 网络库 ","date":"2023-04-12","objectID":"/posts/c++/:1:23","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2018 并行扩展 ","date":"2023-04-12","objectID":"/posts/c++/:1:24","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2018 模块 ","date":"2023-04-12","objectID":"/posts/c++/:1:25","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"2020 C++20 第五个C++标准 C++20是一项非常大的改动. 参考资料 语言特性 新增关键字 concept requires constinit consteval co_await co_return co_yield char8_t 新增标识符 import module modules 模块 优点: 没有头文件 声明实现仍然可以分离, 但非必要 可以显示指定哪些导出(类, 函数等) 不需要头文件重复引入宏 include 模块之间名称可以相同 不会冲突 模块只处理一次, 编译更快 (头文件每次引入都需要处理) 预处理宏只在模块内有效 模块引入顺序无关紧要 (头文件引入顺序不同,可能发生不同结果) //创建模块 //export导出模块; 模块的名字是cppcon export module cppcon; namespace CppCon{ auto GetWelcomeHelper() { return \"Hello World\"; } export auto GetWelcome() { return GetWelcomehelper(); } } //引用模块 import cppcon; int main(){ std::cout \u003c\u003c CppCon::GetWelcome(); } import头文件 //隐式的将 iostream 转换为模块 //加速构建, 因为iosteam只会处理一次 //和预编译PCH具有相似的效果 ?? PCH是什么 ?? import \u003ciostream\u003e Ranges Range代表一串元素或者一串元素中的一段 意义: 简化语法, 方便使用 防止begin/end不配对 使变换/过滤等串联操作成为可能 vector\u003cint\u003e data{11, 22, 33}; sort(begin(data), end(data)); sort(data); //使用Ranges //View: 延迟计算, 不持有, 不改写 //Actions: 即时处理, 改写 //Algorithms: 所有接受begin/end对的算法都可以使用 //View和Ations使用管道符 | 串联 //例子1 串联view vector\u003cint\u003e data{1,2,3,4,5,6,7,8,9,10}; auto result = data | views::remove_if([] (int i) { return i % 2 == 1;}) | views::transform([])(int i) { return to_string(i);}); //result = {\"2\",\"4\",\"6\",\"8\",\"10\"}; //注意 以上操作被延迟, 只有便利result的时候才触发 //例子2 串联actions //排序然后去重 //操作会原地对data进行更改, 然后返回 vector\u003cint\u003e data{4, 3, 4, 1, 8, 0, 8}; vector\u003cint\u003e result = data| actions::sort | actions::unique; //例子3 过滤和变换 //所有的计算延迟到accumulate累加遍历的时候发生 int total = accumulate( view::ints(1) | //产生一个无限对整型数列 view::transform([] (int i) { return i * i;}) | //平方 view::take(10), //取前10个元素 0); //累加 协程 意义: 异步I/O 延迟计算 事件驱动的程序 generator //co_wait 挂起协程, 等待其他计算完成 //co_return 从协程返回 (协程禁用return) //co_yield 弹出一个值, 挂起协程, 下一次调用继续协程的运行 //for co_await 循环体 Concepts ?? 模板相关 ?? lambda 需要显示捕获this变量 C++20之前 [=] 隐式捕获this C++20开始 需要显示捕获this [=, this] 模板形式的lambda表达式 lambda表达式捕获 支持打包展开 constexpr 更新 原子智能指针 Atomic 智能指针对于数据读写并非线程安全. C++20之前, 多线程中使用智能指针, 需要使用mutex控制访问. C++20新增 atomic\u003cshared_ptr\u003e, atomic\u003cweak_ptr\u003e class 指定初始化 struct Data{ int m_x = 0; std::string m_s; }; Data d{.m_s = \"Hellow\"}; \u003c=\u003e 运算符 三路比较运算符 //类似C的strcmp函数返回-1, 0, 1 //但实际\u003c=\u003e返回的并非int类型, 而是\u003ccompare\u003e头中的对象 (a \u003c=\u003e b ) \u003c 0 //如果a\u003cb为true (a \u003c=\u003e b ) == 0 //如果a==b为true (a \u003c=\u003e b ) \u003e 0 //如果a\u003eb为true 范围for循环语句 支持初始化语句 C++17 if, switch语句支持了初始化语句 C++20 新增for循环语句的支持 for (auto data = GetData(); auto\u0026 value : data){ //do something } 特性测试宏 __has_cpp_attribute(fallthrough) __cpp_binary_literals __cpp_chart_t __cpp_coroutines consteval constexpr函数可能编译期执行, 也可以在运行期执行; consteval只能在编译期执行 constinit 强制指定以常量方式初始化 const char* GetStringDyn() { return \"dynamic init\"; } constexpr const char* GetString(bool constInit) { return constInit ? \"constant init\" : GetStringDyn(); } constinit const char* a = GetString(true); // ✔ constinit const char* b = GetString(false); // ❌ 用using引用enum类型 enum class CardTypeSuit { Clubs, Diamonds, Hearts, Spades }; //C++20之前 std::string_view GetString(const CardTypeSuit cardTypeSuit) { switch (cardTypeSuit) { case CardTypeSuit::Clubs: return \"Clubs\"; case CardTypeSuit::Diamonds: return \"Diamonds\"; case CardTypeSuit::Hearts: return \"Hearts\"; case CardTypeSuit::Spades: return \"Spades\"; } } //C++20 std::string_view GetString(const CardTypeSuit cardTypeSuit) { switch (cardTypeSuit) { using enum CardTypeSuit; // 这里 case Clubs: return \"Clubs\"; case Diamonds: return \"Diamonds\"; case Hearts: return \"Hearts\"; case Spades: return \"Spades\"; } } stl choron 增加日历和时区的支持 std::span 某段连续数据的视图 不持有数据, 不分配和销毁数据 copy非常快 不支持数据跨步 可通过运行期确定长度, 也可编译期确定长度 特性测试宏 __cpp_lib_conceps __cpp_lib_ranges __cpp_lib_scoped_lock 包含c++标准库版本, 发布日期, 版权证书, 特性宏等 std::format ?? C++ 也有format了 …. ?? ","date":"2023-04-12","objectID":"/posts/c++/:1:26","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"设计原则 C++设计成直接的和广泛的支援多种程式设计风格（过程化程式设计、数据抽象、物件导向程式设计、泛型程式设计）。 C++设计成给程式设计者更多的选择，即使可能导致程式设计者选择错误。 C++设计成尽可能与C相容，借此提供一个从C到C++的平滑过渡。 C++避免平台限定或没有普遍用途的特性。 C++不使用会带来额外开销的特性。 C++设计成无需复杂的程式设计环境。 ","date":"2023-04-12","objectID":"/posts/c++/:2:0","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["language"],"content":"待学习 stl C++中很重要的功能, 必须要尽快了解常用的 新的概念 C++20中增加了很多新概念 新的语言特性 只需要学习常用的特性, 有些特性是为了配合模板而来的, 暂时不需要学习 其他常用的库 比如网络库Asio, 格式库protobuf 模板 模板的作用 更多的是用在stl的编写上, 日常开发使用的比较少, 可以暂时先不学习 ","date":"2023-04-12","objectID":"/posts/c++/:3:0","tags":["c++"],"title":"c++历史","uri":"/posts/c++/"},{"categories":["tool"],"content":"功能强大的图书管理软件 ","date":"2023-02-12","objectID":"/posts/calibre/:0:0","tags":["calibre"],"title":"calibre 图书管理软件","uri":"/posts/calibre/"},{"categories":["tool"],"content":"功能 笔者主要用来整理图书, 供kindle使用 ","date":"2023-02-12","objectID":"/posts/calibre/:1:0","tags":["calibre"],"title":"calibre 图书管理软件","uri":"/posts/calibre/"},{"categories":["tool"],"content":"使用 ","date":"2023-02-12","objectID":"/posts/calibre/:2:0","tags":["calibre"],"title":"calibre 图书管理软件","uri":"/posts/calibre/"},{"categories":["tool"],"content":"book libray 书库使用中文代替拼音 在calibre中，导入中文书名、中文作者名的书籍时，calibre library 中自动生成的文件夹名、文件名会转换成拼音。 这是个老大难的问题了，网络上的解决方案大概有以下 2 种： 通过设置项修改 针对的是「保存到硬盘」操作，对导入数据不生效 编译 python 文件，替换程序文件 替换程序文件 calibre 的作者强烈不建议自己编译，而是建议使用 debug 模式 具体操作官方文档描述得很清楚，https://manual.calibre-ebook.com/develop.html 以 macOS 为例 安装 calibre app 下载源码文件 \u0026\u0026 check out calibre-app对应版本 修改源码文件 对于中文替换拼音, 只需要在calibre/src/calibre/utils/filenames.py 修改 ascii_text 回传的值即可 #return ascii return orig 新建启动方式 新建my-calibre.sh \u0026\u0026 修改mod 775 #!/bin/sh export CALIBRE_DEVELOP_FROM=\"/Users/kovid/work/calibre/src\" /Applications/calibre.app/Contents/MacOS/calibre-debug -g 通过my-calibre.sh启动 ","date":"2023-02-12","objectID":"/posts/calibre/:2:1","tags":["calibre"],"title":"calibre 图书管理软件","uri":"/posts/calibre/"},{"categories":["gnu"],"content":"在project中生成TAGS文件, 方便索引 ","date":"2022-11-20","objectID":"/posts/global/:0:0","tags":null,"title":"global","uri":"/posts/global/"},{"categories":["gnu"],"content":"安装 sudo apt install global ","date":"2022-11-20","objectID":"/posts/global/:1:0","tags":null,"title":"global","uri":"/posts/global/"},{"categories":["gnu"],"content":"使用 # step1 make tag-files (GPATH, GRTAGS, GTAGS) gtags # *step2 maybe make htlm htags # step3 find global X #find tag global -r X #find rtag global -s X #find symbol ","date":"2022-11-20","objectID":"/posts/global/:2:0","tags":null,"title":"global","uri":"/posts/global/"},{"categories":["gnu"],"content":"GPATH, GRTAGS, GTAGS GTAGS 中包含了定义 GRTAGS中包含了引用 GPATH 中是路径名字 对于C++来说 tag包含了class, struct, global-function \u0026\u0026 class-function 但是不包含class-symbol(成员变量), 局部变量, 全局变量 rtags中包含了tag中内容的引用 和 非tag中内容的引用(比如成员变量) 所以使用global来查找的时候, 参数非常有必要. 比如 global X 是在GTAGS中查找, 所以是查找不到成员变量的, 因为成员变量没有在GTAGS中 global -r X 是在GRTAGS中查找GTAGS中定义的内容的引用, 所以也是查找不到成员变量的 global -s X 与-r相反, 是在GRTAGS中查找没有在GTAGS中定义内容的引用, 所以可以查找成员变量, 局部变量, 全局变量等 ","date":"2022-11-20","objectID":"/posts/global/:2:1","tags":null,"title":"global","uri":"/posts/global/"},{"categories":["gnu"],"content":"对于C++的.h文件 通过gtags –config可以查看gtags生成tags-file的配置 wangruoxudeMacBook-Pro:~ clay$ gtags --config :skip=HTML/,HTML.pub/,tags,TAGS,ID,y.tab.c,y.tab.h,gtags.files,cscope.files,cscope.out,cscope.po.out,cscope.in.out,SCCS/,RCS/,CVS/,CVSROOT/,{arch}/,autom4te.cache/,*.orig,*.rej,*.bak,*~,#*#,*.swp,*.tmp,*_flymake.*,*_flymake,*.o,*.a,*.so,*.lo,*.zip,*.gz,*.bz2,*.xz,*.lzh,*.Z,*.tgz,*.min.js,*min.css:langmap=c\\:.c.h,yacc\\:.y,asm\\:.s.S,java\\:.java,cpp\\:.c++.cc.hh.cpp.cxx.hxx.hpp.C.H,php\\:.php.php3.phtml 很明显上面会把.h当作c来处理, 而非C++, 因此我们需要修改其默认行为 # GTAGSFORCECPP 设置为非nil, 表示把.h当作C++来处理 export GTAGSFORCECPP=1 ","date":"2022-11-20","objectID":"/posts/global/:2:2","tags":null,"title":"global","uri":"/posts/global/"},{"categories":["gnu"],"content":"参考资料 官方文档 ","date":"2022-11-20","objectID":"/posts/global/:3:0","tags":null,"title":"global","uri":"/posts/global/"},{"categories":["system"],"content":"mac 记录 ","date":"2022-11-12","objectID":"/posts/mac/:0:0","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"mac系统怎么样 之前是为了学习linux命令行, 后来是开发环境使用到了xcode, 现在是emacs+alfred. mac是一款很稳定的系统, 但是稳定的代价是, 对于大部分游戏都不支持. 所以如果有游戏需求, 非常不建议使用mac. 17年开始使用mac, 缺点很明显, 对游戏的支持差. 优点也不少: 稳定 广告少! 广告少! 广告少! 命令行学习使用方便 原生软件xcode alfred ","date":"2022-11-12","objectID":"/posts/mac/:1:0","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"mac初步整理 笔者有严重的强迫症, 新上手的东西必须整理一遍才去使用. 习惯性由大到小, 由外而内的整理方式. ","date":"2022-11-12","objectID":"/posts/mac/:2:0","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"os系统选择 不是最新的os系统就是最好的!!! 应该根据不同的mac机型选择不同的os 比如mbp2017 intel处理器可以选择Mojave ","date":"2022-11-12","objectID":"/posts/mac/:2:1","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"界面的整理 launchpad图标大小整理 每一列图标数量 defaults write com.apple.dock springboard-rows -int 7 每一行图标数量 defaults write com.apple.dock springboard-columns -int 7 重启Launchpad defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock 慎用: 该指令重启launchpad的时候, 也会使launchpad的排序恢复默认值!!! 添加空白到Dock栏 空白能使Dock中的程序更好的归类. 按住Option可以拖动 defaults write com.apple.dock persistent-apps -array-add '{\"tile-type\"=\"spacer-tile\";}'; killall Dock ","date":"2022-11-12","objectID":"/posts/mac/:2:2","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"状态栏调整 按住Command之后, 鼠标可以拖动状态栏图标 ","date":"2022-11-12","objectID":"/posts/mac/:2:3","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"mac自带输入法 – 简体拼音 记录一下常用快捷键 \u0026\u0026 配置 TAB – 短按切换ABC与简体中文, 长按大小写 建议设置选词为竖屏, 横屏容易遮挡输入 不舒服的地方 输入的时候无法使用shift来切换为英文, 必须使用Enter或者Ctrl+任意健 候选词为横屏的时候, 会遮挡住输入区域 ","date":"2022-11-12","objectID":"/posts/mac/:2:4","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"关闭内置键盘 苹果内置键盘不好用, 但是触控板非常好用. 习惯把HHKB放在苹果键盘上, 这样可以使用HHKB+苹果触控版 # For newer versions on MacOS / alternative solution: # List loaded kexts for keyboard kextstat | grep Keyboard # It's going to output something like: # 81 0 0xffffff7f833c5000 0xb000 0xb000 com.apple.driver.AppleHIDKeyboard (208) 96DDE905-9D31-38A9-96B7-FB28573587C8 \u003c43 6 5 3\u003e # com.apple.driver.AppleHIDKeyboard is loaded kext identifier. # If you want to plug-in Apple Magic Keyboard / some other Bluetooth keyboard, turn it off first. Then follow the instruction below. # To disable keyboard: sudo kextunload -b com.apple.driver.AppleHIDKeyboard # To enable it back: sudo kextload -b com.apple.driver.AppleHIDKeyboard ","date":"2022-11-12","objectID":"/posts/mac/:2:5","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"开机启动 mac没有像linux使用init作为系统管理, 而是使用Launchd launchd 定义一个由Launchd管理服务, 首先要有一个适用于该运行环境的程序, 比如在系统启动过程中不能使用图形交互API, 那么与用户交互的程序就不能在系统启动过程中被调用. 其次就是定制一个launchd规则的plist文件. 它是让launchd知道哪里以及如何运行一个程序,什么时候运行, 运行的规则等等等配置文件. 最后根据运行的方式, 把这个Plist文件存放到指定的位置, 并设置好文件属性等 级别 目录 操作系统级别的服务程序 /System/Library/LaunchDaemons /System/Library/LaunchAgents 本机全局 /Library/LaunchDaemons /Library/LaunchAgents 用户级别 ~/Library/LaunchAgents Daemons是一种无用户交互的服务程序, 而Agents是用户交互 当系统启动时, 依次执行/System/Library/LaunchDaemons 和 /Library/LaunchDaemons 当用户登陆时, 依次执行/System/Library/LaunchAgents, /Library/LaunchAgents 和 ~/Library/LaunchAgents 操作流程 编写自己的脚本, 并添加可执行权限 如果是Daemons调用, 需要给于777权限 编写plist文件 \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"\u003e \u003cplist version=\"1.0\"\u003e \u003cdict\u003e \u003ckey\u003eLabel\u003c/key\u003e \u003cstring\u003ecom.user.loginscript\u003c/string\u003e \u003ckey\u003eProgramArguments\u003c/key\u003e \u003carray\u003e \u003cstring\u003e/path/to/my/script.sh\u003c/string\u003e \u003c/array\u003e \u003ckey\u003eRunAtLoad\u003c/key\u003e \u003ctrue/\u003e \u003c/dict\u003e \u003c/plist\u003e 根据功能, plist文件放到不同的目录 load plist sudo launchctl load -w ~/Library/LaunchAgents/com.service.name.plist test launchctl start com.user.loginscript 实例 功能: 苹果开机时候 禁用内置键盘 创建mac_startup.sh \u0026\u0026 设置权限为777 #!/bin/bash ## disable mac internal keyboard sudo -S kextunload -b com.apple.driver.AppleHIDKeyboard \u003e /dev/null 创建mac_startup.plist \u0026\u0026 放到/Library/LaunchDaemons \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE plist PUBLIC \"-//Apple Computer//DTD PLIST 1.0//EN\" \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\"\u003e \u003cplist version=\"1.0\"\u003e \u003cdict\u003e \u003ckey\u003eLabel\u003c/key\u003e \u003cstring\u003ecom.mac.startup\u003c/string\u003e \u003ckey\u003eProgramArguments\u003c/key\u003e \u003carray\u003e \u003cstring\u003e/Users/clay/mac_startup.sh\u003c/string\u003e \u003c/array\u003e \u003ckey\u003eRunAtLoad\u003c/key\u003e \u003ctrue/\u003e \u003c/dict\u003e \u003c/plist\u003e load plist sudo launchctl load -w /Library/LaunchDaemons/mac_startup.plist 登陆测试 ","date":"2022-11-12","objectID":"/posts/mac/:2:6","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"mac好用的软件 ","date":"2022-11-12","objectID":"/posts/mac/:3:0","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"Alfred Alfred 是加强版的聚焦搜索, 支持自定义编程, 非常强大 之前先买了Manico, paster 发现这些功能Alfred都可以更好的完成... ","date":"2022-11-12","objectID":"/posts/mac/:3:1","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"Karabiner 不推荐的原因是会导致部分电脑发热严重 Karabiner 是一款好用的键位映射软件 ","date":"2022-11-12","objectID":"/posts/mac/:3:2","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"HomeBrew HomeBrew 是一款包管理软件, 类似于ubuntu下的apt ","date":"2022-11-12","objectID":"/posts/mac/:3:3","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"Oh My Zsh Oh My Zsh让终端显示更加丰富多彩 ","date":"2022-11-12","objectID":"/posts/mac/:3:4","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"Annotate Annotate (App Store下载) 是非常好用的截屏软件, 同时支持gif ","date":"2022-11-12","objectID":"/posts/mac/:3:5","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"IINA IINA 是mac下最好用的视频软件 ","date":"2022-11-12","objectID":"/posts/mac/:3:6","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"mac实用技巧 ","date":"2022-11-12","objectID":"/posts/mac/:4:0","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"Dock上隐藏运行的程序 进入要隐藏的程序的Contents目录 cd App_Path/Contents 编辑info.plist文件 sudo vim info.plist 添加下面的代码 \u003ckey\u003eLSUIElement\u003c/key\u003e \u003ctrue/\u003e 上面的方法并不是万能的，有些软件并不能这么设置，设置了会导致打不开，例如teamview，应该还要修改其他设置，但是大多数软件都可以通过此方法进行修改，如果出错了按此方法修改回去就可以了 关于teamviewer的隐藏，需要在终端执行下面的命令 sudo bash -c 'killall TeamViewer_Service; killall TeamViewer; killall TeamViewer_Desktop; perl -i -0pe \"s/\u003c\\/dict\u003e\\n\u003c\\/plist\u003e/\\t\u003ckey\u003eLSUIElement\u003c\\/key\u003e\\n\\t\u003cstring\u003e1\u003c\\/string\u003e\\n\u003c\\/dict\u003e\\n\u003c\\/plist\u003e/g\" /Applications/TeamViewer.app/Contents/Info.plist; codesign -f -s - /Applications/TeamViewer.app; launchctl unload /Library/LaunchDaemons/com.teamviewer.teamviewer_service.plist; launchctl load /Library/LaunchDaemons/com.teamviewer.teamviewer_service.plist' ","date":"2022-11-12","objectID":"/posts/mac/:4:1","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"mac卡顿处理 删除Macintosh HD/系统/资源库/Caches中的文件 删除Macintosh HD/资源库/Caches中的文件 如果以上无效, 建议更换操作系统版本, 比如从macOS high sierra更换为macOS Mojave ","date":"2022-11-12","objectID":"/posts/mac/:4:2","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"快捷键 系统偏好 – 键盘 – 快捷键 中修改快捷键 ","date":"2022-11-12","objectID":"/posts/mac/:4:3","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"无用程序关闭 聚焦 作用: Command+空格的 聚焦搜索 影响进程: mds、mds_stores、mdworker 关闭原因: 实际没必要, 追求效率的, 可以关掉 #关闭 sudo mdutil -a -i off #打开 sudo mdutil -a -i on ","date":"2022-11-12","objectID":"/posts/mac/:4:4","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"ssh远程连接mac os, 中文乱码 这种情况一般是终端和服务器的字符集不匹配，MacOSX下默认的是utf8字符集。输入locale可以查看字符编码设置情况，而我的对应值是空的。因为我在本地和服务器都用zsh替代了bash，而且使用了oh-my-zsh，而默认的.zshrc没有设置为utf-8编码，所以本地和服务器端都要在.zshrc设置，步骤如下，bash对应.bash_profile或.bashrc文件。 在.bash_profile中增加 export LC_ALL=en_US.UTF-8 export LANG=en_US.UTF-8 source .bash_profile locale 查看下是否设置成功 完成 ","date":"2022-11-12","objectID":"/posts/mac/:4:5","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["system"],"content":"查找错误 mac崩溃原因查找 # 会打印mac 24小时崩溃的原因 # 常见原因 # 5 -- 正常关机 # 3 -- 硬件关机 (holding the power button) log show --predicate 'eventMessage contains \"Previous shutdown cause\"' --last 24h ","date":"2022-11-12","objectID":"/posts/mac/:5:0","tags":["mac"],"title":"mac","uri":"/posts/mac/"},{"categories":["tool"],"content":"etcd学习记录 ","date":"2022-02-22","objectID":"/posts/etcd/:0:0","tags":["etcd"],"title":"etcd","uri":"/posts/etcd/"},{"categories":["tool"],"content":"应用场景 etcd应用最多的地方在服务发现 ","date":"2022-02-22","objectID":"/posts/etcd/:1:0","tags":["etcd"],"title":"etcd","uri":"/posts/etcd/"},{"categories":["tool"],"content":"服务发现 服务发现(Service Discovery)要解决的是分布式系统中最常见的问题之一, 即在同一个分布式集群中的进程或服务如何才能找到对方并建立连接。 从本质上说，服务发现就是要了解集群中是否有进程在监听upd或者tcp端口， 并且通过名字就可以进行查找和链接。 服务发现几个重点 服务注册, 且服务中介需要保证注册者的存活, 不能是黑洞服务 新的服务出现之后, 如何通知消费者 单例挂掉之后, 如何处理 对于非k8s系统来讲, 其实没必要搞服务发现这一套\r ","date":"2022-02-22","objectID":"/posts/etcd/:2:0","tags":["etcd"],"title":"etcd","uri":"/posts/etcd/"},{"categories":["tool"],"content":"redis学习记录 ","date":"2021-12-20","objectID":"/posts/redis/:0:0","tags":["redis"],"title":"redis","uri":"/posts/redis/"},{"categories":["tool"],"content":"基础 ","date":"2021-12-20","objectID":"/posts/redis/:1:0","tags":["redis"],"title":"redis","uri":"/posts/redis/"},{"categories":["tool"],"content":"数据结构 二进制安全字符串 (key, value) 列表 (链表实现) 集合 排序集合 哈希 位数组(简单的位图) HyperLogLogs 概率数据结构 Streams ","date":"2021-12-20","objectID":"/posts/redis/:1:1","tags":["redis"],"title":"redis","uri":"/posts/redis/"},{"categories":["tool"],"content":"键值注意事项 键一般不要太大, 但又不要太短, 导致不可阅读. 需要平衡 值不能大于512MB ","date":"2021-12-20","objectID":"/posts/redis/:1:2","tags":["redis"],"title":"redis","uri":"/posts/redis/"},{"categories":["tool"],"content":"常用的指令 通用命令 exist 返回1表示存在, 0表示不存在 del 删除 type 返回key对应值的类型, 不存在值, 则为none expire 设置过期时间(秒). key对应的过期时间也会被保存在磁盘上 或者set key 100 ex 10 -- 使用ex来简化expire\r persist 删除key的过期时间, 并永久化 字符串 get set getset 将键设置为新值, 并返回旧值为结果 链表相关 索引从0开始\r lpush (key v) 在链表的左侧(头部)添加元素 – 常数时间 rpush (key v) 在链表的右侧(尾部)添加元素 – 常数时间 可以一次推送多个数据. 返回结果为当前链表中的元素个数\r lrange (key arg1 arg2) 从链表中提取元素范围 – 需要的时间与元素数量正比, 非常慢 参数可以为负数表示. -1表示最后一个元素, -2表示倒数第二个\r lpop (key) rpop (key) 返回结果为左侧或右侧的元素\r ltrim (key arg1 arg2) 只保留范围内的元素, 删除链表其他元素 llen (key) 链表的长度 Hash hmset hmget 检索多个字段(可单, 可全部) hget 检索单个字段 hgetall 检索所有字段 hincrby 可以对单个字段的val执行加操作 Set sadd 添加新的元素 smembers 返回集合中的元素(未排序的, redis随意返回) sismember (Set key) 检测key是否是Set的成员. 返回1是,0不是 spop (key option\u0026 count) 删除count个随机的元素, 并返回给客户端 scard 返回集合中的元素个数 Sorted Set 现根据score排序, score一致则根据key的字典值排序 zadd (ZSet key score val) 添加新的元素. 多了一个score的写入 zrange (ZSet index_b index_e option\u0026 withscores) 返回范围内的元素(正序的) zrevrange (ZSet index_b index_E option\u0026 withscores) 返回范围内的元素(倒序的) 额外参数withscores会输出元素的score\r zrangebyscore (ZSet -inf score_val) 返回有序集合中的score \u003c= score_val的元素 zremrangebyscore (ZSet score_b zsocre_e) 删除集合中所有score在b,e之间的元素 zrank (ZSet key) 返回元素在正序集合中的index zrevrank (ZSet key) 返回元素在倒叙集合中的index ","date":"2021-12-20","objectID":"/posts/redis/:1:3","tags":["redis"],"title":"redis","uri":"/posts/redis/"},{"categories":["tool"],"content":"kubernetes, 简称k8s ","date":"2021-11-08","objectID":"/posts/k8s/:0:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"k8s概念 namespace 在所有抽象层之前 kubectl delete namespace \u003cnamespace-name\u003e 删除namespace会删除namespace下面所有的资源, 比如deployment,pods,svc等等 -n xx – 使用xx命名空间 –all-namespaces – 显示所有的命名空间 kubectl get namespaces kubectl delete pod \u003cpod-name\u003e --force -n xx 各种概念 cluster 即k8s集群 master 控制节点 node 工作节点 Namespace CustomResourceDefinition 自定义类型资源crd service deployment – rc – pods ingress ","date":"2021-11-08","objectID":"/posts/k8s/:1:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"kubernetes 创建集群 ","date":"2021-11-08","objectID":"/posts/k8s/:2:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"安装 # 大多数 Pod 网络都需要 CNI_VERSION=\"v0.8.2\" ARCH=\"amd64\" sudo mkdir -p /opt/cni/bin curl -L \"https://github.com/containernetworking/plugins/releases/download/${CNI_VERSION}/cni-plugins-linux-${ARCH}-${CNI_VERSION}.tgz\" | sudo tar -C /opt/cni/bin -xz # kubeadm/kubelet 容器运行时接口（CRI）所需 DOWNLOAD_DIR=/usr/local/bin sudo mkdir -p $DOWNLOAD_DIR CRICTL_VERSION=\"v1.17.0\" ARCH=\"amd64\" curl -L \"https://github.com/kubernetes-sigs/cri-tools/releases/download/${CRICTL_VERSION}/crictl-${CRICTL_VERSION}-linux-${ARCH}.tar.gz\" | sudo tar -C $DOWNLOAD_DIR -xz #RELEASE=\"$(curl -sSL https://dl.k8s.io/release/stable.txt)\" RELEASE=v1.22.3 ARCH=\"amd64\" cd $DOWNLOAD_DIR sudo curl -L --remote-name-all https://storage.googleapis.com/kubernetes-release/release/${RELEASE}/bin/linux/${ARCH}/{kubeadm,kubelet,kubectl} sudo chmod +x {kubeadm,kubelet,kubectl} # 添加kubelet系统服务 RELEASE_VERSION=\"v0.4.0\" curl -sSL \"https://raw.githubusercontent.com/kubernetes/release/${RELEASE_VERSION}/cmd/kubepkg/templates/latest/deb/kubelet/lib/systemd/system/kubelet.service\" | sed \"s:/usr/bin:${DOWNLOAD_DIR}:g\" | sudo tee /etc/systemd/system/kubelet.service sudo mkdir -p /etc/systemd/system/kubelet.service.d curl -sSL \"https://raw.githubusercontent.com/kubernetes/release/${RELEASE_VERSION}/cmd/kubepkg/templates/latest/deb/kubeadm/10-kubeadm.conf\" | sed \"s:/usr/bin:${DOWNLOAD_DIR}:g\" | sudo tee /etc/systemd/system/kubelet.service.d/10-kubeadm.conf # 激活并启动kubelet systemctl enable --now kubelet ","date":"2021-11-08","objectID":"/posts/k8s/:2:1","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"环境配置 # 加载模块 sudo modprobe br_netfilter # cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system 控制平面节点 协议 方向 端口范围 作用 使用者 TCP 入站 6443 Kubernetes API 服务器 所有组件 TCP 入站 2379-2380 etcd 服务器客户端 API kube-apiserver, etcd TCP 入站 10250 Kubelet API kubelet 自身、控制平面组件 TCP 入站 10251 kube-scheduler kube-scheduler 自身 TCP 入站 10252 kube-controller-manager kube-controller-manager 自身 工作节点 协议 方向 端口范围 作用 使用者 TCP 入站 10250 Kubelet API kubelet 自身、控制平面组件 TCP 入站 30000-32767 NodePort 服务† 所有组件 # 查看需要下载哪些 kubeadm config images list # 替换为mirror-images kubeadm config images list |grep -v 'coredns' |sed -e 's/^/docker pull /g' -e 's#k8s.gcr.io#docker.io/clay2019#g' |sh -x kubeadm config images list |grep 'coredns' |sed -e 's/^/docker pull /g' -e 's#k8s.gcr.io#docker.io#g' -e 's#:v#:#g' |sh -x kubeadm config images list |grep -v 'coredns' |sed -e 's/^/docker pull /g' -e 's#k8s.gcr.io#docker.io/clay2019#g' |sh -x docker images |grep clay2019 |awk '{print \"docker tag \",$1\":\"$2,$1\":\"$2}' |sed -e 's#clay2019#k8s.gcr.io#2' |sh -x docker images |grep clay2019 |awk '{print \"docker rmi \", $1\":\"$2}' |sh -x ","date":"2021-11-08","objectID":"/posts/k8s/:2:2","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"kubeadm init 配置 kubeadm的配置文件 kubeadm --config中指定的那个, 会覆盖kubelet等组件的默认行为!!! # 查看kubeadm init-defaults kubeadm config print init-defaults --component-configs KubeProxyConfiguration,KubeletConfiguration \u003e kubeadm.yaml # 有时候 kubeadm init 与 kubeadm init --config kubeadm.yaml 使用的镜像并不相同 # 比如我遇到的kubeadm init使用的是v1.22.3, 但是其init-defaults输出的kubeadm.yaml中的images为v1.22.0!! 需要注意 配置完成之后, 使用 kubeadm init –config xx.yaml来创建master 也可以使用kubeadm init默认安装 如果kubelet没有启动, 修改下kubelet的配置文件, 重新启动即可 ","date":"2021-11-08","objectID":"/posts/k8s/:2:3","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"网络插件安装 kubectl get nodes中发现Node的STATUS为NotReady, 需要安装网络插件. 如果没有安装网络插件, pods/coredns的状态为pending 这里选的是calico, 详见calico安装 ","date":"2021-11-08","objectID":"/posts/k8s/:2:4","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"kubernetes 配置集群的 主要配置deployment 与 service deployment会创建rc, rc会创建pod # 1.写deployment kubectl create deployment alpine --image=alpine # 2.执行 kubectl expose deployment/alpine --name=apine-svc --port=80 --type=NodePort # 3.查看是否成功 kubectl get pods #视情况 加namespace # 4.如果报错, 查看具体错误 kubectl describe pods \u003cpod-name\u003e ","date":"2021-11-08","objectID":"/posts/k8s/:3:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"工具 - kubeadm 集群创建工具 kubeadm init kubeadm reset 需要重新init的时候, 先执行reset kubeadm config print init-default kubeadm config print init-defaults --component-configs KubeProxyConfiguration,KubeletConfiguration \u003e kubeadm.yaml ","date":"2021-11-08","objectID":"/posts/k8s/:4:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"工具 - kubectl 集群管理工具 使用kubectl必须配置kubeconfig文件 放到~/.kube/config中 或者 使用 --kubeconfig来指定 ## kubectl 在 $HOME/.kube 目录中查找一个名为 config 的配置文件 ## 你可以通过设置 KUBECONFIG 环境变量或设置 --kubeconfig 参数来指定其它 kubeconfig 文件 cp -i /etc/kubernetes/admin.conf ~/.kube/config # 检查是否正常 kubectl cluster-info ","date":"2021-11-08","objectID":"/posts/k8s/:5:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"常用命令 kubectl cmd type cmd: get describe type: node namespace deployment pod ","date":"2021-11-08","objectID":"/posts/k8s/:5:1","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"常用命令2 # 转发monitoring/svc=prometheus-k8s的端口9090到 localhost的9000 # 如果不写9000:9090, 只写9090, 表示转发svc的9090到 localhost的9090 kubectl -n monitoring port-forward svc/prometheus-k8s 9000:9090 # 其输出如下 Forwarding from 127.0.0.1:9000 -\u003e 9090 Forwarding from [::1]:9000 -\u003e 9090 # 看上面的输出, 我们知道, 这个端口转发只对localhost生效, 外部网络无法访问 # 如果想从外部可以访问, 我们可以使用nginx反向代理, 转发remote-port到9000 # ingress同样的道理 ","date":"2021-11-08","objectID":"/posts/k8s/:5:2","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"工具 - kubelet work-node 运行需要, master不建议运行 配置文件在/var/lib/kubelet/config.yaml 如果遇到cgroup错误, 可以修改–cgroup-driver=cgroupfs, 然后重新启动kubelet systemctl daemon-reload systemctl enable kubelet systemctl status kubelet root@ubt:/home/dev_wangchengqing# kubectl get nodes NAME STATUS ROLES AGE VERSION ubt NotReady \u003cnone\u003e 3h21m v1.22.3 # NotReady 是因为还没有部署网络插件 ","date":"2021-11-08","objectID":"/posts/k8s/:6:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"插件 - calico # 1.node节点数小于50的配置文件; 如果node节点数大于50, 请参考官网 curl https://docs.projectcalico.org/manifests/calico.yaml -O # 2.如果本地地址在192.168.0.0/16, 需要设置calico的ip地址 # 修改 CALICO_IPV4POOL_CIDR的value的值即可 # 3.执行插件的安装 kubectl apply -f calico.yaml # 4. 确认是否安装成功 kubectl get pods --all-namespaces # coredns 会在网络插件安装成功之后启动 Pending -\u003e Running # 同时kubectl get nodes中的 STATUS会变为Ready ","date":"2021-11-08","objectID":"/posts/k8s/:7:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"插件 - ingress-nginx # 下载yaml curl -L https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.0.4/deploy/static/provider/cloud/deploy.yaml \u003e ingress-nginx.yaml # 修改yaml中的mirror sed -i 's#k8s.gcr.io/ingress-nginx#docker.io/clay2019#g' ingress-nginx.yaml # 部署ingress-nginx kubectl apply -f ${ingress-n-yaml} # 查看是否安装成功 kubectl get pods -n ingress-nginx # 1. 查看已有的ingress kubectl get ingress # 不确定是否有用的时候, 可以 kubectl describe ingress \u003cingress-name\u003e # 2. 编写ingress.yaml ## 编写的时候注意 backend的命名空间 # 3. apply kubectl apply -f ingress.yaml # 4. check 查看是否正常 kubectl describe ingress \u003cingress-name\u003e apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: test namespace: monitoring # 需要增加annotations字段的内容, 否则会提示404, 不知道为什么 annotations: ingress.kubernetes.io/rewrite-target: / kubernetes.io/ingress.class: nginx spec: rules: - http: paths: - path: / pathType: Prefix backend: service: name: prometheus-k8s port: number: 9090 # 当ingress-controller与ingress-rule正确部署之后 # 查看一下ingess-controller命名空间下的svc, 获取到port kubectl get svr -n ingress-nginx # 输出如下 root@ubt:/home/dev_wangchengqing# kubectl get svc -n ingress-nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ingress-nginx-controller LoadBalancer 10.108.147.62 \u003cpending\u003e 80:31468/TCP,443:31055/TCP 61m ingress-nginx-controller-admission ClusterIP 10.107.83.233 \u003cnone\u003e 443/TCP 61m # A为ingress-controller所在的机器的ip地址 # 从输出中可以看到, ingress-controller的svc把自身80端口映射到了31468端口 (31468端口由kube-proxy监听) # 因此我们访问A:31468, 会访问到ingress-controller的10.108.147.62:80 # 然后ingress-controller 会根据 ingress-rule把我们的转发, 下发到不同的backends service ","date":"2021-11-08","objectID":"/posts/k8s/:8:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"命名空间问题 Now, Ingress Controller can be deployed in any namespace and is, in fact, usually deployed in a namespace separate from your app services. It can out-of-the-box see Ingress rules in all namespaces in the cluster and will pick them up. The Ingress rules, however, must reside in the namespace where the app that they configure reside. ingress-controller常常有独立的namespace. 其可以获取所有namespaces中的ingress-rule ingress-rule, 需要与backend保持同一个namespace ","date":"2021-11-08","objectID":"/posts/k8s/:8:1","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"TODO ingress-rule配置问题 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: test namespace: monitoring annotations: kubernetes.io/ingress.class: nginx nginx.ingress.kubernetes.io/rewrite-target: / spec: rules: - http: paths: - path: / pathType: Prefix backend: service: name: grafana port: number: 3000 如果path配置了/app, curl ip:port/app的时候确实可以拉取到 但是进不去 如果path配置了/ , crul ip:port 的时候就是正常的 猜测原因 当配置为/app的时候, 访问ip:port/app时候, 会被重定向为 backend:port/xxx xxx一般为backend service对外提供的, 比如 prometheus的为http://mytest.com/login 这时候url在client被修改为ip:port/login 但是在ingress-rule中并没有对ip:port/login的处理规则, 因此提示404 解决方法 暂时回避了该问题, 使用多个host 取代 \u003c单host+ 多path\u003e的方式 apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: test namespace: monitoring annotations: kubernetes.io/ingress.class: nginx nginx.ingress.kubernetes.io/rewrite-target: / spec: rules: - host: g.mytest.com http: paths: - path: / pathType: Prefix backend: service: name: grafana port: number: 3000 - host: p.mytest.com http: paths: - path: / pathType: Prefix backend: service: name: prometheus-k8s port: number: 9090 ","date":"2021-11-08","objectID":"/posts/k8s/:8:2","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"监控 使用grafana + prometheus来监控k8s 使用kube-prometheus来配置监控系统 ","date":"2021-11-08","objectID":"/posts/k8s/:9:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"安装 替换被墙的镜像的源 *-deployment.yaml中搜索image关键字, 可以看到需要下载那些镜像 具体的文件有 blackbox-exporter-deployment.yaml grafana-deployment.yaml kube-state-metrics-deployment.yaml 包含k8s.gcr.io中的镜像, 需要提前替换 prometheus-adapter-deployment.yaml 包含k8s.gcr.io中的镜像, 需要提前替换 prometheus-prometheus.yaml prometheus镜像 修改kubelet configuration cat /var/lib/kubelet/config.yaml查看 set config.yaml authentication.webhook.enabled to true. 或者 kubelet –authentication-token-webhook=true set config.yaml authorization.mode to Webhook. 或者 kubelet –authorization-mode=Webhook kubectl create -f manifests/setup 等待下面的镜像下载完成 quay.io/brancz/kube-rbac-proxy quay.io/prometheus-operator/prometheus-operator until kubectl get servicemonitors –all-namespaces ; do date; sleep 1; echo “\"; done 官方该命令只是确保 kubectl create -f manifests/setup执行完毕, 没有实际意义 kubectl create -f manifests/ 查看images镜像 和 kubectl get pods -n monitoring查看安装进度 卸载kube-prometheus kubectl delete --ignore-not-found=true -f manifests/ -f manifests/setup # 对于某些无法卸载的, 可以使用强制卸载 kubectl delete pod -n monitoring \u003cpod-name\u003e --force ","date":"2021-11-08","objectID":"/posts/k8s/:9:1","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"grafana dashboard配置 使用kube-prometheus安装完成之后, 默认的dashboards在defalut目录下, 包含了alertmanager, kubenets,node-export, prometheus等各种dashboard信息, 以及足够使用 ","date":"2021-11-08","objectID":"/posts/k8s/:9:2","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"报警配置 ","date":"2021-11-08","objectID":"/posts/k8s/:9:3","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"kubernetes 错误排查 首先确认master节点是否安装成功 # 查看kube-apiserver, kube-controller-manager, kube-scheduler, etcd, pause服务 #kubectl get pods -n kube-system # -n表示namespace kubectl get pods --all-namespaces # 查看所有namespace的pods信息 # coredns为pending是正常的, 其在等待CNI网络插件 再确认node节点是否成功 kubectl get nodes kubectl get nodes -o wide #获取更详细信息 # Node状态为NotReady是正常的, 其在等待CNI网络插件 ","date":"2021-11-08","objectID":"/posts/k8s/:10:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"Q\u0026A node的状态显示为NotReady # kubectl get nodes # 显示STATUS为notReady # 1. 先查看node上的kubelet是否启动 systemctl status kubelet #如果未启动或者报错, 重启kubelet, systemctl restart kubelet # 2. 再看网络插件(CNI插件)是否安装 kubectl get pods --all-namespaces kubelet 找不到node journalctl -xeu kubelet Nov 05 17:22:16 ubt kubelet[775493]: E1105 17:22:16.246230 775493 kubelet.go:2412] \"Error getting node\" err=\"node \\\"node\\\" not found\" # kubeadm init --config kubeadm.yaml的 kubeadm.yaml中修改nodeRegistration.name为 执行机的hostname nodeRegistration: criSocket: /var/run/dockershim.sock imagePullPolicy: IfNotPresent name: k8s-m1 # 修改为执行节点的hostname，不然会提示找不到node taints: null localAPIEndpoint: advertiseAddress: 1.2.3.4 #修改为master机器的ip bindPort: 6443 kubelet 提示cgroup错误 # kubeadm init --config kubeadm.yaml的 kubeadm.yaml中修改nodeRegistration.name为 执行机的hostname # cgroupDriver: systemd -- 这里暂时不知道什么意思, 修改为cgroupfs cgroupDriver: cgroupfs pod启动失败: had taint {node-role.kubernetes.io/master: }, that the pod didn’t tolerate. root@ubt:/home/dev_wangchengqing# kubectl describe pods alpine-6b967c77f7-9rvv2 Name: alpine-6b967c77f7-9rvv2 Namespace: default Priority: 0 Node: \u003cnone\u003e Labels: app=alpine pod-template-hash=6b967c77f7 Annotations: \u003cnone\u003e Status: Pending IP: IPs: \u003cnone\u003e Controlled By: ReplicaSet/alpine-6b967c77f7 Containers: alpine: Image: alpine Port: \u003cnone\u003e Host Port: \u003cnone\u003e Environment: \u003cnone\u003e Mounts: /var/run/secrets/kubernetes.io/serviceaccount from kube-api-access-kwqhc (ro) Conditions: Type Status PodScheduled False Volumes: kube-api-access-kwqhc: Type: Projected (a volume that contains injected data from multiple sources) TokenExpirationSeconds: 3607 ConfigMapName: kube-root-ca.crt ConfigMapOptional: \u003cnil\u003e DownwardAPI: true QoS Class: BestEffort Node-Selectors: \u003cnone\u003e Tolerations: node.kubernetes.io/not-ready:NoExecute op=Exists for 300s node.kubernetes.io/unreachable:NoExecute op=Exists for 300s Events: Type Reason Age From Message ---- ------ ---- ---- ------- Warning FailedScheduling 29s (x3 over 2m51s) default-scheduler 0/1 nodes are available: 1 node(s) had taint {node-role.kubernetes.io/master: }, that the pod didn't tolerate. # 因为 master 节点同时当 node 节点用，需要把 master 标签和污点去掉，默认 master 无法调度 # 去除master标签 kubectl label node ubt node-role.kubernetes.io/master- # 去除污点(无法调用schedule) kubectl taint node ubt node-role.kubernetes.io/master:NoSchedule- ingress-nginx提示404 确定ingress-controler启动 kubectl get svc -n ingress-nginx 确定ingress-rule配置正确 kubectl describe ingress -n ingress-nginx \u003cingress-name\u003e 重点查看annotations的配置 必须配置kubernetes.io/ingress.class: nginx 必须配置ingress.kubernetes.io/rewrite-target: / 确定访问的方式正确 确定backend的pod-ip:port可以访问 此处的port为backend自己的port(即backend所在的svc的port, backend pod是没有端口的?? TODONOW待确定) 确定backend的svc-ip:port可以访问 此处的port为backend自己的port 确定ingress-nginx的pod-ip:port可以访问 此处的port为ingress-nginxd的port 确定ingress-nginx的svc-ip:port可以访问 此处的port为ingress-nginx的port 确定本地 http://localhost:port可以访问 需要添加http标志, ingress-controler是对http的转发 此处的port为ingress-nginx映射的port 比如下方的话, 该port就是31468 root@ubt:/home/dev_wangchengqing# kubectl get svc -n ingress-nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ingress-nginx-controller LoadBalancer 10.108.147.62 \u003cpending\u003e 80:31468/TCP,443:31055/TCP 22h ingress-nginx-controller-admission ClusterIP 10.107.83.233 \u003cnone\u003e 443/TCP 22h 确定网络内其他主机可以访问 A-ip:port A-ip是ingress-nginx所在的机器的ip port是ingress-nginx隐射出来的port ingress-nginx svc 一直pending root@ubt:/home/dev_wangchengqing# kubectl get svc -n ingress-nginx NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE ingress-nginx-controller LoadBalancer 10.108.147.62 \u003cpending\u003e 80:31468/TCP,443:31055/TCP 23h ingress-nginx-controller-admission ClusterIP 10.107.83.233 \u003cnone\u003e 443/TCP 23h # 1. 确认所在环境是否支持LB(LoadBalancer), 本地以及大部分云服务器商 都不支持 # 如果是使用ingress-controller, 使用NodePort更好 # 2. 确认ingress-nginx/pod是否正常 pod处于ImagePullBackOff状态 kubectl get pods -n monitoring # 通过下面的命令查看是哪个镜像没有拉取到, 然后使用mirror-image拉取即可 kubectl describe pods -n monitoring \u003cpod-name\u003e pod处于pending状态 kubectl get pods -n monitoring # 先查看pod状态 kubectl describe pods -n \u003c","date":"2021-11-08","objectID":"/posts/k8s/:11:0","tags":["k8s"],"title":"k8s","uri":"/posts/k8s/"},{"categories":["tool"],"content":"cadvisor, influxdb, grafana 组成的监控系统 cadvisor 负责docker容器数据的收集 默认只显示2分钟的数据, 而且还没有保存, 因此需要数据库保存数据 influxdb 负责数据的保存 grafana 负责数据的展示, 其图表做的非常好 ","date":"2021-10-28","objectID":"/posts/monitor/:0:0","tags":["influxdb","cadvisor","grafana"],"title":"monitor","uri":"/posts/monitor/"},{"categories":["tool"],"content":"influxdb2.0 记录 创建流程 创建的时候需要先创建超级用户与组织org 这里的超级用户有web的权限, 貌似是web管理员 再创建bucket bucket = db + rp + ... 再创建数据库\u003cdb,rp\u003e, 需要关联到bucket与org 再创建数据库用户 关联到bucket与org 这里的用户只是数据库的, 没有web的权限 ","date":"2021-10-28","objectID":"/posts/monitor/:1:0","tags":["influxdb","cadvisor","grafana"],"title":"monitor","uri":"/posts/monitor/"},{"categories":["tool"],"content":"常用命令 查看用户 influx user list – 这里看到的是上面的超级用户, 有web权限的 influx v1 auth list – 这里是查看数据库的, v1是1.0的接口 查看数据库 influx v1 dbrp list – 可以看到db及其相关联的bucket等map信息 ","date":"2021-10-28","objectID":"/posts/monitor/:1:1","tags":["influxdb","cadvisor","grafana"],"title":"monitor","uri":"/posts/monitor/"},{"categories":["tool"],"content":"cadvisor ","date":"2021-10-28","objectID":"/posts/monitor/:2:0","tags":["influxdb","cadvisor","grafana"],"title":"monitor","uri":"/posts/monitor/"},{"categories":["tool"],"content":"写入influxdb中的数据格式 _measurement – 表 cpu_usage_per_cpu cpu_usage_system cpu_usage_total cpu_usage_user fs_limit fs_usage load_average memory_cache memory_failcnt memory_failure memory_mapped_file memory_max_usage memory_rss memory_swap memory_usage memory_working_set referenced_momory rx_bytes rx_erros tx_bytes tx_erros _field – key value instance – per_cpu的编号(cpu核) machine – 物理机器名字 container_name – 容器名字 device failure_type pgmajfault scope hierarchical type limit usage //确认 Group下面有: _start _stop _time _measurement ","date":"2021-10-28","objectID":"/posts/monitor/:2:1","tags":["influxdb","cadvisor","grafana"],"title":"monitor","uri":"/posts/monitor/"},{"categories":["tool"],"content":"grafana ","date":"2021-10-28","objectID":"/posts/monitor/:3:0","tags":["influxdb","cadvisor","grafana"],"title":"monitor","uri":"/posts/monitor/"},{"categories":["tool"],"content":"使用Flux查询influxdb注意事项 from 前面不能加data =, 否则数据会流向data 不能加yield(), 否则数据不显示 from(bucket: \"qybucket\") |\u003e range(start: v.timeRangeStart, stop:v.timeRangeStop) |\u003e filter(fn: (r) =\u003e r._measurement == \"cpu_usage_total\" and r._field == \"value\" ) ","date":"2021-10-28","objectID":"/posts/monitor/:3:1","tags":["influxdb","cadvisor","grafana"],"title":"monitor","uri":"/posts/monitor/"},{"categories":["tool"],"content":"dashboard 一个dashboard 由1个多个panel面板组成, 可以有多个dashboard 每个dashboard对应一个xx.yaml 每个面板对应一个配置文件xx.json dashboard的配置文件xx.yaml中有个特殊的字段, 可以把指定目录下的 子目录变为dashboard, 子目录下的xx.json变为面板 path: $GF_PATHS_PROVISIONING/dashboards foldersFromFilesStructure: true 当 foldersFromFilesStructure设置为true的时候, path下的子目录名字会变为dashboard的名字 子目录下的xx.json会变为该dashboard下的panel面板 这样我们只需要配置一个总的yaml, 然后规划path下的目录层级即可, 方便进行统一的管理 ","date":"2021-10-28","objectID":"/posts/monitor/:3:2","tags":["influxdb","cadvisor","grafana"],"title":"monitor","uri":"/posts/monitor/"},{"categories":["tool"],"content":"prometheus","date":"2021-10-28","objectID":"/posts/monitor/:4:0","tags":["influxdb","cadvisor","grafana"],"title":"monitor","uri":"/posts/monitor/"},{"categories":["system"],"content":"linux常用命令\u0026\u0026工具 ","date":"2021-10-18","objectID":"/posts/linux/:0:0","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"查看系统信息 ","date":"2021-10-18","objectID":"/posts/linux/:1:0","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"cpu cat /proc/cpuinfo| grep “physical id\"| sort| uniq| wc -l cat /proc/cpuinfo| grep “cpu cores\"| uniq cat /proc/cpuinfo| grep “processor\"| wc -l cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c ","date":"2021-10-18","objectID":"/posts/linux/:1:1","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"查看库 (动态库, 静态库)的封装信息 readelf nm objdump ","date":"2021-10-18","objectID":"/posts/linux/:1:2","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"fd 查询 所有进程允许打开的最大fd数量。查询语句： /proc/sys/fs/file-max 所有进程已经打开的fd数量及允许的最大数量。查询语句： /proc/sys/fs/file-nr 单个进程允许打开的最大fd数量.查询语句： ulimit -n 单个进程（例如进程id为5454）已经打开的fd.查询语句： ls -l /proc/5454/fd/ 设置 单个进程允许打开的最大fd数量 # 用户单进程最大; 仅当前sesstion生效 # ulimit -n 实际是 ulimit -Sn (Soft软件) # H硬件是 ulimit -Hn ulimit -n xx # 用户单进程S(软件)最大 -- 需要重新登录生效 echo '* soft nofile 1048576' \u003e\u003e /etc/security/limits.conf # 用户单进程H(硬件)最大 -- 需要重新登录生效 # 该值一定不能大于fs.nr_open, 否则注销后将无法正常登录!!! echo '* hard nofile 1048576' \u003e\u003e /etc/security/limits.conf # 重点!!! 以上3个的配置数都受限于fs.nr_open -- 调用sysctl -p生效 sysctl -w fs.nr_open=xxx ","date":"2021-10-18","objectID":"/posts/linux/:1:3","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"socket 命令: ss socket Statistics – socket统计信息 比netstat 更快 ","date":"2021-10-18","objectID":"/posts/linux/:1:4","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"必备命令(软件) ","date":"2021-10-18","objectID":"/posts/linux/:2:0","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"top # top 当前系统时间; 启动了3小时45分钟; user同时在线的用户; load average服务器1min, 5min, 15min的负载情况 # load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。 # 如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了 # Tasks 总共开启了27个进程, 1个在run, 26个sleep, 0stoped, 0僵尸进程zombie # %cpu 总核数的平均值(不会大于100%), us用户占比, sy系统占比, ni用户进程空间内改变过优先级的进程占用CPU百分比 # id空闲cpu百分比, wa用户进程空间内改变过优先级的进程占用CPU百分比, hi硬件中断, si软件中断, st实时 # MiB Mem total系统物理总内存, free空闲内存, used已使用, buff/cache缓冲区内存 # MiB Swap total交换总内存, free交换空闲, used交换已用, avail 可用内存 # 这一系列信息是系统的信息, docker容器内外是一致的 top - 12:19:58 up 3:45, 1 user, load average: 0.00, 0.02, 0.05 Tasks: 27 total, 1 running, 26 sleeping, 0 stopped, 0 zombie %Cpu(s): 1.5 us, 1.1 sy, 0.0 ni, 97.2 id, 0.0 wa, 0.0 hi, 0.2 si, 0.0 st MiB Mem : 64348.3 total, 39305.2 free, 11285.5 used, 13757.6 buff/cache MiB Swap: 8192.0 total, 8192.0 free, 0.0 used. 52690.6 avail Mem # pid pid # user 谁启动的该进程 # PR 优先级 # ni nice值 负值表示高优先级，正值表示低优先级 # VIRT 虚拟内存 # RES 真实内存 # SHR 共享内存 # %CPU 单核cpu占比, 大于100%表示占用了多个cpu核, 不能大于100% * cpu核数 # TIME+ 进程运行总时间??占用cpu的总时间?? # COMMAND 进程启动时的命令 PID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 122 root 20 0 12936 7148 6648 S 1.0 0.0 2:32.20 cli 69 root 20 0 12928 7064 6572 S 0.7 0.0 2:07.64 svr 125 root 20 0 27728 17472 3944 S 0.3 0.0 1:01.14 cli 123 root 20 0 27728 17316 3880 S 0.3 0.0 1:01.08 cli 126 root 20 0 27728 17436 3948 S 0.3 0.0 1:01.07 cli 124 root 20 0 27728 17380 3852 S 0.3 0.0 1:00.94 cli 132 root 20 0 27728 17436 3948 S 0.7 0.0 0:59.75 cli 1. 排序 \u003c -- 左移sort-field; 进入top时候默认sort-field是%cpu \u003e -- 右移sort-field R -- 反转排序 M -- (不推荐)根据%mem 排序 P -- (不推荐)根据%cpu 排序 T -- (不推荐)根据TIME+排序 2. 高亮 b -- 是否高亮显示 \u003cR进程 或者 sort-field\u003e, 总开关 x -- 是否高亮 sort-field y -- 是否高亮 R进程 z -- (不推荐)高亮显示 B -- (不推荐)加粗 3. 其他 1 -- 显示所有逻辑cpu k -- 关闭特定pid进程 s -- 设置刷新时间 4. 内存 m -- 切换mem显示, 显示使用百分比\u0026\u0026总内存 --\u003e (*used/total)% / total t -- 切换cpu显示, 没看明白; 仍然推荐看%Cpu-\u003eid 或者1查看所有核心的 1. 最小单位为进程, 线程信息需要通过ps去查看 ","date":"2021-10-18","objectID":"/posts/linux/:2:1","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"free # total 系统总内存 # used 已经使用的内存 # free 空闲的内存 -- 不等于可用内存 # shared 已经舍弃的内存??? # buff/cache io读写内存;内存紧张的时候,会自动释放; cache文件系统缓存; buff 裸设备相关缓存 # available 可用内存. = free + buff/cache total used free shared buff/cache available Mem: 62Gi 11Gi 38Gi 17Mi 13Gi 51Gi Swap: 8.0Gi 0B 8.0Gi ","date":"2021-10-18","objectID":"/posts/linux/:2:2","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"ss 查看socket 统计信息 这是system的统计信息, docker容器内外是一致的 # every 100s 每100s刷新一次 ss-s 851d60ae4404是服务器名字 服务器当前时间 # total: 这个数值是docker容器有关的, 每个单独计算; 貌似是inet + 1 TODONOW. # TCP: 2101 这个数值是docker容器无关的, 容器内外都一样; 貌似是state总和?? TODONOW # estab -- 这个数值是docker容器相关的, 每个单独计算 # closed -- 这个数值是docker容器相关的, 每个单独计算 # orphaned -- # timewait -- Every 100.0s: ss -s 851d60ae4404: Wed Oct 20 17:44:33 2021 Total: 3 TCP: 2101 (estab 0, closed 2100, orphaned 0, timewait 0) # RAW # UDP # TCP 这里的total是docker容器相关的, 每个单独计算 # INET # FRAG Transport Total IP IPv6 RAW 0 0 0 UDP 1 1 0 TCP 1 1 0 INET 2 2 0 FRAG 0 0 0 # ss默认只显示state = established状态的, 可以通过-a或state参数来控制显示 -a #显示所有状态的 # -4 ipv4 # -6 ipv6 # -t tcp协议 # -u udp协议 等等 ss -t # 匹配tcp连接 # dst -- 远端 # src -- 本地 ss dst 192.168.1.5 # 匹配远程地址 ss dst 192.168.1.5:443 # 匹配远程地址和端口 # dport -- # sport -- # 可以通过比较参数来选择某个区间的端口号 # le, ge, eq, ne, gt, lt -- 与sh的语法一致 ss sport lt 50 # 匹配小于50的端口号 # state 通过tcp连接状态进行过滤 # 常用状态 # established, SYN-SENT, syn-recv, fin-wait-1, fin-wait-2, time-wait, closed, close-wait, listen, closing ss state listening # 匹配listen状态 ","date":"2021-10-18","objectID":"/posts/linux/:2:3","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"netstat s 统计信息 t tcp ","date":"2021-10-18","objectID":"/posts/linux/:2:4","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"watch 周期性的执行某个命令 watch ss -s # 定时刷新ss-s命令 ","date":"2021-10-18","objectID":"/posts/linux/:2:5","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"crontab 定时任务, 具体见 man crontab ","date":"2021-10-18","objectID":"/posts/linux/:2:6","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"tmux \u0026\u0026 screen 为什么使用tmux 和 screen: 远程登录操作时候, 因网络不稳定, 总是掉线, 导致东西无法保存 讲解它们之前必须要先了解nohup 与 \u0026 nohup 与 \u0026 nohup与 \u0026都是后台运行 nohup会占用标准输出 \u0026则不会占用标准输出 它们的作用都是为了防止session关闭后, 程序无法运行 但每个程序都要加上 nohup前缀 或者 \u0026后缀, 则会特别麻烦, 因此出现了screen与tmux screen screen属于GNU计划 然其操作什么的并不友善, 个人更倾向于tmux 【基本指令】 screen | screen -S 创建screen screen -d detach screen 只有deatch之后 其他人才能attach screen -r reatach screen 链接screen screen -ls | screen -list 列出所有的screen 【快捷键操作】 screen的一个弊端就是将太多功能放在了快捷键上 而不是放在CMD上 C-a 为screen指令的前缀 C-a k kill C-a w 列出所有的screen窗口 – 亲测无效??? C-a p |C-a n 切换到上一个或下一个窗口 – 亲测无效?? C-a z 类似于emacs的C-z 将程序放入后台 可以通过jobs 和fg操作 通过C-a z可以了解screen的工作原理 – screen就是新开了一个shell, 在里面有不同的窗口windows 然后可以在windows间切换, 或者是回到原先的shell中 【为什么放弃screen】 虽然查看教程, 发现screen还有很多高级功能, 然而screen的窗口功能太不友好, 导致我经常不知道自己工作 在哪个窗口下, 而且因为C-a w的无效, 很难有一览全局, 所以最后选择放弃screen, 改投tmux tmux 框架 server -\u003e session 01 | -\u003e session 02 | –\u003e socket 01(默认socket) -\u003e session 03 –\u003e socket 02(通过-L | -S生成的新的socket) … … 即一个server 多个session, session又属于socket 基本指令 tmux tmux ls 列出所有的tmux session, 注意没有- – tmux attach attch到上次的tmux session tmux attach -t session attch到指定的tmux session tmux kill-session -t 关闭session tmux kill-server -t 关闭server 注: 关闭server 将导致tmux关闭, tmux中的程序也会关闭 如果session退出之前, tmux是挂起状态stopped,那么下次session重新链接后, 将导致tmux关闭 tmux new -s $sessionName 创建一个新的session, 并指定其名称, 不然就是递增数字 快捷键操作 tmux以C-b作为快捷键的前缀 C-b ? 列出所有的命令 C-b 数字 | n | p 切换窗口 C-b C-z 挂起程序 C-b d deatach类似于screen中的deatch deatch之后就可以回到正常的shell, 并使tmux运行在后台 为什么选择tmux 友好的界面, 友好的C-b ?帮助提示, 简单的操作 遗留问题 如果运行 tmux\u0026 (\u0026后台运行), 会导致莫名其妙的问题 如何使tmux在后台运行 使用bg命令无效, 这与进程的状态有关…有时间再看 C-b d 使当前session deatch运行在后台 ","date":"2021-10-18","objectID":"/posts/linux/:2:7","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"ffmpeg 强大的视频解码软件 ffmpeg -i https://××××××××/really.m3u8 -c copy xxx.mp4 ","date":"2021-10-18","objectID":"/posts/linux/:2:8","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"sort 根据ASCII进行排序, 默认为升序 u 去除重复行 r 降序 n 根据数值进行排序 你有没有遇到过10比2小的情况。我反正遇到过。 出现这种情况是由于排序程序将这些数字按字符来排序了，排序程序会先比较1和2，显然1小，所以就将10放在2前面 -n可以告诉sort根据数值进行排序, 而非ASCII k, t k指定列数, t指定分隔符 f 会将小写字母都转换为大写字母来进行比较，亦即忽略大小写 ","date":"2021-10-18","objectID":"/posts/linux/:2:9","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"wc -l 统计行数 ","date":"2021-10-18","objectID":"/posts/linux/:2:10","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"管道 ","date":"2021-10-18","objectID":"/posts/linux/:3:0","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["system"],"content":"| \u0026\u0026 xargs 管道是实现“将前面的标准输出作为后面的标准输入” xargs是实现“将标准输入作为命令的参数” ","date":"2021-10-18","objectID":"/posts/linux/:3:1","tags":["linux"],"title":"linux","uri":"/posts/linux/"},{"categories":["tool"],"content":"docker-compose简化了container的命令 ","date":"2021-10-09","objectID":"/posts/docker-compose/:0:0","tags":["docker"],"title":"docker-compose","uri":"/posts/docker-compose/"},{"categories":["tool"],"content":"配置文件docker-compose.yml 如何支持docker run -itd中的itd参数 i交互 t:tty d后台运行 ","date":"2021-10-09","objectID":"/posts/docker-compose/:1:0","tags":["docker"],"title":"docker-compose","uri":"/posts/docker-compose/"},{"categories":["tool"],"content":"glog是google开发的日志库 ","date":"2021-10-09","objectID":"/posts/glog/:0:0","tags":["glog"],"title":"glog","uri":"/posts/glog/"},{"categories":["tool"],"content":"功能 ","date":"2021-10-09","objectID":"/posts/glog/:1:0","tags":["glog"],"title":"glog","uri":"/posts/glog/"},{"categories":["tool"],"content":"安装 ","date":"2021-10-09","objectID":"/posts/glog/:2:0","tags":["glog"],"title":"glog","uri":"/posts/glog/"},{"categories":["tool"],"content":"配置 ","date":"2021-10-09","objectID":"/posts/glog/:3:0","tags":["glog"],"title":"glog","uri":"/posts/glog/"},{"categories":["tool"],"content":"使用 LOG_IF(INFO, condition) LOG_EVERY_N(INFO, 20) 每20次 打印一次 LOG_IF_EVERY_N(INFO, condition, 20) 符合条件下, 每20次打印一次 LOG_FIRST_N(INFO, 20) 只打印前20次 LOG_EVERY_T(INFO, 2.35) 每2.35s打印一次 ","date":"2021-10-09","objectID":"/posts/glog/:4:0","tags":["glog"],"title":"glog","uri":"/posts/glog/"},{"categories":["tool"],"content":"记录 glog 参考文档 _https://zhuanlan.zhihu.com/p/26025722 severity levels INFO, WARNING, ERROR, FATAL setting flags in file You can also modify flag values in your program by modifying global variables FLAGS_* . Most settings start working immediately after you update FLAGS_* when run If the Google gflags library isn’t installed, you set flags via environment variables, prefixing the flag name with GLOG_, e.g., GLOG_logtostderr=1 ./your_application Debug mode conditional logging check macros VLOG – yourself-macro Custom Log Prefix Format Automatically remove old logs ","date":"2021-10-09","objectID":"/posts/glog/:5:0","tags":["glog"],"title":"glog","uri":"/posts/glog/"},{"categories":null,"content":"cmake ","date":"2021-10-08","objectID":"/posts/cmake/:0:0","tags":null,"title":"cmake","uri":"/posts/cmake/"},{"categories":null,"content":"参数 -S path_to_source -B path_to_build -G generator-name ","date":"2021-10-08","objectID":"/posts/cmake/:1:0","tags":null,"title":"cmake","uri":"/posts/cmake/"},{"categories":null,"content":"F\u0026Q err: Tell CMake where to find the compiler by setting either the environment variable \"CXX\" or the CMake cache entry CMAKE_CXX_COMPILER to the full path to the compiler, or to the compiler name if it is in the PATH. sln: sudo apt install gcc sudo apt install g++ ","date":"2021-10-08","objectID":"/posts/cmake/:2:0","tags":null,"title":"cmake","uri":"/posts/cmake/"},{"categories":["tool"],"content":"bash-shell ","date":"2021-10-03","objectID":"/posts/shell/:0:0","tags":["shell"],"title":"shell","uri":"/posts/shell/"},{"categories":["tool"],"content":"功能 ","date":"2021-10-03","objectID":"/posts/shell/:1:0","tags":["shell"],"title":"shell","uri":"/posts/shell/"},{"categories":["tool"],"content":"安装 ","date":"2021-10-03","objectID":"/posts/shell/:2:0","tags":["shell"],"title":"shell","uri":"/posts/shell/"},{"categories":["tool"],"content":"配置 ","date":"2021-10-03","objectID":"/posts/shell/:3:0","tags":["shell"],"title":"shell","uri":"/posts/shell/"},{"categories":["tool"],"content":"使用 ","date":"2021-10-03","objectID":"/posts/shell/:4:0","tags":["shell"],"title":"shell","uri":"/posts/shell/"},{"categories":["tool"],"content":"记录 exit 与 return return 退出函数; 在非函数地方, 无效 exit 在任何地方, 都代表推出sh $# 代表入参 sh脚本的入参在非函数地方调用 函数的入参在调用函数的地方传递 $@ 可以传递所有的参数到下一层 数组使用echo打印的话 只会显示第一个 与 区别 更高级, 识别与或非等; 而 不识别 ' ' 与 \" “区别 在 ' ‘中的变量不会被展开; ‘$a'显示出来是字面值$a 空语句 是 : 数组 ${name[@]} ${name[*]} 获取函数返回值 return的返回值 可以通过 $?获取 但是该返回值返回的只能是0-255的数字 fun_check $? # 获取fun_check的返回值 echo的返回值 可以通过$()调用获取 ret=$(fun_check) 获取文件名 和 扩展名 file=\"1.2.3.4.5\" ${file%%.*} # =\u003e1 ${file%.*} # =\u003e1.2.3.4 ${file#*.} # =\u003e2.3.4.5 ${file##*.} # =\u003e5 ","date":"2021-10-03","objectID":"/posts/shell/:5:0","tags":["shell"],"title":"shell","uri":"/posts/shell/"},{"categories":["gnu"],"content":"make记录 ","date":"2021-09-23","objectID":"/posts/make/:0:0","tags":null,"title":"make","uri":"/posts/make/"},{"categories":["gnu"],"content":"常用 make make clean make install – 编译成功的文件安装到系统目录 make dist 产生发布软件包文件（即distribution package 这个命令将会将可执行文件及相关文件打包成一个tar.gz压缩的文件用来作为发布软件的软件包。 它会在当前目录下生成一个名字类似“PACKAGE-VERSION.tar.gz”的文件 PACKAGE和VERSION，是我们在configure.in中定义的AM_INIT_AUTOMAKE(PACKAGE, VERSION) make distcheck 生成发布软件包并对其进行测试检查，以确定发布包的正确性 这个操作将自动把压缩包文件解开，然后执行configure命令，并且执行make，来确认编译不出现错误 最后提示你软件包已经准备好，可以发布了 ","date":"2021-09-23","objectID":"/posts/make/:1:0","tags":null,"title":"make","uri":"/posts/make/"},{"categories":["gnu"],"content":"make -j num 同时启动多少个jobs一起编译, 一般为系统内核数的2倍 make打印信息 不显示目录 make --no-print-directory make打印信息优化 SHOW_COMPILE=@echo -e \"\\033[36mCompling \\033[35m==\u003e \\033[33m$\u003c\\033[0m\" SHOW_LINK=@echo -e \"\\033[31mLINKING \\033[35m==\u003e \\033[33m$(EXEFILE)\\033[0m\" SHOW_DEBUG_BUILD=@echo -e \"\\033[31mBuilding Debug...\\033[0m\" SHOW_RELEASE_BUILD=@echo -e \"\\033[31mBuilding Release...\\033[0m\" makefile 中的 “+ - @” 实际为shell中的规则, 不是makefile中的 符号 作用 @ 使命令被执行前不回显 - 使任何命令行的非0退出状态都被忽略 + 使命令行可以通过制定-n -q或-t选项来执行 内置函数 patsubst 格式：$(patsubst ,, ) 名称：模式字符串替换函数——patsubst。 功能：查找中的单词（单词以“空格”、“Tab”或“回车”“换行”分隔）是否符合模式，如果匹配的话，则以替换。 这里，可以包括通配符“%”，表示任意长度的字串。如果中也包含“%”，那么，中的这个“%”将是中的那个“%”所代表的字串。 （可以用“\\”来转义，以“\\%”来表示真实含义的“%”字符） 返回：函数返回被替换过后的字符串。 示例： $(patsubst %.c,%.o, a.c b.c) 把字串“a.c b.c”符合模式[%.c]的单词替换成[%.o]，返回结果是“a.o b.o” $@ $^ $ $\u003c $? $@ 表示目标文件 $^ 表示所有的依赖文件 $\u003c 表示第一个依赖文件 $? 表示比目标还要新的依赖文件列表 gcc编译过程 预处理 -E .cpp -\u003e .i 汇编 -S .i -\u003e .s 编译 -c .s -\u003e .o -o 仅仅是输出目标的file_name, 不一定是连接后的file_name, 比如 gcc -S hello.i -o hello.s gcc 不带参数可以 跟随.cpp .i .s .o类型的文件, 会自动执行预处理, 汇编, 编译, 连接的动作 所以连接不需要指定参数 wildcard Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。 这种情况下如果需要通配符有效，就需要使用函数“wildcard”，它的用法是：$(wildcard PATTERN…) 。 在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。 如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。 需要注意的是：这种情况下规则中通配符的展开和上一小节匹配通配符的区别。 makefile只能在taget的地方调用shell, 其他地方无效 其他地方调用需要使用 $(shell cmd) ","date":"2021-09-23","objectID":"/posts/make/:2:0","tags":null,"title":"make","uri":"/posts/make/"},{"categories":["tool"],"content":"github记录 ","date":"2021-09-23","objectID":"/posts/github/:0:0","tags":["github"],"title":"github","uri":"/posts/github/"},{"categories":["tool"],"content":"github 认证方式 Github 本身提供了多种认证方式，所有开发人员可以各取所需。 SSH，这是最原始的方式，如果使用git bash只要按照官方文档一步一步配置就好了 小心坑：SSH有可能需要配置代理，否则无法解析服务器域名。错误如下： ssh: Could not resolve hostname github.com: no address associated with name 解决办法：给SSH以及git 客户端配置代理。 HTTPS，这也是比较方便的方式，但是每一次都需要输入用户名和密码。 小心坑：本机的SSL证书不是正规机构颁发的，验证失败。错误如下： fatal: unable to access ‘https://github.com/owner/repo.git/': SSL certificate problem: unable to get local issuer certificate 解决办法：将Git的SSL验证关闭，命令如下。 git config –global http.sslVerify false Access Token，我个人认为最为便捷的方式之一，不失安全性。 https://help.github.com/articles/creating-an-access-token-for-command-line-use/ 使用方法： 从Settings页面生成唯一的Token 手动拼接出远程仓库的地址，比如：https://%24GH%5FTOKEN@github.com/owner/repo.git 3）从以上地址克隆或使用git remote add 的方式关联本地仓库，之后都不需要输入用户名和密码信息 ","date":"2021-09-23","objectID":"/posts/github/:1:0","tags":["github"],"title":"github","uri":"/posts/github/"},{"categories":["tool"],"content":"github action实例解析 – hugo workflow中所有缩进必须是空格, 不能是tab name: github page on: push: branches: master # Set a branch to deploy pull_request: jobs: deploy: runs-on: ubuntu-20.04 steps: uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: ‘latest’ name: Build run: hugo –minify name: Deploy uses: peaceiris/actions-gh-pages@v3 if: github.ref == ‘refs/heads/master’ with: github_token: ${{ secrets.HUGO_PUBLISH_TOKEN }} publish_dir: ./public ","date":"2021-09-23","objectID":"/posts/github/:2:0","tags":["github"],"title":"github","uri":"/posts/github/"},{"categories":["tool"],"content":"github action实例解析 – qygame调用docker name: ‘make for qygame’ autho: wcq description: ‘make for qygame’ inputs: qygame_token: description: ‘Set a generated GITHUB_TOKEN for pushing to the remote branch.’ required: true runs: using: ‘docker’ image: ‘Dockerfile’ ","date":"2021-09-23","objectID":"/posts/github/:3:0","tags":["github"],"title":"github","uri":"/posts/github/"},{"categories":["tool"],"content":"程序检测工具 ","date":"2021-08-28","objectID":"/posts/valgrind/:0:0","tags":["valgrind"],"title":"valgrind","uri":"/posts/valgrind/"},{"categories":["tool"],"content":"valgrind 程序性能查看工具,号称程序员的瑞士军刀 可以查看内存信息, 函数调用, cache信息等等 ","date":"2021-08-28","objectID":"/posts/valgrind/:1:0","tags":["valgrind"],"title":"valgrind","uri":"/posts/valgrind/"},{"categories":["tool"],"content":"使用hexo + org-mode + github搭建blog ","date":"2021-08-28","objectID":"/posts/hexo/:0:0","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"为什么要用hexo 说hexo之前, 必须先说blog. blog作用有下: 利己, 整理自身知识体系 或作记录 利人, 分享的精神 blog好处很多, 却也增加了使用者的难度, 比如要理解html等. 同时, 外在的表现(CSS等)往往会导致bloger的重心偏差, 去追求外在的东西. 我们需要一个能让我们专注于文章知识本身, 而无需去关心外在或其他知识的工具, 来帮助我们搭建自己的blog. 当下, 一个不错的选择就是hexo. hexo不拘束我们的文章语言(markdown, org等), 自动将语言转化为html, 并且提供不错的外观. 使我们可以专注文章本身. ","date":"2021-08-28","objectID":"/posts/hexo/:1:0","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo是什么 如上所言, hexo是一款不错的blog框架 hexo的主要优点: 不限制前端语言 自动化生成html 丰富便捷的themes 统一干净的包管理npm 部署简单, 集成方便 迅速上手, 学习时间短 hexo的缺点: 环境无法移植 在A pc上搭建的环境, 只能在A pc上发布blog ","date":"2021-08-28","objectID":"/posts/hexo/:2:0","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo怎么使用 ","date":"2021-08-28","objectID":"/posts/hexo/:3:0","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo安装 详细点此查看官网 安装 Node.js, 获得npm包管理工具 安装 Git 安装 Hexo $ npm install -g hexo-cli 至此, hexo已完成安装 安装hexo-renderer-org 这里是org-mode与hexo的结合使用, 非官方的markdown. 根据hexo-renderer-org官方文档一步步操作即可, 具体不详解. 唯一注意的点是: Emacs line的版本要 \u003e= 24 org-mode的版本最好 \u003e= 9.0 使用的分支是coldnew, 而不是master或emacs! ","date":"2021-08-28","objectID":"/posts/hexo/:3:1","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo创建blog 详情点此查看 创建并初始化blog目录 mkdir blog cd blog hexo init 注意事项: hexo命令(例如hexo g) 应该在 hexo init所在目录下使用(上面中是blog目录) ","date":"2021-08-28","objectID":"/posts/hexo/:3:2","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo配置 基本配置 Site ## 标题 title: ## 副标题 subtitle: ## SEO优化 description: keywords ## 作者 author: ## 语言 language: zh-Hans URL ## 访问地址 url: https://clay9.github.io/ ## root地址 root: / Deployment ## 仓库地址 deploy: https://github.com/clay9/clay9.github.io.git ## 仓库协议类型 type: git org ## emacs path, 使用bash环境 emacs: ## emacsclient path emacclinet: Extensions ## 主题 theme: next 主题配置:next scheme scheme: Mist ","date":"2021-08-28","objectID":"/posts/hexo/:3:3","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo使用 文件链接 hexo-renderer-org支持使用org-mode的文件链接方式. 但是有一定的限制. 如果要发布的org文件的名字为A.org. 那么: A.org中链接的文件必须放在A目录下, 且A目录与A.org同级. A.org中链接文件格式为: file:A/文件名字 ","date":"2021-08-28","objectID":"/posts/hexo/:3:4","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo部署 hexo支持多渠道发布, 具体看官网, 这里只说发布到github hexo处理 安装 hexo-deployer-git $ npm install hexo-deployer-git --save 修改blog/_config.yml deploy: type: git repo: \u003crepository url\u003e branch: [branch] github处理 新建项目, 名字为: [YourName].github.io 至此github方面完成 测试 生成并部署到github上 hexo g -d 在web中打开[Yourname].github.io, 查看是否可以显示 ","date":"2021-08-28","objectID":"/posts/hexo/:3:5","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"hexo高级用法 ","date":"2021-08-28","objectID":"/posts/hexo/:4:0","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"自定义域名 实现可以通过wcq.fun 与 www.wcq.fun均可访问 hexo配置 blog/source目录下新增CNAME文件, 其内容为域名, 比如 wcq.fun 域名服务商配置 wcq.fun绑定教程 www.wcq.fun绑定教程 ","date":"2021-08-28","objectID":"/posts/hexo/:4:1","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"鼠标点击小心心效果 在themes/next/source/js/src/下新建love.js文件 并且copy下面的代码到love.js中 在themes/next/layout/_layout.swig末尾添加以下代码: \u003c!-- 页面点击小红心 --\u003e \u003cscript type=\"text/javascript\" src=\"/js/src/love.js\"\u003e\u003c/script\u003e ","date":"2021-08-28","objectID":"/posts/hexo/:4:2","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"next主题安装第三方插件 搜索 这里使用的是local search ","date":"2021-08-28","objectID":"/posts/hexo/:4:3","tags":["hexo"],"title":"hexo搭建blog","uri":"/posts/hexo/"},{"categories":["tool"],"content":"docker安装gitlab ","date":"2021-08-28","objectID":"/posts/gitlab/:0:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"为什么要用gitlab git分布式架构,本身没有服务器之说.但为了团队开发, 总有一台电脑充当服务器的角色.我们称之为Public, 意为公共库. 有了Public之后, 所有人都通过该库进行交流. 如果有人恶意或无意损坏了该库的代码, 将导致不可预估的风险.因此我们希望能够对该库进行权限控制. 笔者最开始接触的控制软件是gitosis, 本质仍是通过控制public_key, private_key来管理人员.现在想来, 其缺点非常明显: 配置时候容易出错 无法直观展示人员和项目 除了管理员, 其他人都项目和人员无法认知 虽然gitosis满足了权限的需求, 但是却无法提供良好的用户体验. 对于git, 不应该仅仅是在控制权限方面, 更应该是: 交流, 思想的分享 使用简单便捷 配置简单直观 这些gitlab都完全满足, 并且其允许代码放置在自己的服务器上, 这避免了代码泄漏到internet, 对于企业来说, 非常重要. 省去了在github买private的钱… 当然, gitlab还有非常多惊喜的地方, 比如CI|CD等 ","date":"2021-08-28","objectID":"/posts/gitlab/:1:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab是什么 综上所述, gitlab是一款优秀的git代码管理软件. 其主要优点: 安装简单, 使用简单, 配置简单 团队项目交流方便 完善的开发流程, 主要是CI, CD 可部署在自己的服务器, 减少了代码泄露风险 ","date":"2021-08-28","objectID":"/posts/gitlab/:2:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab怎么用 ","date":"2021-08-28","objectID":"/posts/gitlab/:3:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab安装 安装方式很多, 这里采用docker安装, 因为简单. 安装Docker 在GUI模式(Kitmatic)中搜索并安装gitlabb-ce 或者Docker命令行安装 ","date":"2021-08-28","objectID":"/posts/gitlab/:3:1","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab配置 Settings Volumes下面配置文件路径 Settings Hostname/Posts下配置端口转发 /etc/gitlab/gitlab.rb 中 external_url “http://www.45quyou.com” 该字段不仅仅影响登陆, 还会影响项目的显示 /var/opt/gitlab/gitlab-rails/etc/gitlab.yml 中 Web Server Settings中的host www.45quyou.com ","date":"2021-08-28","objectID":"/posts/gitlab/:3:2","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab使用 配置生效 sudo gitlab-ctl reconfigure 重启进程 sudo gitlab-ce stop | start | restart ","date":"2021-08-28","objectID":"/posts/gitlab/:3:3","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"gitlab高级用法 ","date":"2021-08-28","objectID":"/posts/gitlab/:4:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"CI CI: 持续集成 注册 gitlab-runner 在仓库根目录下添加.gitlab-ci.yml文件 piple stage jobs ","date":"2021-08-28","objectID":"/posts/gitlab/:4:1","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"常见问题 KiteMatic 卡在Starting Docker VM界面 解决办法: 完全关闭 KietMatic 和 Docker进程 下载 reset脚本 打开命令行, 执行 ./reset 启动Docker 启动KiteMatic ","date":"2021-08-28","objectID":"/posts/gitlab/:5:0","tags":["gitlab"],"title":"mac搭建gitlab服务器","uri":"/posts/gitlab/"},{"categories":["tool"],"content":"nginx是使用率最高的web容器 ","date":"2021-08-28","objectID":"/posts/nginx/:0:0","tags":["nginx"],"title":"nginx","uri":"/posts/nginx/"},{"categories":["tool"],"content":"安装 docker pull nginx docker run --name nginx-test -p 8080:80 -d nginx ","date":"2021-08-28","objectID":"/posts/nginx/:1:0","tags":["nginx"],"title":"nginx","uri":"/posts/nginx/"},{"categories":["tool"],"content":"配置 配置文件在/etc/nginx /etc/nginx/nginx.conf是总的, 默认不修改 /etc/nginx/config.d/* 下的是配置的, 一般一个文件配置一个站点 ","date":"2021-08-28","objectID":"/posts/nginx/:2:0","tags":["nginx"],"title":"nginx","uri":"/posts/nginx/"},{"categories":["tool"],"content":"使用","date":"2021-08-28","objectID":"/posts/nginx/:3:0","tags":["nginx"],"title":"nginx","uri":"/posts/nginx/"},{"categories":["tool"],"content":"docker容器 ","date":"2021-08-28","objectID":"/posts/docker/:0:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"功能 ","date":"2021-08-28","objectID":"/posts/docker/:1:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"为什么需要docker ","date":"2021-08-28","objectID":"/posts/docker/:1:1","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"docker与虚拟机的对比 之前以为docker容器就是简约版本的虚拟机, 所以一直想把不同的软件融合到一个镜像中 现在2020.6.21 发现上面的想法是错误的 现在的认知: docker是对于app(单个软件)的封装 多个软件协同合作的正确方式, 应该是建立多个互相关联的容器, 而不是企图把所有的软件放到一个容器中 ","date":"2021-08-28","objectID":"/posts/docker/:1:2","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"安装 安装docker 安装Kitmatic docker gui工具; 不推荐使用 ","date":"2021-08-28","objectID":"/posts/docker/:2:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"配置 镜像配置 使用中国科技大学镜像加速, 无须注册, 直接使用即可 ","date":"2021-08-28","objectID":"/posts/docker/:3:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"使用 推荐阅读教程 TODONOW 待补充 docker实际应用 web服务器 + php + laravel + 数据库 ","date":"2021-08-28","objectID":"/posts/docker/:4:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"镜像操作 搜索镜像 docker search 下载镜像 docker pull 实例化镜像 镜像实例化为容器 (类比C++中的类–镜像, 对象–容器) docker run -e “参数” -P 端口映射 –name 容器名字 -d(后台运行) image名字 -p 本机端口 : 容器端口 -v 本机路径 : 容器路径 镜像存储为文件 \u0026\u0026 加载 docker save image_name -o file_path docker load -i file_path 在网络不好的情况下, 可以直接使用文件的方式加载镜像 容器封装为镜像 docker commit [container_id] [image_name] image tag修改名字 docker tag [old_image_name] [new_image_name] 推送image到dockerhub 必须先登录dockerhub docker login 推送的时候image必须增加tag, tag的名字必须为 登录id/image名字 docker 官网速度太慢了, 建议存储为文件, 供别人使用 git push image ","date":"2021-08-28","objectID":"/posts/docker/:4:1","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"容器操作 查看容器 docker container ls -al 启动 关闭 重启容器 docker container start | stop | restart \u003ccontainer_id\u003e 重定义容器输出 docker container attach \u003ccontainer_id\u003e 进入到容器中 docker container exec -it \u003ccontainer_id\u003e COMMAND -i interactive -t tty COMMAND 一般都是bash环境. 比如: docker container exec -it mysql bash ","date":"2021-08-28","objectID":"/posts/docker/:4:2","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"本机与docker容器交互 文件传输 docker cp test mssql:/home 查看镜像ip地址 TODONOW 因hexo原因, 下面的命令会导致hexo无法编译org为html, 所以详见 ~/bin/docker_ip.sh ","date":"2021-08-28","objectID":"/posts/docker/:4:3","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"Dockerfile \u0026\u0026 docker-compose dockerfile – 对镜像的管理, 可以安装并修改镜像 (类比C++中的class) docker-compose – 对容器的管理, 可以指定使用哪个容器, 并能修改容器 (类比C++中的对象实例) docker-compose 是一个指令, docker-compose.yml是其配置文件 docker-compose -h查看用法 ","date":"2021-08-28","objectID":"/posts/docker/:4:4","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"网桥 通过指令docker network可以查看 docker中的网桥信息 网桥可以使多个容器组件局域网 容器可以在创建之前选择网桥 docker create --name [容器名称] --network [网桥名称] [镜像名称] 容器也可以在运行状态时 选择网桥 docker network connect [网桥名称] [容器名称] ","date":"2021-08-28","objectID":"/posts/docker/:4:5","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"卷 volume docker volume create 命令用于创建新卷。默认情况下，新卷创建使用 local 驱动，但是可以通过 -d 参数来指定不同的驱动。 docker volume ls 会列出本地 Docker 主机上的全部卷。 docker volume inspect 用于查看卷的详细信息。可以使用该命令查看卷在 Docker 主机文件系统中的具体位置。 docker volume prune 会删除未被容器或者服务副本使用的全部卷。 docker volume rm 删除未被使用的指定卷 ","date":"2021-08-28","objectID":"/posts/docker/:4:6","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"docker-compose ","date":"2021-08-28","objectID":"/posts/docker/:5:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"dockerfile COPY 注意事项 COPY src tag 如果tag不存在, 则会创建, 类似mkdir -p 如果src或tag为目录, 则必须以/结尾 src为目录, 复制的时候src自身不会被复制, 只会复制其里面所有子文件 ","date":"2021-08-28","objectID":"/posts/docker/:6:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"小技巧 使用镜像的时候, 不一定要做成容器 可以使用 docker run -it image_name ","date":"2021-08-28","objectID":"/posts/docker/:7:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["tool"],"content":"镜像漏洞排查 docker scan ","date":"2021-08-28","objectID":"/posts/docker/:8:0","tags":["docker"],"title":"docker","uri":"/posts/docker/"},{"categories":["protocol"],"content":"ssh简述 ","date":"2021-08-28","objectID":"/posts/ssh/:0:0","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"功能 ","date":"2021-08-28","objectID":"/posts/ssh/:1:0","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"安装 ","date":"2021-08-28","objectID":"/posts/ssh/:2:0","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"配置 ","date":"2021-08-28","objectID":"/posts/ssh/:3:0","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"超时断开处理 client 超时断开处理 ServerAliveInterval 120 这行内容的含义是，每120s，客户端就向服务端发送一个空的包。让服务端认为客户端在线，因此就不会超时断开。当然，如果服务端设置的超时时间是60s，你这里设置的时间肯定要小于60s。不过服务端设置超时时间为60s的情况非常罕见，而且是出错的时候才会出现这种情况。所以这里设置为120s即可 server 超时断开处理 ","date":"2021-08-28","objectID":"/posts/ssh/:3:1","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"使用","date":"2021-08-28","objectID":"/posts/ssh/:4:0","tags":null,"title":"ssh","uri":"/posts/ssh/"},{"categories":["protocol"],"content":"应用场景 ","date":"2021-08-28","objectID":"/posts/thread/:1:0","tags":null,"title":"多线程总结","uri":"/posts/thread/"},{"categories":["protocol"],"content":"创建 ","date":"2021-08-28","objectID":"/posts/thread/:2:0","tags":null,"title":"多线程总结","uri":"/posts/thread/"},{"categories":["protocol"],"content":"使用","date":"2021-08-28","objectID":"/posts/thread/:3:0","tags":null,"title":"多线程总结","uri":"/posts/thread/"},{"categories":["net"],"content":"socket相关网络编程 ","date":"2021-08-28","objectID":"/posts/socket/:0:0","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["net"],"content":"基本概念 ","date":"2021-08-28","objectID":"/posts/socket/:1:0","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["net"],"content":"socket socket是 [应用层] 与 [传输层, 网络层] 之间的一个抽象层 它的出现是为了简化网络进程通信 linux头文件 usr/include/x86_64-linux-gnu/sys/socket.h 结构体 sockaddr 函数 socket() connect() send() recv() shutdown() socket() bind() lisent() accept() recv() send() shutdown() g++的默认目录中已经包含了sys/的上层目录 usr/include/netinet/in.h 结构体 AF_INET 中的 sockaddr_in AF_INET6 中的 sockaddr_in6 AF_UNIx 中的 sockaddr_un user/include/arpa/inet.h 函数 htons() inet_addr() unistd.h 函数 close() socket函数 socket(domain, socket_type, protol) domain socket_type protol socket()本质是创建了一个进程文件表, 返回的值为指向进程文件表的指针的索引. bind(fd, sockaddr*, len) fd: socket()中的文件表指针的索引 sockaddr: 地址, 端口 len: sockaddr的长度 \u003c1\u003e 比较有意思的是sockaddr根据family的不同, 可以与不同的结构体互转 比如 AF_INET sockaddr_in AF_INET6 sockaddr_in6 AF_UNIX sockaddr_un 这几种结构体都与sockaddr可互转(字节对齐blabla) bind()本质是在补充socket()创建的文件表. socket()时候该文件表很多值都是空的, bind()来补充 因为client 在connect的时候, 系统会自动分配端口,以及绑定本机ip, 所以client的socket一般不必要 使用bind() connet(fd, sockaddr*, len) 连接到其他scokaddr listen(fd, iMaxNum) iMaxNum是队列中的最大数, 并不是指可连接的socket数目 一般只在server开启listen(), 监听指定的端口信息 accept() accept()会造成阻塞. 它会将listen()中的sockaddr进行处理 处理流程是 accept()会创建一个新的fd_connet, 此fd_connet公用server socket() fd的端口和地址 但是fd_connect仅仅是用来传输数据的 recv(fd, msg) send(fd, msg) 至accetp()时候, 一切操作就和在本地上操作一样, 所以这里的recv() 和 send()操作与本机上的文件操作是一样的 close(fd) shutdown(fd, type) linux一切皆是file原则, fd可以关闭 [ip, port]相关函数 点分十进制ip 是以字符串形式存储的 网络字节序 即 32位的二进制 //in_addr struct in_addr { in_addr_t s_addr; }; //in_addr_t typedef unsigned long in_addr_t 函数原型: in_addr_t inet_addr(const char* strptr); 若字符串有效, 则将点分十进制IP字符串转换为网络字节序地址，否则为INADDR_NONE 函数原型：int inet_aton(const char *IP, struct in_addr *addr); 将点分十进制IP地址转换为网络字节序存储在addr中，并且返回该网络字节序表示的无符号整数 函数原型：char *inet_ntoa(struct in_addr in); 将网络字节序的IP地址（也就是结构体in_addr类型变量）转化为点分十进制的IP地址（字符串) socket fd本质 socket本质是维护了fd进程文件表, 如下: 名称 说明 备注 fd 文件描述符, 表的索引 host 1. 域名(DNS /etc/hosts) 2. ip地址 兼容Ipv4 Ipv6是难点 服务 1. 服务名称(/etc/services) 2. 端口 协议 1. 传输层(/etc/protol) 2. 网络层 链路层用到的比较少 网络 1. 网络名称?(DNS /etc/networks) 2. ip地址 谁会使用到这些信息?? 期间用到的函数主要有 尽量使用ipv4, ipv6通用的函数 流程函数 socket() bind() listen() connect() accept()等 字节处理函数 处理大小字节序 htons() htonl() ntohs() ntohl() 处理域名与十分数字 getaddrinfo() getnameinfo() 处理sockaddr结构体的函数 getsockname() 返回local fd getpeername() 返回remote fd ","date":"2021-08-28","objectID":"/posts/socket/:1:1","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["net"],"content":"socket问题 阻塞 影响并发, 多路复用 解决方案: 使用非阻塞模型, 比如select, poll, epoll(linux下特有), IOCP(windows下特有) 多线程 – 不推荐使用 多进程 – 不推荐使用 粘包 解决方案: 限制发送大小 每个消息增加长度标识 ","date":"2021-08-28","objectID":"/posts/socket/:1:2","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["net"],"content":"I/O模型 强烈建议阅读 (链接过期, 直接搜狗搜索epoll, “epoll本质\"即是) 阻塞式 非阻塞 select poll epoll (linux特有) IOCP (windows特有) ","date":"2021-08-28","objectID":"/posts/socket/:1:3","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["net"],"content":"epoll使用 epoll本身为我们处理了什么 之前socket::recv()时, 导致我们的进程阻塞 现在socket::recv()时, 使epoll阻塞; epoll中断时, 告之进程 有了epoll我们还需要处理什么 创建epoll对象 添加检视的fd对象 – op, epoll_event 检测是否有中断, 然后处理 ","date":"2021-08-28","objectID":"/posts/socket/:1:4","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["net"],"content":"socket属性 ","date":"2021-08-28","objectID":"/posts/socket/:2:0","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["net"],"content":"keep live机制 当socket服务端开启keep live之后, 服务器检测到 一定时间内 socket不活动的时候, 就会每隔 固定时间 向该sockt发送 固定次数 的查询. 如果一直没有回应, 服务端则关闭该socket 对应的字段为: tcp_keepalive_time（开启keepalive的闲置时长） tcp_keepalive_intvl（keepalive探测包的发送间隔） tcp_keepalive_probes （如果对方不予应答，探测包的发送次数） ","date":"2021-08-28","objectID":"/posts/socket/:2:1","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["net"],"content":"编程实例 ","date":"2021-08-28","objectID":"/posts/socket/:3:0","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["net"],"content":"原始socket模型, recv()中处理分包粘包 原始socket模型, 考虑到tcp分包 //网络读取 -- 系统检测到网络I/O事件时, 调用该函数 LRESULT CTCPSocketService::OnSocketNotifyRead(WPARAM wParam, LPARAM lParam) { //读取数据 //使用中间量m+cbRecvbuf来当做缓冲区 //使用中间量m_wRecvsize来记录当前缓冲区中已读数据大小 int iRetCode = recv(m_hSocket, (char *)m_cbRecvBuf + m_wRecvSize, sizeof(m_cbRecvBuf) - m_wRecvSize, 0); //读取失败, 则返回SOCKET_ERROR if (iRetCode == SOCKET_ERROR) { ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf)); m_wRecvSize = 0; return 1;//\"网络连接关闭，读取数据失败\"; } //读取成功, 则返回读取到的数据的大小 m_wRecvSize += iRetCode; //在tcp数据中, 增加包的大小, 用来校验是否读取完毕; TCP_Head * pHead = (TCP_Head *)m_cbRecvBuf; WORD wPacketSize = pHead-\u003eTCPInfo.wPacketSize; // //数据包大小校验 if (wPacketSize \u003e (SOCKET_TCP_BUFFER + sizeof(TCP_Head))) { //当发生错误时候, 缓冲区置位 ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf)); m_wRecvSize = 0; return 3;//\"数据包太大\"; } //解析数据 if (m_wRecvSize == wPacketSize) //数据全部接受完毕之后 再解析 { //拷贝数据 BYTE cbDataBuffer[SOCKET_TCP_BUFFER+sizeof(TCP_Head)]; CopyMemory(cbDataBuffer, m_cbRecvBuf, wPacketSize); //置位缓冲信息 -- 缓冲区中只保存一条tcp信息 m_wRecvSize = 0; ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf)); //解密数据 WORD wRealySize = CrevasseBuffer(cbDataBuffer, wPacketSize); if(wRealySize \u003c sizeof(TCP_Head)) return 4; //解析后的数据错误 //获得TCP_Head TCP_Command Command = ((TCP_Head *)cbDataBuffer)-\u003eCommandInfo; //获得实际的数据 void * pDataBuffer = cbDataBuffer + sizeof(TCP_Head); //实际的数据 WORD wRealDataSize = wRealySize - sizeof(TCP_Head); //实际的数据大小 //内核命令 if (Command.wMainCmdID == MDM_KN_COMMAND) { switch (Command.wSubCmdID) { case SUB_KN_DETECT_SOCKET: //网络检测 { //发送数据 SendData(MDM_KN_COMMAND, SUB_KN_DETECT_SOCKET, pDataBuffer, wRealDataSize); break; } } continue; } //处理数据 bool bSuccess = m_QueueServiceEvent.PostTCPSocketReadEvent(m_wServiceID, Command, pDataBuffer, wRealDataSize); if (bSuccess == false) return 5;//\"网络数据包处理失败\"; }; return 0; } ","date":"2021-08-28","objectID":"/posts/socket/:3:1","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["net"],"content":"ipv4 系统文件在/proc/sys/net/ipv4下面 ip_local_port_range # 用户端口范围, [n, m) tcp_timestamp # 针对TIME_WAIT状态的tcp连接; 0关闭,1开启 tcp_tw_recycle # 是否快速回收+ linux内核已删除该字段 tcp_tw_reuse # TIME_WAIT状态的tcp的port是否可以复用;0关闭,1开启 # 需要开启tcp_timestamp; # 这是针对cli的设计,而非svr tcp_rmem # tcp read缓冲区 tcp_wmem # tcp write缓冲区 ip_forward 0禁止ip转发, 1打开; ip_default_ttl 数据报的生存周期(time to live), 即最多经过多少路由器 ip_no_pmtu_disc 关闭路径MTU探测 min_pmtu 最小路径MTU的大小 mtu_expires PMTU信息缓存多长时间 ","date":"2021-08-28","objectID":"/posts/socket/:4:0","tags":["epoll","socket"],"title":"socket","uri":"/posts/socket/"},{"categories":["protocol"],"content":"数据库开发 ","date":"2021-08-28","objectID":"/posts/sql/:0:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"数据库开发 ","date":"2021-08-28","objectID":"/posts/sql/:1:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"win下 详细解释 原生接口 ODBC OLE ADO ","date":"2021-08-28","objectID":"/posts/sql/:1:1","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"linux下 原生接口 ODBC ","date":"2021-08-28","objectID":"/posts/sql/:1:2","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"sqlserver ","date":"2021-08-28","objectID":"/posts/sql/:2:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"优缺点 ","date":"2021-08-28","objectID":"/posts/sql/:2:1","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"Docker安装sqlserver 官方文档 搜索镜像 docker search mssql 安装镜像(这个是官网的) docker pull microsoft/mssql-server-linux 运行镜像, 创建容器 docker run -e “ACCEPT_EULA=Y” -e “SA_PASSWORD=hack@2020” -p 9988:1433 –name mssql -d microsoft/mssql-server-linux 注: 如果不指定映射的端口, 则可能随机使用一个端口 密码必须8位数, 否则会创建失败 -p 第一个参数为主机端口, 第二参数为docker容器端口 进入容器 docker exec -it mssql bash 测试sql server命令 /opt/mssql-tools/bin/sqlcmd -S localhost -U SA -P “passwd” 如果启动失败 docker logs mssql 查看日志信息 ","date":"2021-08-28","objectID":"/posts/sql/:2:2","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"sqlcmd用法 登录 /opt/mssql-tools/bin/sqlcmd -S 127.0.0.1 -U SA -P \"hack@2020\" 执行语句查询 select * from sys.databeses go 一定记得使用go ","date":"2021-08-28","objectID":"/posts/sql/:2:3","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"unicode支持 排序规则会影响字符集 服务器 排序规则 数据库 排序规则 表中的字段 排序规则 排序规则会影响字符集, 比如排序规则为xx_UTF8, 那么其默认的字符集为unicode nchar nvarchar类型会无视排序规则, 直接把改字段变为unicode编码 使用的时候 记得加N, exp: N'排序规则' ","date":"2021-08-28","objectID":"/posts/sql/:2:4","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"client 与 server 最理想的状态 server 是 unicode编码(只要nchar, nvarchar即可) client 是 unicode编码 unixodbc 编译的时候, 添加了 utf8的支持 ./configure --enable-iconv=yes --with-iconv-char-enc=UTF-8 总结: 数据库表字段的编码, 服务器程序运行环境的编码, unixodbc编译时候的字符编码 三者需要统一, 这样写入数据库的时候 才不会乱码 服务器运行环境 locale可以查看 locale -a显示系统支持的字符集 ","date":"2021-08-28","objectID":"/posts/sql/:2:5","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"遇到的奇怪的问题 \u0026\u0026 解决思路 简述: 通过odbc 操作sqlserver, 插入中文错误 现象: 读取sqlserver中文正常 插入sqlserver中文乱码 思路: 查看sqlserver 的编码集(排序规则) 查看qy-server的运行环境 locale 编译unixodbc的时候是否加入了编码的支持 查看odbc的配置文件 odbcinst -j 这次的问题在于 odb的配置文件中 有重名的DSN ","date":"2021-08-28","objectID":"/posts/sql/:2:6","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"mysql 优点: 缺点: 没有存储过程 ","date":"2021-08-28","objectID":"/posts/sql/:3:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"ODBC 安装odbc驱动 建议使用官方源码安装 http://www.unixodbc.org 下载源码之后 ./configure --enable-gui=no --enable-iconv=yes --with-iconv-char-enc=UTF-8 ./configure --enable-gui=no --enable-iconv=yes --with-iconv-char-enc=GB18030 这里需要添加中文支持, 不然会发生数据库读取中文正常, 写入中文时候乱码 安装对应的sql的驱动 这里sql的驱动是 odbc下的sql驱动 以mssql为例. 在microsoft官网下载 查看sql的驱动信息 debin在 /usr/local/etc/odbcinst.ini [ODBC Driver 17 for SQL Server] Description=Microsoft ODBC Driver 17 for SQL Server Driver=/opt/microsoft/msodbcsql17/lib64/libmsodbcsql-17.6.so.1.1 UsageCount=1 说明sql的驱动安装成功 编写DSN debin在 /usr/local/etc/odbc.ini [MssqlDB] Driver = ODBC Driver 17 for SQL Server Server = tcp:172.16.238.10,1433 测试安装 # 查看odbc是否已经安装 odbcinst -j # 查看驱动是否安装 odbcinst.ini odbcinst -q -d # 查看源是否安装 odbc.init odbcinst -q -s 测试连接 上面安装测试完成之后, 测试连接 isql MssqlDB user_name user_passwd -v 如果连接成功 +---------------------------------------+ | Connected! | | | | sql-statement | | help [tablename] | | quit | | | +---------------------------------------+ 连接失败的可能分析 先确认安装测试的3个命令执行正常 确认数据库的密码是否正确 在数据库的容器中查看$SA_PASSWORD, 与本地的密码比较 ","date":"2021-08-28","objectID":"/posts/sql/:4:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["protocol"],"content":"常用数据库语句 sql server 查询sql版本 select @@version go 查询支持的字符集 只有2019版本 才支付utf-8字符集 select * from ::fn_helpcollations() go 查询当前系统的排序规则 SELECT SERVERPROPERTY('Collation') 查询排序规则的字符集 SELECT COLLATIONPROPERTY('Chinese_PRC_Stroke_CI_AI_KS_WS', 'CodePage') 936 简体中文GBK 950 繁体中文BIG5 437 美国/加拿大英语 932 日文 949 韩文 866 俄文 65001 unicode UFT-8 查询所有的库 select * from sys.databeses order by name go 有时候显示的数据太多, 我们可以只显示需要的比如 select name from sys.databeses order by name go 查询当前数据库所有表 方法一 select * from sys.objects where type='U' go –XType='U’:表示所有用户表; –XType='S’:表示所有系统表; 2. 方法二 select * from sys.tables go 查询表中所有的字段 SELECT * FROM SysColumns WHERE id=Object_Id(‘TableName’); SELECT COLLATIONPROPERTY(‘Chinese_PRC_CS_AS_WS’, ‘CodePage’) SELECT COLLATIONPROPERTY(‘Chinese_PRC_90_CI_AS_SC_UTF8’, ‘CodePage’) SELECT COLLATIONPROPERTY(‘Latin1_General_100_CI_AI_SC_UTF8’, ‘CodePage’) SELECT COLLATIONPROPERTY(‘SQL_Latin1_General_CP1_CI_AS’, ‘CodePage’) SELECT COLLATIONPROPERTY(‘Chinese_Simplified_Stroke_Order_100_CI_AI’, ‘CodePage’) ","date":"2021-08-28","objectID":"/posts/sql/:5:0","tags":null,"title":"数据库开发","uri":"/posts/sql/"},{"categories":["net"],"content":"c++网络库 ","date":"2021-08-28","objectID":"/posts/handy/:0:0","tags":["handy"],"title":"handy网络库","uri":"/posts/handy/"},{"categories":null,"content":"协议太多, 不好分类, 真是乱七八糟 ","date":"2021-08-28","objectID":"/posts/protocol/:0:0","tags":null,"title":"乱七八糟的协议合集","uri":"/posts/protocol/"},{"categories":null,"content":"简单协议 ","date":"2021-08-28","objectID":"/posts/protocol/:1:0","tags":null,"title":"乱七八糟的协议合集","uri":"/posts/protocol/"},{"categories":null,"content":"字符编码 写入内存过程: 符号 –\u003e 根据符号表(编码表), 找到符号的value –\u003e 根据实现算法(utf-8等), 计算出在内存中的值 –\u003e 内存值 解析过程: 内存值 –\u003e 根据算法, 计算出符号的value –\u003e 根据符号表, 找到value对应的符号 –\u003e 符号 编码小知识 ios-8859-1 为http上所使用的编码 我在gitlab上面下载的代码虽然最原始是GBK编码（win下）， 下载到mac后 通过file -I 会被识别为iso-8859-1, 就是因为是http协议下载的。 所以转换为mac下可以使用的时候，做法应该是： iconv -f GBK -t UTF-8 file \u003e file2 ASCII \u0026\u0026 Unicode 由来 ASCII码 – 保存英文以及一些特殊控制字符 byte即2^8=256个符号 Unicode – 1. ASCII符号表只能有256个符号, 不够其他国家使用, 比如汉字有10W+ 各个国家符号表(key)对应的value不同, 导致web通信困难(乱码), 为了统一, unicode出现 Unicode \u0026\u0026 utf-8 Unicod只是符号表, 其内部类似于这样 符号 Value 严 4E25 即我们的汉字\"严” 对应的Unicode Value就是 4E25 但Unicode只是规定了符号表的map(key, value), 并没有规定value在内存中的存储形式, 比如little endian中\"严\"是25 4E 第一个字节为25, 第二个字节为4E 而 big endian中则是 4E 25 除了大小字节序问题, 4E 25的如何实现也有非常多的方法 常见的有utf-8 utf-16等等 所以utf-8只是实现Unicode的一种方式 比较重要的一点是, 为了兼容ASCII, ASCII对应的符号value, 在ASCII与utf-8中一致(即英文与控制符号一致) ASCII \u0026\u0026 Unicode转换 这个转换确实纠结了我很久 转换的复杂性在于 字节长度问题 ASCII码的value是一个BYTE, 其value在内存中的实现也是一个byte Unicode的value是二个byte, 其Value在内存中的实现(utf-8)有1-5个byte 字节长度不同, 导致我们需要在char* 和 wchar_t*间转换 编码格式 注: 其实1应该也属于编码格式 因为ASCII 和 Unicode(自身)之间的实现方式差异很大, 在其中转换的时候要非常熟悉各种编码实现的原理 为了解决2个问题, 可以考虑一下2个函数, 虽然是windows下的: MultiByteToWideChar和WideCharToMultiByte ","date":"2021-08-28","objectID":"/posts/protocol/:1:1","tags":null,"title":"乱七八糟的协议合集","uri":"/posts/protocol/"},{"categories":null,"content":"大小字节序 对于多字节, 比如 AE FF Big—Endian 大字节 如果在内存中 0x 0000 0001 AE 0x 0000 0002 FF 即内存中的低位保存的是高字节 则为Big-Endian little-Endian 小字节 如果在内存中 0x 0000 0001 FF 0x 0000 0002 AE 即内存中的低位保存的是低字节 则为little-Endian 网络上的传输为大字节序 所以在host传入到internet时候, 比如socket, 应该将字节序转换 ","date":"2021-08-28","objectID":"/posts/protocol/:1:2","tags":null,"title":"乱七八糟的协议合集","uri":"/posts/protocol/"},{"categories":null,"content":"ip地址详解 主机host的数量 决定了 选择 A类 B类 或者C类地址 hosts的划分, 即子网 决定了 掩码的值 掩码的值 决定了 ip地址的网络id 与 主机id A类的掩码 为 255.0.0.0 B类的掩码 为 255.255.0.0 C类的掩码 为 255.255.255.0 通过A类掩码 计算出 所能承载的host数量n, 按ip从0.0.0.0开始, 数到host数量n, 计算出A类ip地址范围 通过B类掩码 计算出 所能承载的host数量m 按A类广播地址+1开始, 数到m, 计算出B类ip地址范围 通过C类掩码 计算出 所能承载的host数量x 按B类广播地址+1开始, 数到x, 计算出C类ip地址范围 子网的第一个ip地址 和最后一个ip地址有特殊含义 第一个ip地址为 本机地址?????? 最后一个ip地址为广播地址 这2个地址 被设计用来做其他事情, 设计的时候不应该考虑吧进去 ","date":"2021-08-28","objectID":"/posts/protocol/:1:3","tags":null,"title":"乱七八糟的协议合集","uri":"/posts/protocol/"},{"categories":["net"],"content":"基本模型概念: 阻塞, 非阻塞 同步, 异步 ","date":"2021-08-28","objectID":"/posts/module/:0:0","tags":null,"title":"基本模型概念","uri":"/posts/module/"},{"categories":["net"],"content":"阻塞, 非阻塞 阻塞 进程(线程)挂起, 由运行队列转移到等待队列 不消耗内存 非阻塞 进程(线程)不挂起 ","date":"2021-08-28","objectID":"/posts/module/:1:0","tags":null,"title":"基本模型概念","uri":"/posts/module/"},{"categories":["net"],"content":"同步, 异步 同步 等待某事执行完毕, 再继续往下执行 异步 无须等待执行完毕, 可以继续往下执行 与 [阻塞, 非阻塞] 差异 相同点 阻塞 或 同步, 都会使程序陷入 “等待” 状态 差异点 阻塞是指进程(线程)的一种状态 同步, 异步是一种程序设计 ","date":"2021-08-28","objectID":"/posts/module/:2:0","tags":null,"title":"基本模型概念","uri":"/posts/module/"},{"categories":["protocol"],"content":"正则表达式 ","date":"2021-08-28","objectID":"/posts/regex/:0:0","tags":null,"title":"正则表达式","uri":"/posts/regex/"},{"categories":["protocol"],"content":"推荐文章 正则表达式30分钟入门教程 ","date":"2021-08-28","objectID":"/posts/regex/:1:0","tags":null,"title":"正则表达式","uri":"/posts/regex/"},{"categories":["net"],"content":"完成端口 ","date":"2021-08-28","objectID":"/posts/iocp/:0:0","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["net"],"content":"说明 完成端口IOCP是windows下的异步非阻塞模型 IOCP I/O completion port 推荐文档: 完成端口详解 – by 小猪 ","date":"2021-08-28","objectID":"/posts/iocp/:1:0","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["net"],"content":"原理图 ","date":"2021-08-28","objectID":"/posts/iocp/:2:0","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["net"],"content":"TODO 使用模型1 模型1 ","date":"2021-08-28","objectID":"/posts/iocp/:2:1","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["net"],"content":"使用模型2 模型2 ","date":"2021-08-28","objectID":"/posts/iocp/:2:2","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["net"],"content":"具体步骤 建立完成端口 HANDLE m_hCompletionPort = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 0 ); if (m_hCompletionPort == NULL) { std::cout \u003c\u003c \"完成端口 创建失败\" \u003c\u003c std::endl; } 建立Worker线程 //获取系统cpu核心数量 SYSTEM_INFO SystemInfo; GetSystemInfo(\u0026SystemInfo); unsigned int dwThreadCount = SystemInfo.dwNumberOfProcessors; //建立worker线程 unsigned int m_nThreads = dwThreadCount * 2; //江湖传言... HANDLE* m_phWorkerThreads = new HANDLE[m_nThreads]; for (int i = 0; i \u003c m_nThreads; i++) { m_phWorkerThreads[i] = ::CreateThread(0, 0, _WorkerThread, …); } 创建一个用于监听的Socket，绑定到完成端口上，然后开始在指定的端口上监听连接请求 //创建监听线程 //监听连接 hConnectSocket = WSAAccept(m_hListenSocket, (SOCKADDR *) \u0026 SocketAddr, \u0026nBufferSize, NULL, NULL); if (hConnectSocket == INVALID_SOCKET) { std::cout \u003c\u003c \"accept failed\" \u003c\u003c std::endl; return false; } //绑定到完成端口上 -- 注意这里socket对象 CreateIoCompletionPort((HANDLE)hConnectSocket, m_hCompletionPort, NULL, 0); //为该socket投递recv请求 //buf, bytes, flags, overlapped 对象初始化... 如果不初始化, 非常容易导致错误 int iRetCode = WSARecv(hConnectSocket, \u0026buf, 1, \u0026bytes, \u0026flags, (OVERLAPPED*)m_recvOverlapped, NULL); if (iRetCode == SOCKET_ERROR) { if (WSAGetLastError() != WSA_IO_PENDING) { //WSARecv error return false; } // WSARecvFrom() is now operating in the background, // the IOCP port will be signaled when finished... } else { // data is already available, // the IOCP port will be signaled immediately... } woker线程处理 //等待完成端口 if(!GetQueuedCompletionStatus(m_hCompletionPort, \u0026rbytes, (PULONG_PTR) \u0026 pServerSocketItem, (LPOVERLAPPED*)\u0026myOverlapped, INFINITE)) { if(myOverlapped) { CLog::Log(log_debug, \"[socket::server] rs thread run OnEventThreadRun WSARecvFrom() failed\"); } else { CLog::Log(log_debug, \"[socket::server] rs thread run OnEventThreadRun GetQueuedCompletionStatus() failed\"); } return false; } //注意: 处理的时候 注意上锁 switch(myOverlapped-\u003emask) { case recv: { do_recv(); //一般do_recv()中需要投递 WSARecv()请求 break; } case send: { do_send(); break; } } ","date":"2021-08-28","objectID":"/posts/iocp/:3:0","tags":null,"title":"IOCP完成端口","uri":"/posts/iocp/"},{"categories":["protocol"],"content":"linux下静态库 \u0026\u0026 动态库 ","date":"2021-08-28","objectID":"/posts/dll/:0:0","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["protocol"],"content":"差异区别 编译连接静态库时, 会copy一份静态库镜像到目标文件; 编译连接动态库时, 不会copy 程序运行时, 无须再去访问原静态库; 程序运行时, 要能访问到动态库文件 静态库 .a 动态库 .so (shared object) ","date":"2021-08-28","objectID":"/posts/dll/:1:0","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["protocol"],"content":"生成方式 静态库 A.由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表 B.ar命令将很多.o转换成.a，生成文静态库 动态库 A.gcc 加特定参数 编译 fPIC生成动态的.o文件; shared把动态.o文件打包为动态库 gcc -fPIC file1.c -c //这一步生成file1.o gcc -shared file1.o -o libtest.so //把.o文件打包为动态库(.o文件必须是 fPIC生成) ","date":"2021-08-28","objectID":"/posts/dll/:2:0","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["protocol"],"content":"常见问题 运行时候找不到动态库, 处理方式 （1) 最直接最简单的方法就是把so拉到/usr/lib或/lib中去，但这好像有点污染环境吧？ （2）export LD_LIBRARY_PATH=$(pwd) （3）可以在/etc/ld.so.conf文件里加入我们生成的库的目录，然后/sbin/ldconfig 加载动态库 函数原型：void *dlopen(const char *libname,int flag); 参数中的libname一般是库的全路径，这样dlopen会直接装载该文件； 如果只是指定了库名称，在dlopen在查找库的过程中会按照如下路径进行搜索： a.根据环境变量LD_LIBRARY_PATH查找 b.根据/etc/ld.so.cache查找 c.查找依次在/lib和/usr/lib目录查找。 flag参数表示处理未定义函数的方式，可以使用RTLD_LAZY或RTLD_NOW。 RTLD_LAZY表示暂时不去处理未定义函数，先把库装载到内存，等用到没定义的函数再说； RTLD_NOW表示马上检查是否存在未定义的函数，若存在，则dlopen以失败告终。 ","date":"2021-08-28","objectID":"/posts/dll/:3:0","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["protocol"],"content":"动态库再认知 ","date":"2021-08-28","objectID":"/posts/dll/:4:0","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["protocol"],"content":"结论 动态库允许延迟定义, 但是在连接为可执行文件时, 所有动态库的声明必须有定义 ","date":"2021-08-28","objectID":"/posts/dll/:4:1","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["protocol"],"content":"测试 A 依赖libbase.so, B依赖libA A编译的时候, 不指定libbase.so(但是要include base的头文件), 可以编译成功 延迟定义 B -lA 编译, 编译成功, 连接失败, 提示libA没有xxx的定义(在libbase中) 若B -lA -lbase, 则编译连接都成功 连接为执行文件的时候, 所有的声明都必须要有定义 而且这个定义可以是在A中-lbase, 也可以是在B中 -lbase 说明-lbase只是告之符合连接表而已 ","date":"2021-08-28","objectID":"/posts/dll/:4:2","tags":null,"title":"静态库 \u0026\u0026 动态库","uri":"/posts/dll/"},{"categories":["language"],"content":"protobuf使用 ","date":"2021-08-28","objectID":"/posts/protobuf/:0:0","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["language"],"content":"安装 ","date":"2021-08-28","objectID":"/posts/protobuf/:1:0","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["language"],"content":"protobuf cmake生成命令 cmake -G “Visual Studio 16 2019” -A Win32 -DCMAKE_INSTALL_PREFIX=../../../../../install ../.. -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_BUILD_SHARED_LIBS=ON cmake -G “Visual Studio 16 2019” -A Win32 -DCMAKE_INSTALL_PREFIX=../../../../../install ../.. -Dprotobuf_BUILD_TESTS=OFF cmake -G “Visual Studio 16 2019” -A Win32 -DCMAKE_INSTALL_PREFIX=../install ../cmake -Dprotobuf_BUILD_TESTS=OFF -Dprotobuf_BUILD_SHARED_LIBS=ON ","date":"2021-08-28","objectID":"/posts/protobuf/:1:1","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["language"],"content":"使用 打印protobuf结构体数据信息 tagUserinfo ui; cout \u003c\u003c ui.Utf8DebugString() \u003c\u003c endl; ","date":"2021-08-28","objectID":"/posts/protobuf/:2:0","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["language"],"content":"语法 ","date":"2021-08-28","objectID":"/posts/protobuf/:3:0","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["language"],"content":"F\u0026Q 问: 编译的时候提示找不到定义 // 告诉编译器, 运行时候再找定义 // 在xx.pb.h中加入如下宏定义 #define PROTOBUF_USE_DLLS ","date":"2021-08-28","objectID":"/posts/protobuf/:4:0","tags":null,"title":"protobuf","uri":"/posts/protobuf/"},{"categories":["project"],"content":"使用docker搭建web, 包含web服务器(nginx), php7.4.7, lavarel7.12.0, mssql ","date":"2021-08-28","objectID":"/posts/web/:0:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"基本信息 软件 版本 备注 docker desktop 2.0.0.3 sdocker engine 18.09.2 laravel 7.12.0 php php:7.4.7-fpm mssql 2017-CU13 ","date":"2021-08-28","objectID":"/posts/web/:1:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"架构分析 +-------------+ +-------------+ +--------------+ | nginx | -----\u003e | php | -----\u003e | mssql | | | | | | | +-------------+ +-------------+ +--------------+ ^ | | \u003c--- | \\------ +--+-------+ \\---+------------+ | laravel | | composer | | | | | +----------+ +------------+ 通过composer把laravel信息打入到php载体中(这里是docker容器) 在docker_compose中设置转移信息, 使nginx的信息交由php处理 开发环境需要laraverl \u0026\u0026 composer, 生产环境不需要 ","date":"2021-08-28","objectID":"/posts/web/:2:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"下载laravel \u0026\u0026 compose完成laravel的项目依赖 下载laravel laravel对php有版本要求, 所以这里下载的是v7.12.0 https://github.com/laravel/laravel/releases/tag/v7.12.0 完成laravel的依赖安装 这里compose直接安装在了本地mac环境上, 没有装在docker容器中, 效果一样 不知道为什么, 有些文件下载会失败, 建议多敲几次该命令 # 进入laravel项目目录, 并输入 composer install ","date":"2021-08-28","objectID":"/posts/web/:3:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"编写dockerfile \u0026\u0026 docker-compose.yml 参考文档 dockerfile 与 docker-compose.yml应该在laravel项目的根目录下, 因为后续有把laravel打入到php载体的操作 docker-compose.yml version: '2' services: # The Application php-fpm app: # 这里通过app.dockerfile安装 build: context: ./ dockerfile: app.dockerfile working_dir: /var/www volumes: ​ - ./:/var/www environment: ​ - \"DB_PORT=3306\" ​ - \"DB_HOST=database\" # The Web Server web: build: context: ./ dockerfile: web.dockerfile working_dir: /var/www # 这里表示继承app中的设定 volumes_from: ​ - app ports: ​ - 8080:80 # The Database database: image: mysql:5.6 volumes: ​ - dbdata:/var/lib/mysql environment: ​ - \"MYSQL_DATABASE=homestead\" ​ - \"MYSQL_USER=homestead\" ​ - \"MYSQL_PASSWORD=secret\" ​ - \"MYSQL_ROOT_PASSWORD=secret\" ports: ​ - \"33061:3306\" volumes: dbdata: app.dockerfile 这里注释了php的扩展, 但仍然安装laravel成功了, 很奇怪 # php -- 使用特定7.4.7 From php:7.4.7-fpm #RUN apt-get update \u0026\u0026 apt-get install -y libmcrypt-dev \\ # mysql-client libmagickwand-dev --no-install-recommends \\ # \u0026\u0026 docker-php-ext-install mcrypt pdo_mysql web.dockerfile FROM nginx:1.10 ADD vhost.conf /etc/nginx/conf.d/default.confx nginx config配置 server { listen 80; index index.php index.html; root /var/www/public; location / { try_files $uri /index.php?$args; } location ~ \\.php$ { fastcgi_split_path_info ^(.+\\.php)(/.+)$; # 这里表示把信息转移给app即php处理 fastcgi_pass app:9000; fastcgi_index index.php; include fastcgi_params; fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name; fastcgi_param PATH_INFO $fastcgi_path_info; } } ","date":"2021-08-28","objectID":"/posts/web/:4:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"安装docker-compose.yml中信息 # 进入到docker-compose-yml的目录 docker-compose up ","date":"2021-08-28","objectID":"/posts/web/:5:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"laravel打入到php载体中 laravel环境配置 # 进入到laravel的根目录 mv .env.example .env 应用程序密钥和优化 docker-compose exec app php artisan key:generate docker-compose exec app php artisan optimize ","date":"2021-08-28","objectID":"/posts/web/:6:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"测试 访问http://0.0.0.0:8080 应该能看到laravel的标志 ","date":"2021-08-28","objectID":"/posts/web/:7:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"生产环境优化 可以把已经配置好的容器打包为镜像, 并保存为镜像文件. 这样生产环境搭建的时候, 就无需再配置环境(php载体的laravel环境), 同时生成环境可以通过镜像文件加载, 免除了网络问题卡下载的问题. ","date":"2021-08-28","objectID":"/posts/web/:8:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["project"],"content":"遗留问题 docker php容器映射问题 如何把php容器的路径 映射出来 生产环境 docker-compse.yml编写问题 ","date":"2021-08-28","objectID":"/posts/web/:9:0","tags":null,"title":"web框架搭建","uri":"/posts/web/"},{"categories":["language"],"content":"web前端三剑客 ","date":"2021-08-28","objectID":"/posts/html/:0:0","tags":null,"title":"html \u0026\u0026 css \u0026 js","uri":"/posts/html/"},{"categories":["language"],"content":"功能 html – 骨骼 css – 组织 js – 血液 ","date":"2021-08-28","objectID":"/posts/html/:1:0","tags":null,"title":"html \u0026\u0026 css \u0026 js","uri":"/posts/html/"},{"categories":["language"],"content":"Bootstrap bootstrap是web前端框架, 封装了html, css ","date":"2021-08-28","objectID":"/posts/html/:2:0","tags":null,"title":"html \u0026\u0026 css \u0026 js","uri":"/posts/html/"},{"categories":["language"],"content":"AdminLTE AdminlLTE是web前端框架, 封装了Bootstrap和js框架 推荐使用 使用简单 代码简洁干净 ","date":"2021-08-28","objectID":"/posts/html/:3:0","tags":null,"title":"html \u0026\u0026 css \u0026 js","uri":"/posts/html/"},{"categories":["language"],"content":"php \u0026\u0026 php框架 ","date":"2021-08-28","objectID":"/posts/php/:0:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"说明 php是web后端常用的开发语言 有cli和fpm版本, cli版本暂时不知道什么用, fpm版本可以供其他软件使用, 比如apache2, nginx ","date":"2021-08-28","objectID":"/posts/php/:1:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"安装 强烈推荐使用docker安装php docker install php:7.4.7-fpm ","date":"2021-08-28","objectID":"/posts/php/:2:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"laravel 中文翻译文档 官方文档 laravel是流行的php框架 唯一感触就是环境配置真麻烦 laravel与hexo非常类似, 都是通过命令生成一个项目. 不同的是laravel需要把很多信息打入到php所在的载体中(docker容器或者服务器)(在compose install的时候打入). 而hexo则是通过命令, 把源文件生成为静态文件, 静态文件可以被github-page等服务器识别, 供web解析 ","date":"2021-08-28","objectID":"/posts/php/:3:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"laravel安装adminLTE – 通过mix方式安装 laravel7.x 安装adminlte2.4 下载adminLTE到工程中 composer require \"almasaeed2010/adminlte=~2.4\" 编写app.scss \u0026\u0026 app.js \u0026\u0026 webpack.mix.js TODONOW 如何编写 app.scss路径 resources/sass/app.scss app.js路径 resources/js/app.js webpack.mix.js路径 在项目根目录下 npm install \u0026\u0026 npm run dev 项目根目录下执行 npm install 安装js依赖 (根据package.json来安装) npm run dev 把webpack.mix.js(类似工程项目)中内容编译 xxx.blade.php代码中引用修改 css文件引用修改 js文件引用修改 \u003c!DOCTYPE html\u003e \u003chtml\u003e \u003chead\u003e . . . \u003clink rel=\"stylesheet\" href=\"{{ mix('css/app.css') }}\"\u003e \u003c/head\u003e \u003cbody class=\"hold-transition skin-blue sidebar-mini\"\u003e . . . \u003cscript src=\"{{ mix('js/app.js') }}\"\u003e\u003c/script\u003e \u003c/body\u003e \u003c/html\u003e ","date":"2021-08-28","objectID":"/posts/php/:3:1","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"laravel安装adminLTE – 直接放到public目录下面即可 把adminLTE代码(github下载的源码) 放到laravel项目的pulic目录中 修改项目中对adminLTE的引用路径 \u003c!-- Font Awesome --\u003e \u003clink rel=\"stylesheet\" href=\"adminlte/plugins/fontawesome-free/css/all.min.css\"\u003e \u003c!-- icheck bootstrap --\u003e \u003clink rel=\"stylesheet\" href=\"adminlte/plugins/icheck-bootstrap/icheck-bootstrap.min.css\"\u003e \u003c!-- Theme style --\u003e \u003clink rel=\"stylesheet\" href=\"adminlte/dist/css/adminlte.min.css\"\u003e 注意路径的起始位置为laravel项目的public 重启php 与 nginx!!!!! 需要重启才能生效 ","date":"2021-08-28","objectID":"/posts/php/:3:2","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"laravel学习 /project path/app目录 逻辑代码(后端代码) app目录下的Http中放的是我们需要的 逻辑代码 app/Http中 controlers与middleware交互是通过app/Http/kernel.php中的变量map来寻找的 /project path/resources/views 前端代码(表现层代码) 模板文件一般放在layouts目录下面 访问DB数据库 注意事项 修改config/database.php 吐槽 database.php中sql server的demo不正确 配置为 'sqltest' =\u003e [ 'driver' =\u003e 'sqlsrv', //'url' =\u003e env('DATABASE_URL'), 'host' =\u003e '172.22.0.4', 'port' =\u003e '1433', 'database' =\u003e'QPAccountsDB', 'username' =\u003e 'sa', 'password' =\u003e 'hack@2020', 'charset' =\u003e 'utf8', 'prefix' =\u003e '', 'prefix_indexes' =\u003e true, ], 提示 修改了database.php后 需要执行以下命令 提示错误为 php artisan config:cache 成功了会显示 Configuration cache cleared! Configuration cached successfully! 提示错误 There is no existing directory at “%s” and its not buildable 查看storage权限 是否为775 执行以下命令 php artisan route:clear \u0026\u0026 php artisan config:clear \u0026\u0026 php artisan cache:clear 查看php是否开启了对DB的支持(这里以mssql为例) 详见本文档的 支持mssql \u0026\u0026 sqlserver 数据库表的搭建 创建数据库 \u0026\u0026 在app/User.php中选择数据库 protected $connection = 'QPWebDB'; 在选择的数据库中创建table php artisan migrate 测试laravel的注册, 登录功能 访问 0.0.0.0:8080 进行注册,登录测试 web站点访问流程 – 以登录为例 controler 管理类 middleware 中间件 访问web站点 –\u003e 通过/project path/routes/web.php中的路由找到controler – /project path/app/Http/controler/HomeControler.php –\u003e controler转交给middleware处理 – auth 根据/project path/app/Http/kernel中的变量map找到middleware 如果有缓存, 则进入到home界面, 否则进入到login界面, 由controler中控制 –\u003e middleware通过route找到view (route 与 view之间通过XXX.blade.php关联) –\u003e 显示view页面 –\u003e 点击login页面中的登录按钮 –\u003e view找到对应的对应的controlers – /projectt path/app/Http/Controllers/Auth/LoginController.php 根据Auth::routes()找到 TODONOW可以查看在哪里实现的该函数 –\u003e controler转交给middleware处理 – /projcet path/Http/Middleware/RedirectIfAuthenticated.php –\u003e middleware中继续往下传递 总结 laravel 可以分为下面几个模块 route – 路由 controler – 管理器 middleware– 中间件 view – 视图文件(前端显示) guard 其架构为 +-----------+ | controler | ----- +------------+ +----------+ /--\u003e +-----------+ \\---\u003e | middleware| | route | ---- | ^ +------------+ +----------+ -- v | --- \\--- +------------+ ----/ \\\u003e | view | \u003c-/ +------------+ route可以访问 controler 与view controler可以访问view, 或者把复杂逻辑交给middleware midlleware可以访问view view 可以把action提交给controler, 由controler管理 ","date":"2021-08-28","objectID":"/posts/php/:3:3","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"compose compose 解决项目中对php的依赖 mac系统下 ","date":"2021-08-28","objectID":"/posts/php/:4:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"安装 # 安装compose curl -sS https://getcomposer.org/installer | php # 修改为全局可用 sudo mv composer.phar /usr/local/bin/composer # 查看是否安装成功 composer --version ","date":"2021-08-28","objectID":"/posts/php/:4:1","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"更新源 国外的源 被墙了 # 修改为国内的源 composer config -g repo.packagist composer https://packagist.phpcomposer.com ","date":"2021-08-28","objectID":"/posts/php/:4:2","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"pear \u0026\u0026 pecl 实际中并未使用到 :) pecl是php扩展池, pear管理php自身扩展库, 可以在pecl中下载php扩展 ","date":"2021-08-28","objectID":"/posts/php/:5:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"使用 实际使用, 可以参考下面的 web服务器 + php + lavarel + 数据库 TODONOW 待补充连接 ","date":"2021-08-28","objectID":"/posts/php/:6:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"支持mssql \u0026\u0026 sqlserver 下载odbc驱动 apt install unixodbc 下载微软的 dobc for sql 微软官方下载地址 根据服务器和php选择下载 并安装 dpkg -i msodbcsql17_17.5.2.1-1_amd64.deb 下载微软的 php for sql扩展 微软官方下载 并根据操作放入到php的lib目录, 同时修改php.ini 重启php 与 web载体(nginx, apache2) 测试是否安装成功 官方测试代码 ","date":"2021-08-28","objectID":"/posts/php/:7:0","tags":null,"title":"php","uri":"/posts/php/"},{"categories":["language"],"content":"C++ 常见库 ","date":"2021-08-28","objectID":"/posts/stl/:0:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":" 用法: 主要使用std::format() 意义: std::format之前, C++格式化字符要么使用C的format, 要么使用std::iostream C的format非类型安全; std::iostream效率低下 而std::fromat类型安全, 效率也高 备注: C++20中首次加入 template\u003ctypename... Args\u003e std::string fromat(string_view fmt, const Args\u0026... args); //例子1 //format()返回类型或值的字符串表示形式 //{}作为类型安全的占位符 string who{\"lilei\"}; int val{12}; double pi{std::numbers::pi}; format(\"Hello, {}!\\n\", who); //Hello, lilei! format(\"Val: {}\\n\", who); //Val: 12 format(\"v: {}\\n\", who); //v: 3.141592652589793 //例子2 //左对齐\u003c, 右对齐\u003e, 中心对齐^ //{:.\u003c10} 左对齐, 10占位, 不足使用.代替 //.是填充字符 //10表示占位大小 format(\"{:.\u003c10}\", 12); //12........ format(\"{:.\u003e10}\", 12); //........12 format(\"{:.^10}\", 12); //....12.... //例子3 //设置数值的精读 format(\"{:.5}\", std::number::pi); //3.1416 ","date":"2021-08-28","objectID":"/posts/stl/:1:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"* ","date":"2021-08-28","objectID":"/posts/stl/:2:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"下面的都是待整理 ","date":"2021-08-28","objectID":"/posts/stl/:3:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"* ","date":"2021-08-28","objectID":"/posts/stl/:4:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"转换函数 c++11 支持 std::to_string(XX) XX 为int, short, long, longlong数值类型 std::stoi() 同类型的有std::stol(), std::stoll() ","date":"2021-08-28","objectID":"/posts/stl/:5:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"文件操作: fstream类 C++类, 头文件: #include 流程函数 构造fstream对象 fstream file; 打开文件 file.open(file_name, mode) mode: fstream::out 写: 内存-\u003e文件 fstream::in 读: 文件-\u003e内存 当带有此模式的时候, 会默认认为文件存在, 即使文件不存在, 也不会创建文件; 所以对于需要创建文件的场景, 应该不带此mode 读文件 file » string file_val 遇到 空格 \\n \\r \\t时候停止 – 待确认TODONOW file.get(char ch) 每次读取一个字符 getline(file, string \u0026file_val) 读取一行, 遇到\\n停止 file.read(char*buf, length) 在读指针位置读取length长度到buf中, 一般用于二进制文件 写文件 file « file_val 待确认TODONOW file.put(ch) 写入一个字符 file.write(char*buf, length) 在写指针位置写入length长度的buf, 一般用户二进制文件 关闭文件 file.close 读写指针函数 获得读写指针位置 TODONOW 待确认 设置读写指针函数 读: seekg(postion) //postion绝对位置 一般用户文本文件 读: seekg(offset, ios::beg|ios::end::ios::cur) //offset相对位置 一般用户二进制文件, 最好勿在文本文件中使用 写: seekp(positon) 一般用户文本文件 写: seekp(offset, ios::beg|ios::end|ios::cur) 一般用户二进制文件, 最好勿在文本文件中使用 fstream状态函数 if(file) 检验流是否有效 这个需要重点查看下, 什么时候流会失效 已知: file.eof()时候, file则会变为无效 file.is_open() 流是否打开了文件 file.eof() 是否到了文件尾 file.clear() TODONOW 这个也需要再看下 如果file.eof(), 调用clear可以重置标志; 重置标识后, file重新变为有效流 ","date":"2021-08-28","objectID":"/posts/stl/:6:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"字符串: string类 构造 比较 查找 插入 删除 ","date":"2021-08-28","objectID":"/posts/stl/:7:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"curses使用 官方地址: http://www.tldp.org/HOWTO/NCURSES-Programming-HOWTO/windows.html ","date":"2021-08-28","objectID":"/posts/stl/:8:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"* ","date":"2021-08-28","objectID":"/posts/stl/:9:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"FILE FILE是C的文件操作 – C++的为fstream 问: 为什么有了fstream 还需要FILE? 答: 很多系统函数,都是对C的支持, 比如popen()函数等 fopen fread fwrite fclose ","date":"2021-08-28","objectID":"/posts/stl/:10:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"* ","date":"2021-08-28","objectID":"/posts/stl/:11:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"C++ 与 shell的互相调用,传参,获取运行输出 ","date":"2021-08-28","objectID":"/posts/stl/:12:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["language"],"content":"左值, 右值, 左值引用, 右值引用 左值 lvalue(loactor value) – 地址 右值 rvalue(read value) – value lvalue 是“loactor value”的缩写，可意为存储在内存中、有明确存储地址（可寻址）的数 rvalue 译为 \"read value\"，指的是那些可以提供数据值的数据（不一定可以寻址，例如存储于寄存器中的数据） 有名称的, 可以获取到存储地址的 变量或表达式为左值, 其余为右值 引用 \u0026 – 只能操作左值, 称为左值引用 \u0026\u0026 – 只能操作右值,称为右值引用 std::move(arg) – 可以把左值引用转换为右值引用 左值引用, 对于类来说, 会使用copy 构造函数 右值引用, 对于类来说, 会使用移动构造函数 ","date":"2021-08-28","objectID":"/posts/stl/:13:0","tags":null,"title":"C \u0026\u0026 C++ 常见库","uri":"/posts/stl/"},{"categories":["gnu"],"content":"git简易指导, 个人使用心得 ","date":"2021-08-28","objectID":"/posts/git/:0:0","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git使用流程 ","date":"2021-08-28","objectID":"/posts/git/:1:0","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git原理 ","date":"2021-08-28","objectID":"/posts/git/:2:0","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git特性 ","date":"2021-08-28","objectID":"/posts/git/:3:0","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"tag 获取最近的tag git describe --abbrev=0 --tags 查看2个tag(或HEAD, 或branch)之间的距离, A与B之间的距离(或B与A之间的距离) 如果未branch_name, 实际为branch上的HEAD节点 git log --pretty=oneline tagA...tagB 查看从A到B的距离, 而不是从B到A的距离 If you just wanted commits reachable from tagB but not tagA: git log --pretty=oneline tagA..tagB #或者 git log --pretty=oneline ^tagA tagB 简化SHA信息 –abbrev-commit # 一般--pretty=oneline 后面都会加 --abbrev-commit git log --pretty=oneline --abbrev-commit ","date":"2021-08-28","objectID":"/posts/git/:3:1","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git高级特性 ","date":"2021-08-28","objectID":"/posts/git/:4:0","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git hooks 参考文档 ","date":"2021-08-28","objectID":"/posts/git/:4:1","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"删除大文件 寻找大文件 git rev-list --objects --all | grep \"$(git verify-pack -v .git/objects/pack/*.idx | sort -k 3 -n | tail -5 | awk '{print$1}')\" 删除大文件 git filter-branch -f --prune-empty --index-filter 'git rm -rf --cached --ignore-unmatch your-file-name' --tag-name-filter cat -- --all 删除之后 git gc --prune=now ","date":"2021-08-28","objectID":"/posts/git/:4:2","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git lfs 把大文件排除在git仓库之外, git仓库中只有一个指针指向该大文件 ","date":"2021-08-28","objectID":"/posts/git/:5:0","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"安装lfs curl -s https://packagecloud.io/install/repositories/github/git-lfs/script.deb.sh | sudo bash \u0026\u0026 sudo apt-get install git-lfs \u0026\u0026 git lfs install ","date":"2021-08-28","objectID":"/posts/git/:5:1","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"初始化 git lfs install ","date":"2021-08-28","objectID":"/posts/git/:5:2","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"使用 过滤大文件 git lfs track file_path 过滤之后, 会生成.gitattributes 提交到远端 git push – 提交普通文件 git lfs push – 提交lfs文件 下载大文件 git lfs clone url ","date":"2021-08-28","objectID":"/posts/git/:5:3","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"git submodule 参考文档 https://www.cnblogs.com/nicksheng/p/6201711.html 当项目越来越庞大之后，不可避免的要拆分成多个子模块， 我们希望各个子模块有独立的版本管理，并且由专门的人去维护，这时候我们就要用到git的submodule功能 submodule 管理的不是分支, 而是一个commit #递归的方式克隆整个项目 git clone \u003crepository\u003e --recursive #添加子模块 git submodule add --branch branch_name \u003crepository\u003e \u003cpath\u003e #初始化子模块 -- 根据.gitmodule文件clone子模块 git submodule init # 更新子模块 参数remote表示拉取远端最新的而非仓库对应的; init同上 git submodule update --remote --init # 拉取所有子模块 git submodule foreach git pull ","date":"2021-08-28","objectID":"/posts/git/:6:0","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"拉取子模块 方法1 先clone父项目 更新子模块 git submodule update --init 方法2 clone 父项目时 加 –recursive git clone url path --recursive ","date":"2021-08-28","objectID":"/posts/git/:6:1","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"F\u0026Q 问: 命令行下的git status如何显示中文 答：git config --global core.quotepath false 问：在命令行下(gnu-bash)中git不能补全git的命令 1) 首先获得源码 git clone git://git.kernel.org/pub/scm/git/git.git 1) 从源码中拷贝git-completion.bash到用户主目录下. git-completion.bash cp git/contrib/completion/git-completion.bash ~/.git-completion.bash 2) 在 .bashrc 中加入 source ~/.git-completion.bash 3) 在shell下执行 . ~/.bashrc 问: 如何取消对文件的跟踪 答: 分情况而定 1) 对于从没有追踪过的文件, 只需要设置.gitignore即可 2) 对于已经追踪过的文件, 需要git rm --cached (-r) file 然后再加入到.gitignoe中即可 git对大小写不敏感问题, 可以通过下面命令修改 git config core.ignorecase false 修改git默认的编辑器 git config --global core.editor \"'D:/notepad++/notepad++.exe' -multiInst -notabbar -nosession -noPlugin\" ","date":"2021-08-28","objectID":"/posts/git/:7:0","tags":null,"title":"git","uri":"/posts/git/"},{"categories":["gnu"],"content":"gdb学习 ","date":"2021-08-28","objectID":"/posts/gdb/:0:0","tags":null,"title":"gdb","uri":"/posts/gdb/"},{"categories":["gnu"],"content":"附加命令 attach thread_id 附加到进程 gdb ./a.out 使用gdb启动程序 ","date":"2021-08-28","objectID":"/posts/gdb/:1:0","tags":null,"title":"gdb","uri":"/posts/gdb/"},{"categories":["gnu"],"content":"调试命令 bt (backtrace) 查看函数栈 bt full 查看更加详细的信息 f (frame) 查看栈信息 f 0 表示查看栈顶; f n查看第n+1层 down 查看下一栈 up 查看上一栈 i (info) i f 查看当前栈所在层的具体信息 i args 当前函数的参数名及其值 i locals 当前函数中所有局部变量及其值 i catch 异常处理信息 i b 查看断点 i proc mappings 查看程序的内存分布 i reg 查看寄存器 l (list) 查看源码 p (print) 查看变量的值 ","date":"2021-08-28","objectID":"/posts/gdb/:2:0","tags":null,"title":"gdb","uri":"/posts/gdb/"},{"categories":["gnu"],"content":"调试方法 以调试core文件为例 gdb ./a.out core bt 先查看堆栈 如果2没有有用信息, bt full 查看更加详细的堆栈 有时候遇到一些奇怪问题, 可以尝试make clean 整个工程, 再重新生成 ","date":"2021-08-28","objectID":"/posts/gdb/:3:0","tags":null,"title":"gdb","uri":"/posts/gdb/"},{"categories":null,"content":"个人简介 昵称: wcq 地址: 深圳 邮箱: 377133665@qq.com 描述: Emacs重度患者 ","date":"2021-08-28","objectID":"/about/:1:0","tags":null,"title":"About","uri":"/about/"},{"categories":null,"content":"关于本站 梳理自身知识体系 分享 ","date":"2021-08-28","objectID":"/about/:2:0","tags":null,"title":"About","uri":"/about/"},{"categories":["gnu"],"content":"初学autotools ","date":"2021-08-28","objectID":"/posts/autotools/:0:0","tags":null,"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"为什么需要autotools Makefile固然可以帮助make完成它的使命，但要承认的是，编写Makefile确实不是一件轻松的事，尤其对于一个较大的项目而言更是如此。 那么，有没有一种轻松的手段生成Makefile而同时又能让我们享受make的优越性呢？ 本节要讲autotools系列工具正是为此而设的， autotools只需用户输入简单的目标文件、依赖文件、文件目录等就可以轻松地生成Makefile autotools还可以完成系统配置信息的收集，从而可以方便地处理各种移植性的问题。 也正是基于此，现在Linux上的软件开发一般都用autotools来制作Makefile。 ","date":"2021-08-28","objectID":"/posts/autotools/:1:0","tags":null,"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"什么是autotools 综上所述, autotools主要就是利用各个工具的脚本文件以生成最后的Makefile. autotools并不是一个工具, 而是一系列工具合集. 主要有: autoscan aclocal autoconf autoheader automake ","date":"2021-08-28","objectID":"/posts/autotools/:2:0","tags":null,"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"autotools怎么使用 ","date":"2021-08-28","objectID":"/posts/autotools/:3:0","tags":null,"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"autotools安装 mac下包管理习惯使用homebrew 安装autoscan \u0026\u0026 autoconf brew install autoconf 安装aclocal \u0026\u0026 automake \u0026\u0026 autoheader brew install automake ","date":"2021-08-28","objectID":"/posts/autotools/:3:1","tags":null,"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"autotools 在代码当前目录下执行autoscan, 生成configure.scan. configure.scan重命名为configure.ac. 并做以下修改: 初始化AC_INIT 初始化AM_INIT_AUTOMAKE 设定AC_CONFIG_FILES # -*- Autoconf -*- # Process this file with autoconf to produce a configure script. AC_PREREQ([2.69]) #1. _初始化AC_INIT 和 初始化AM_INIT_AUTOMAKE_ AC_INIT(hello,1.0,377133665@qq.com) AM_INIT_AUTOMAKE(hello,1.0) #AC_CONFIG_SCRDIR来侦测源码文件是否存在, 来确定源码目录的有效性 AC_CONFIG_SRCDIR([main.cpp]) AC_CONFIG_HEADERS([config.h]) # Checks for programs. AC_PROG_CXX # Checks for libraries. # Checks for header files. AC_CHECK_HEADERS([stdlib.h unistd.h]) # Checks for typedefs, structures, and compiler characteristics. # Checks for library functions. #2. _生成makefile_ AC_CONFIG_FILES([Makefile]) AC_OUTPUT 执行aclocal命令. 扫描configure.ac文件生成aclocal.m4文件. 该文件主要处理本地宏定义. 它根据已经安装的宏、用户定义宏和 acinclude.m4 文件中的宏将 configure.ac 文件需要的宏集中定义到文件 aclocal.m4 中. 执行autoconf.这个命令将 configure.ac 文件中的宏展开，生成 configure 脚本。 这个过程要用到aclocal.m4中定义的宏. 如果configure.ac宏定义改变了, 需要重新执行aclocal命令 执行autoheader.该命令生成 config.h.in 文件。该命令通常会从 “acconfig.h” 文件中复制用户附加的符号定义。该例子中没有附加的符号定义, 所以不需要创建 “acconfig.h” 文件。 创建Makefile.am文件.Automake工具会根据 configure.in 中的参量把 Makefile.am 转换成 Makefile.in 文件。最终通过Makefile.in生成Makefile文件，所以Makefile.am这个文件非常重要，定义了一些生成Makefile的规则 AUTOMARK_OPTIONS = foreign bin_PROGRAMS = hello hello_SOURCES = main.cpp 执行automake –add-missing命令。该命令生成 Makefile.in 文件。使用选项 “–add-missing” 可以让 Automake 自动添加一些必需的脚本文件。如果发现一些文件不存在，可以通过手工 touch命令创建 执行./configure。大部分linux软件安装都先需要执行./congigure，然后执行make和make install命令。 ./congigure主要把 Makefile.in 变成最终的 Makefile 文件。configure会把一些配置参数配置到Makefile文件里面。 执行make mac系统gcc与g++默认下都是clang的别名. 所以有可能会在此处产生错误. 实际上并没有发现不同 执行make install ","date":"2021-08-28","objectID":"/posts/autotools/:3:2","tags":null,"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"autotools流程图 dot流程图源码 ","date":"2021-08-28","objectID":"/posts/autotools/:3:3","tags":null,"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"推荐文章 autotools使用详解 Makefile中文手册 ","date":"2021-08-28","objectID":"/posts/autotools/:4:0","tags":null,"title":"autotools个人心得","uri":"/posts/autotools/"},{"categories":["gnu"],"content":"gcc ","date":"2021-08-28","objectID":"/posts/gcc/:0:0","tags":null,"title":"gcc","uri":"/posts/gcc/"},{"categories":["gnu"],"content":"安装 ","date":"2021-08-28","objectID":"/posts/gcc/:1:0","tags":null,"title":"gcc","uri":"/posts/gcc/"},{"categories":["gnu"],"content":"配置 ","date":"2021-08-28","objectID":"/posts/gcc/:2:0","tags":null,"title":"gcc","uri":"/posts/gcc/"},{"categories":["gnu"],"content":"gcc 查看搜索路径 g++ | gcc -print-serach-dirs (可通过–help查看) 头文件搜索路径 gcc C_INCLUDE_PATH g++ CPLUS_INCLUDE_PATH ep: export CPLUS_INCLUDE_PATH=/usr/lib/ 扩展1 输出 echo $C_INCLUDE_PATH 调用 $C_INCLUDE_PATH 赋值 export C_INCLUDE_PATH 删除变量 unset C_INCLUDE_PATH C++调用 string strValue(getenv(“C_INCLUDE_PATH”) 库文件搜索路径 LIBRARY_PATH gcc编译时候需要 LD_LIBRARY_PATH 程序运行时候需要 ","date":"2021-08-28","objectID":"/posts/gcc/:2:1","tags":null,"title":"gcc","uri":"/posts/gcc/"},{"categories":["gnu"],"content":"使用","date":"2021-08-28","objectID":"/posts/gcc/:3:0","tags":null,"title":"gcc","uri":"/posts/gcc/"}]