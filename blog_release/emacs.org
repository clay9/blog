#+TITLE: emacs
#+AUTHOR: wcq
#+OPTIONS: ^:nil
#+OPTIONS: \n:t

* Legalese
  :PROPERTIES:
  :COPYING: t
  :END:

  This is a short example of a complete Texinfo file, version 1.0.

  Copyright \copy 2016 Free Software Foundation, Inc.


* 简述
** emacs是什么
  1. emacs最原始,最纯粹的功能: text editor
  2. 也可以作为优秀的 prog editor
  3. 一款不错的文本gtd软件
  4. 简单好用的tramp, shell, graph等软件


  综上, emacs其实更像一个大杂烩, 整合了大多数功能, 使其可以高效的完成任务.
  同时, 因为良好的定制性, emacs可以增强个人使用体验, 但也增加了很多学习成本
  
** 日常使用功能
   | 具体事务                               | 所用emacs功能    |
   |----------------------------------------+------------------|
   | 文本编辑                               |                  |
   |----------------------------------------+------------------|
   | 代码编写, c++, elisp, shell, docker... |                  |
   |----------------------------------------+------------------|
   | gtd                                    | org-agenda-mode  |
   |----------------------------------------+------------------|
   | blog                                   | org-mode && hugo |
   |----------------------------------------+------------------|
   | 其他杂项                               |            |
   |----------------------------------------+------------------|


* emacs-程序
  emacs作为程序最基本的配置.
  比如frame, window, mode-line的显示与控制等. 

* text editor
  文本编辑器是emacs最原始, 最纯粹, 最重要的功能.
  大部分配置都是在处理该项, 使其更符合个人习惯.
  配置繁琐, 但不复杂
  
** show
   text editor最基本的配置, 文本在buffer中显示的样子.
   比如行号, break-line, column indicator等
   
** move-and-kill
   即是text editor, 也是emacs最基础的操作.
   delete, kill, yank, select. 这是emacs中最基础的操作
** hide-show
   hide, show 方便控制sexp的显示隐藏
* completion
  text editor的配置使我们可以高效的编辑文本.
  而completion则可以使emacs更聪明的理解我们的动作.

  emacs有非常多的completion前端和后端, 也有前后端大杂烩.
  没必要都了解, 选一个常用的即可.

  completion流程:
  complete根据我们动作提供候选者 -> 前端显示候选者 -> 我们选择合适的候选
  流程本身非常简单, 涉及到的package也很少, 比较复杂的是候选者的提供, 而这个不需要我们自己去做.
  现在的方案 ([2023-11-01 Wed]):
  consult提供候选, vertico && corfu作为前端显示, marginalia补充候选者信息, orderless提供选择规则.
  embark提供对候选者的操作.

  几个package提供了功能的最小合集, 且与emacs兼容性良好. 因此不再建议使用helm等大杂烩包
  其他一些package也是在提供候选, 比如yasnippet, eglot, copilot等. 只是因为针对的场景不同, 所以暂时不再这里介绍
* prog editor
  emacs可以配置为优秀的IDE. 而且因为定制性强, 配置的IDE更能符合个人的工作流程.
  合格的IDE需要有以下功能: 编辑, 编译, 调试, +发布+

  我常遇到的工作场景是这样的: 工程项目在本地mac, 项目运行编译环境在mac的docker容器中.
  1. 通过lsp server连接编译环境与mac emacs. 这样在mac emacs上编辑, 也会有运行环境的信息, 方便排错与completion
  2. 需要编译的时候, 直接remote compile, 并在mac emacs接收编译错误
  3. 调试使用gdb的远程调试. (TODO: 待处理. 最近很少使用到调试功能了)


  emacs内置了lsp client: eglot. 而且eglot与错误处理flymake搭配良好.
  eglot可以把lsp server中的错误信息给到flymake, completion信息给到corfu(实际是给到emacs completion通用接口), symbol信息给到xerf

  emacs本身有对local compile的支持, 可以使用ppcompile来增加到对remote compile的处理

  实际上, 对于我的工作场景, emacs有不止一种处理手段, 比如可以直接tramp到docker project来处理. 因此选择适合的就行.
  
* org与GTD
** org mode
   org-mode一直被称为神器

   主要有2大功能, 一是自身强大的文本模式, 另一个则是org-agenda

   推荐阅读: [[http://doc.norang.ca/org-mode.html][org心得体会]]

*** 配置
    org作为文本模式配置较少, 更多的配置是为了org-agenda.

    org文本模式下, [[https://github.com/clay9/emacs.d/blob/master/lisp/init-org-mode.el][可以配置一下简单的外观]]. 比如org-bullets.
    org-bullets更改了heading的图标, 更改了折叠的block样式为⤵. 显示更为美观


    org-agenda的配置可以参考[[https://github.com/clay9/emacs.d/blob/master/lisp/init-org-agenda-mode.el][init-org-agenda.el]]和[[https://github.com/clay9/emacs.d/blob/master/lisp/fun/init-org-agenda-fun.el][一系列自定义函数]]
*** 使用
**** 基本语法
***** 语法: time-stamp选择
      添加time-stamp时, 不要在calendar中移动,效率太低
      使用以下2种方式即可:
      1. 使用简约的时间格式
         17-1-1  => 2017-01-01
      2. 使用时间间隔
         now = [2016-12-28 Wed]
         +1d  => 2016-12-29

      具体见(dir) - Org mode - Dates and times - Creating timestamps - The date/time promt

***** 语法: 时间repeate
      org-mode repeate格式
      +   .+   ++区别

      1. "+"
         backlog 可以积压的item
      2. ".+"
         specific date, no backlog 在特定日期完成的item
         ep: call mother
         每周六给mother打电话, 不可积压(或者说现在的操作不会影响之前)
      3. "++"
         specific interval, no backlog 在特定间隔完成的item
         ep: change batteries
         每隔1月更换电池, 不可积压
***** 语法: table计算
      @ 表示行； $表示列
      < 表示第一;   > 表示最后；

      例子:
      @<  第一行
      $>  最后一列
      @<< 第二行(更建议使用 @2)

      对table使用C-c} 可以查看行列值
*** +导出 与 org-info+
    : org-info已弃用, 不再推荐, 建议使用gnu texinfo或者ox-hugo

    org-mode有强大的导出功能, 具体可以参考官方文档.

    这里只是介绍一下org-info.js

    org-info.js 可以输出info-style xhtml, 可以作为org-mode导出html中的一种css样式补充 [[https://orgmode.org/worg/code/org-info-js/][官方文档]]

    可以在info(m), over-view(m), ppt(x)三种模式间切换. (说实话, ppt模式, 真的没啥效果:)

    拥有众多的属性值, 方便导出配置
    - path     org-info.js脚本所在路径, 可以是绝对路径或相对路径, 但必须是目录
      如果没有设置, 则默认从orgmode.org中读取
      publish , export均生效
    - home     整个org-file的根节点,  对应界面上的"HOME"按钮
      1) export 时候, 设置有效
      2) publish的时候, 设置无效
    - up       整个org-file的上层节点,对应界面上的"UP"按钮
      TODONOW 暂时不知道作用, 不设置正常使用, 界面上没有"UP"按钮
    - view     html显示样式
    - toc      整个org-file是否显示content
      publish时候 设置无效
    - ltoc     sub-heading是否显示content
      publish时候 设置无效
    - mouse    鼠标样式
    - buttons


    拥有简单的快捷键, 方便在文档node间移动. n, p, m, x, i, ?

    org-info为org-mode自带, 无须额外安装. 使用的时候, 只需指定属性然后导出即可
    #+BEGIN_EXAMPLE
    #+INFOJS_OPT: home:http://wcq.life
    #+INFOJS_OPT: view:info toc:t ltoc:t mouse:underline buttons:nil
    #+END_EXAMPLE
    org-file中的连接会被自动转换为html中的连接
    #+BEGIN_EXAMPLE 1
    # org-file:
    file:test.org

    在html中被转为
    link:test.html
    #+END_EXAMPLE

*** +MobileOrg+
    : 已弃用, 不再推荐, 建议使用iphone自带软件

    方案流程
    1. PC端配置MobileOrg
       具体见.emacs
    2. 寻找WebDAV server
       现在使用的是坚果云
    3. curl同步PC端到webDAV server
       这一块非常纠结
       起初使用的ssh的scp,发现scp貌似不支持https?
       后来使用了curl, 结果发现curl不支持目录的上传.....
       导致.emacs中mobileorg的配置十分难看, 有机会应该改掉这块!
       方法有2:
       1) 换一种工具取代curl  -- 更倾向于这一种方式
       2) 使用regular expression -- 貌似curl支持的不好


    总览图
    #+BEGIN_EXAMPLE artist
      +-----------+ push          +--------------+
      | PC端      |-------------->| WwbDAV server|
      |           |<--------------|              |
      +-----------+ pull          +--------------+
                                      |      ^
                                      |      |
                                      |      |
                                      v      |
                                  +--------------+
                                  | Mobile       |
                                  |              |
                                  +--------------+
    #+END_EXAMPLE
** GTD
*** 为什么要用GTD
    每天或每周需要处理的事情非常之多, 小到晚上要洗衣服, 大到明天项目交付. 这些事情如果都存储在脑中, 轻则
    焦虑不堪, 重则脑子爆炸. 而且脑中一旦塞满了这类事情, 非常不利于思考. 大脑应该是拿来思考的, 而不是用来存
    储的. 假设一种情形, 大脑只用来思考, 而存储则放在大脑之外, 那么我们就不必因当下之外的事情而焦虑, 能够更
    专一的处理当下的问题. 同时, 如果外在存储能够提醒我们何时该思考何问题, 那么我们也不会因错过了某事而悔恨
    ,比如女友生日. 而这也是GTD的目的所在, 大脑只用来思考, 存储在脑外.
*** GTD是什么
**** 人生5楼
     了解GTD之前, 必须了解人生5楼.

     | 楼数 | 功能     | 说明    | 备注    |
     |------+----------+---------+---------|
     | 5楼  | 人生规划 |         |         |
     |------+----------+---------+---------|
     | 4楼  | 3年目标  |         |         |
     |------+----------+---------+---------|
     | 3楼  | 1年目标  |         |         |
     |------+----------+---------+---------|
     | 2楼  | 职责范围 |         |         |
     |------+----------+---------+---------|
     | 1楼  | 项目     |         | GTD管理 |
     |------+----------+---------+---------|
     | 地面 | 行动清单 | 归属1楼 | GTD管理 |
     |------+----------+---------+---------|

     把人生(或部分人生)比喻成一座大厦, 1楼是我们当下要做的事情, 2楼是我们的职责范围, 3楼是我们1年后的样
     子, 4楼是我们3年后的样子, 5楼是我们人生(10年, 20年或一辈子)的规划.

     _我们的人生是高层决定了低层_. 比如, 如果想成为计算机专家(5楼), 那么3年后要先成为工程师(4楼), 1年后
     要先成为程序员(3楼). 为了要成为程序员, 也许我们需要去报班学习(2楼职责为学习),或者成为程序员助理(2楼职
     责为搬砖). 而1楼则是我们当下要确确实实需要处理的事情, 比如看书, 工作, 与同事交流等, 所有一切能对我们有
     提升的事情.

     _大厦是由低到高建造的_. 千里之行, 始于足下. 1楼的行为直接决定了能否达到后面的楼层.

     大厦最难的地方不在于实现5楼的规划, 而在于制定5楼的规划. 不过这也正是人生的魅力所在吧.
**** GTD是什么
     GTD全名Getting things done, 它只是一种思想, 所能管理的是大厦的1楼.
     它的核心目的: 事物存储在脑外, 大脑用来思考.

     GTD的工作流程(算法)甚至文件(结构)都是可以自定义的. 适合的才是最好的.

     吐槽: 中文译本《Getting things done》满篇废话.
*** GTD怎么实现
    GTD的实现方式非常之多, 有很多软件工具. 最喜欢的还是org-mode(emacs 插件).

** org mode怎么实现GTD
*** 需求分析
    所有的设计都是基于需求的, 应该先有需求, 再去设计.
    当前的需求:
    1. 有哪些task
       - [X] 他们归属于哪个PROJECT
       - [X] 他们的四象限: 紧急&&重要
       - [X] 工作量预估
       - [ ] 关联性 A task可能与B, C相关联
         : TODO 该任务并未完成
    2. 当前正在处理的任务
       尽可能的关注当前, 忽略其他
    3. 当某个task进行时, 快速capture我的想法, 并且自动refile
    4. 看到自己花费的时间
       - [X] 一天,一周都做了什么
       - [X] 某个PROJECT总共花费的时间

*** 思路的设计
    5楼 到 地面视角
    | 楼数 | 功能     | 说明    | 备注    |
    |------+----------+---------+---------|
    | 5楼  | 人生规划 |         |         |
    |------+----------+---------+---------|
    | 4楼  | 3年目标  |         |         |
    |------+----------+---------+---------|
    | 3楼  | 1年目标  |         |         |
    |------+----------+---------+---------|
    | 2楼  | 职责范围 |         |         |
    |------+----------+---------+---------|
    | 1楼  | 项目     |         | GTD管理 |
    |------+----------+---------+---------|
    | 地面 | 行动清单 | 隶属1楼 | GTD管理 |
    |------+----------+---------+---------|
    备注 : GTD管理的其实是 1楼 && 地面的清单

*** 流程的设计
    #+BEGIN_EXAMPLE artist-mode
      -------------------------+------------------------
                               |
                               | capture (easy)
                               |
                               |
                               v
           archive        +---------+
      +-------------------|  inbox  |
      |                   +----+----+
      |                        |
      |                        | refile (auto)
      |                        |
      |                        |
      |       |----------------+--------------------|
      |       |                |                    |
      |       |                v                    v
      |       v           +---------+          +---------+
      |  +---------+      | my/emacs|          | work/qy |
      |  |  task   |      |  * emacs|          |  * ker  |
      |  +----+----+      |  * org  |          |  * frame|
      |       |           |  * ccIDE|          |  * sub  |
      |       |           +---------+          +---------+
      |       |
      |       | archive (auto)
      |       |
      |       v
      |  +---------+
      +->| archive |
         +----+----+
    #+END_EXAMPLE
*** 文件的设计
    区分目录是为了更好的给PROJECT做分类处理, 使后续的统计查看更方便. 比如org-agenda `R统计时间

    gtd_common中保存的是一些通用的, 可能暂时不好归类的PROJECT以及一系列TODO任务.

    而gtd_emacs与gtd_qygame则是已经明确分类的PROJECT.
    比如gtd_emacs/emacs.org明确的是与emacs有关的任务.
    但即使都是emacs相关, 也可分为是emacs自身, org, 还是cc-IDE.
    所以emacs.org中实际包含了上面三个PROJECT: emacs, org, ccIDE

    #+CAPTION: gtd目录
    | 目录       | 说明                 | 备注        |
    |------------+----------------------+-------------|
    | gtd_common | 通用gtd流程文件      | inbox.org   |
    |            |                      | task.org    |
    |            |                      | archive.org |
    |------------+----------------------+-------------|
    | gtd_emacs  | emacs project files  |             |
    |------------+----------------------+-------------|
    | gtd_qygame | qygame project files |             |
    |------------+----------------------+-------------|

    #+CAPTION: gtd_common中的文件
    | 文件名      | 说明     | 备注                       |
    |-------------+----------+----------------------------|
    | inbox.org   | 收集箱   | 不区分时间, 不区分场景     |
    |             |          | 灵光一闪即可扔进去保存     |
    |-------------+----------+----------------------------|
    | task.org    | 任务清单 | 1. priority标签            |
    |             | task     | 2. 四象限约束              |
    |-------------+----------+----------------------------|
    |             | 项目清单 | 1. 凡是steps>1的都属于项目 |
    |             | project  |                            |
    |-------------+----------+----------------------------|
    | archive.org | 参考资料 | 1. 有参考价值的东西        |
    |             |          | 2. 垃圾箱                  |
    |-------------+----------+----------------------------|

    备注:
    1. task 与 project的唯一区别
       task只有one step,  project的steps > 1
    2. 文件都是通过流程来操作的, 不应该手动去干预
    3. 没增加一个工程, 应该增加一个对应的gtd_xx目录

*** TODO的设计
    | 名称     | 功能         | 备注 |
    |----------+--------------+------|
    | TODO     | 等待自己处理 |      |
    |----------+--------------+------|
    | WAITTING | 等待他人完成 |      |
    |----------+--------------+------|
    | DONE     | 完成         |      |
    |----------+--------------+------|
    | CANCEL   | 取消         |      |
    |----------+--------------+------|
    备注:
    1. 针对的对象是下一步行动清单
    2. project中的下一步行动即是最上层的行动;
       task中的下一步行动是依据四象限法则来确定的.
    3. TODO与WAITTING的含义, 表示该行动正在或即将处理

*** TAGS的设计
    四象限使用proirity来区分;
    TAGS为之后快速查找使用

*** PROPERTY的设计
    当前主要使用的字段
    1. P_UUID
       PROEJCT item的标志, 主要影响auto refile
    2. HIDE_WHEN_STUCK
       PROJECT item的属性, 控制了是否在agenda中显示
       有些PROJECT是长久开启的, 不会关闭. 比如emacs
       当这类PROJECT没有task时, 就变成了STUCK项目. 但我们并不希望将这类PROJECT在agenda中显示.
       所以有了HIDE_WHEN_STUCK.

       #+BEGIN_EXAMPLE artist
         +------------+----------------+
         |  not stuck |  stuck project |
         |            |                |
         |            |   +---+        |
         |            |   |   |        |
         |            |   |   +--------+--------> stuck but also hide
         |            |   +---+        |          HIDE_WHEN_STUCK
         |            |                |
         |            |                |
         +------------+----------------+
       #+END_EXAMPLE
*** Effort的设计
    effort是自己对某个task工作量的预估, 与clock-sum-time比对, 可以很好的进行分析.
    为了方便的effort, 这里只在两处设计了提示:
    1. capture的时候, 可以输入effort. 当然为了快速capture, 这里允许输入0跳过
    2. clock-in的时候, 如果item effort还是0, 则会要求进入工作预估
*** clock的设计
    org的clock已经非常好用了. 这里只是做了一点点修改:
    1. 快捷键快速clock-in, clock-out
    2. 如果当前没有clock, 会在agenda界面做个提示

*** capture设计
    经常是在工作的时候, 突然有了某个想法. 这个想法也许值得记录, 但不要打断当前的思路. 所以需要capture
    capture应该是快速的, 但又要明确的(归属要明确, 最好effort要明确)

    为了快速capture, 所以不应该考虑这个想法应该放到哪个file. 统一放到inbox即可.
    为了后面的auto refile, 这个想法或item 应该携带足够的信息, 可以完成auto refile.
    这里的办法是给item一个tag.
    比如 capture了一个item, 再给其增加对应的tag
    : * org应该快速capture :org:
    这样就表明了这是一个与org PROJECT有关的task
*** refile的设计
    refile应该是自动完成的, 不应该手动
    为了自动完成, item已经给了相关信息(tag)
    在gtd_my或gtd_work的PROJECT中, 也应该携带足够的信息去与该tag匹配. 只有匹配成功了, 就可以auto-refile
    这里的办法是给PROJECT item一个Property (P_UUID)来实现
    比如
    #+BEGIN_EXAMPLE org
    * PROJECT org                                                       :org:
      :PROPERTIES:
      :P_UUID:   org
      :END:
    #+END_EXAMPLE
    当capute-item的tag 与 PROJECT-item的P_UUID相匹配的时候, 会自动refile
*** archive的设计
    对于gtd_my, gtd_work中的task, 没必要archive
    对于gtd_common中的task, 应该自动archive

*** Agent的设计
    agent的目的有2个:
    1. 查看各种代办事项
       今天的, 未来的, TODO的, inbox中的
    2. 统计信息
       一是以time为视角的统计, 比如今天或这周做了哪些TODO或PROJECT
       二是以PROJECT为视角的统计. 比如统计emacs PROJECT花费的时间


    查看代办事项, 主要是org-agenda-view, org-next-view, org-inbox-view 查看
    查看统计信息, 主要是org-project-view, org-archive-view 以及在特定PROJECT file中的org-colmun-view查看具体


    快捷键主要是为了方便.比如
    - 空格滚动各种view
    - tab在另一个窗口显示item narrow
    - enter则进入item编辑
    - 常用的功能都会放到C-j中处理 等等

*** 使用流程
    #+BEGIN_EXAMPLE
      |
      | capture with                                         add timestamp &&              add DONE &&
      | template       +---------+ auto refile   +---------+   auto refile     +---------+ auto archive  +---------+
      +--------------->|  inbxo  |-------------->|next step|------------------>|  agenda |-------------->| archive |
      |  C-c c         +---+-----+               +---------+  C-j s,d          +---------+  C-j t        +---------+
      |                    |                                                                                  ^
      |                    |                       add DONE && auto refile                                    |
      |                    +----------------------------------------------------------------------------------+
      |                                                  C-j t
    #+END_EXAMPLE

    1. C-c c   -> inbox
       : info, todo, waiting, project 都会放到inbox
    2. 当打开org-agenda(主动调用"r")或者在org-agenda中按'r' 会自动把inbox中的文件refile到指定位置
    3. 在org-agenda界面操控
       C-j 以及常用的快捷键 t, space, tab, enter等
    4. org-agenda界面的'r'动作, 不仅可以把inbox中的文件reflie, 也可以把task.org中完成的任务archive
    5. 其实还有最后一步, 即把archive中的内容输出到blog中
       : blog具体见 hugo的文档
       : 不建议删除已完成或cancel的task. 后期统计可以使用

  

* 键位设置
** 设计思路
   原则
   1. 尽量保留默认常用快捷键
   2. 不同mode, 尽量使用相似的快捷键

   思路
   1. 通用快捷键(比如search等与mode无关的)或者是所有mode都会使用的统一放到C-s中
   2. mode自身的快捷键, 放到C-j中
   3. 项目相关的快捷键, 放到C-d中
** 快捷键
   具体可以参考[[https://github.com/clay9/emacs.d/blob/master/lisp/init-local-shortkey.el:compilation-mode-map][局部快捷键]] 与 [[https://github.com/clay9/emacs.d/blob/master/lisp/init-global-shortkey.el][全局快捷键]]

   | key | C                  | M    | C-x      | C-c              |
   |-----+--------------------+------+----------+------------------|
   | a   | 行首               | 段首 | buffer首 | =mode= org-agent |
   | b   | 后退               | 后退 | 列表     |                  |
   | c   | =修饰= 通用修饰    |      |          | capure           |
   | d   | 删除               | 删除 | 目录     |                  |
   | e   | 行尾               | 段尾 | buffer尾 |                  |
   | f   | 前进               | 前进 | 打开     |                  |
   | g   | 取消               |      |          |                  |
   | h   | =修饰= 帮助文档    |      |          |                  |
   | i   | 别名 {TAB}         |      |          |                  |
   | j   | =修饰= mode使用    |      |          |                  |
   | k   | kill               |      | 删除     |                  |
   | l   | 移动buffer         |      |          |                  |
   | m   | 别名 {ENTER}       |      |          |                  |
   | n   | 下一行             |      |          |                  |
   | o   | =mode= smartparens |      | 切换     |                  |
   | p   | 上一行             |      |          |                  |
   | q   | =未使用=           |      |          |                  |
   | r   | =未使用=           |      |          |                  |
   | s   | 查找               |      | 保存     |                  |
   | t   | =未使用=           |      |          |                  |
   | u   | =修饰= 命令重复    |      |          |                  |
   | v   | 翻页               | 翻页 |          |                  |
   | w   | 剪切               | 复制 |          | refile           |
   | x   | =修饰= buffer      | 命令 |          |                  |
   | y   | 粘贴               |      |          | archive          |
   | z   | =未使用=           |      |          |                  |
   | DEL |                    | 删除 |          |                  |
   |-----+--------------------+------+----------+------------------|
    

* TODO 待整理 -- tools
** eshell
*** why
    emacs内置的shell.
    - 与elisp无缝结合
    - 语法特性方面比bash shell更有意思
      #+BEGIN_EXAMPLE eshell
      # 可以与tramp无缝结合
      cd /method:user@host#port:path
      #+END_EXAMPLE
*** how
**** eshell script
     官方不建议在eshell中写shell脚本, eshell脚本也是以.sh结尾
***** 变量赋值
      eshell 脚本中使用elisp语法给变量赋值
      #+BEGIN_EXAMPLE eshell
      (setq remote_temp "/ssh:clay@192.168.0.97:~/temp")
      #+END_EXAMPLE
***** 变量使用 $
      基本与shell相同, 具体可以详见官方说明
      #+BEGIN_EXAMPLE eshell
      eshell/rm -r $remote_temp
      #+END_EXAMPLE
*** manual
    1. [[https://linuxtoy.org/archives/emacs-eshell.html][官方文档]]
** elisp
*** how
**** 日常记录
     lisp没有重载一说, 直接覆盖; 因此为了方便出现了 advise 函数
**** elisp 与 bash
***** bash调用elisp
      1. elisp代码写入el文件(eshell script)
      2. bash调用emacs执行el文件
         #+BEGIN_EXAMPLE shell
         # 实际还是emacs 执行的elisp代码
         emacs -u clay --script /Users/clay/.emacs.d/lisp/fun/init-hexo-fun.el
         #+END_EXAMPLE
***** elisp 调用bashe
      #+BEGIN_EXAMPLE elisp
      (setq my-command
      (concat "IFS=: read -ra dirs <<<\"$PATH\"\n"
              "for dir in ${dirs[@]}; do\n"
              " echo got dir \"$dir\"\n"
              "done\n"))
      (shell-command (format "bash -c %s" (shell-quote-argument my-command)))
      #+END_EXAMPLE
*** manual
    1. [[http://smacs.github.io/elisp/02-elisp-basic.html][水木社区Emacs版]]
    2. [[https://www.csdn.net/article/2012-11-22/2812113-The-Nature-Of-Lisp][lisp的本质]]

** tramp
*** what
    全程 transparent remote access multiple protocol

    tramp是用来编辑远端文件的模块, 支持多种协议 ssh, ftp, smb, adb等, 常用method
    - ssh
    - plink
      : putty的ssh client(与linux的ssh client作用一样)
    - su | sudo
      #+BEGIN_EXAMPLE shell
      # 这种并不连接到远程主机, 而是允许使用另一个用户身份打开本地文件
      /su:root:path/
      #+END_EXAMPLE
*** how
**** basic
     #+BEGIN_EXAMPLE shell
     /method:user@host#port:path/to/file

     # example 1
     /ssh:clay@192.1.1.1#22:~

     # example 2 windows下可以使用putty作为ssh的client
     /plink:clay@192.1.1.1:~
     #+END_EXAMPLE

**** set default method
     #+BEGIN_EXAMPLE elisp
     (setq tramp-default-method "plink")

     ; 设置之后的例子
     ; 可以设置linux和windows下默认的method，之后就无需考虑操作系统
     /-:clay@192.1.1.1:~
     #+END_EXAMPLE
**** multiple hop
     #+BEGIN_EXAMPLE shell
     # 在本机上,    通过clay用户登录到host1
     # 再在host1上, 通过admin登录到host2
     /ssh:clay@host1|ssh:admin@host2:/path
     #+END_EXAMPLE
**** su | sudo
     #+BEGIN_EXAMPLE shell
     # 使用sudo打开远程文件
     /-:clay@192.1.1.1|sudo::/path

     # 使用sudo打开本地文件
     # su::默认的是 su:root@localhost. 配置在tramp-default-method-alist
     /su::local-path
     /su:user@localhost:/local-path
     /sudo:root@localhost:/local-path
     #+END_EXAMPLE
**** use with bookmarks
     tramp使用的时候 需要使用到method user host path的组合，一般较长

     我们更希望使用较短的shortcut去远程打开某个file

     这里推荐的方法是bookmark. 理由:
     1. bookmark emacs内置, 而且非常方便
     2. bookmark 的配置信息 可以方便git管理

     使用方法:
     #+BEGIN_EXAMPLE shell
     # 1.远程连接
     C-x f /ssh:clay@192.1.1.1:~

     # 2.添加到bookmark
     C-x C-f BOOK-NAME RET

     # 3.查看bookmark
     C-x C-f

     # 4.管理bookmark配置文件
     ~/.emacs.d/bookmarks

     # 5.管理auth信息文件
     ~/.emacs.d/authinfo
     #+END_EXAMPLE

*** notice
    : TODO 这条notice待验证
    Tramp 打开的远端文件和本地的文件没什么区别，会被记录在 backup、autosave、recentf等中.

    在今后重启 Emacs 时，如果这时无法连接远端机器，Emacs 可能会卡住，
    这是因为 tramp 会对之前打开的文件进行检查

    解决方案:
    让backup等机制绕过tramp即可

** graph
*** why
    图形表达更直观, 形象.
*** what
    artist-mode和graphviz-mode都可以完成绘图的功能.

    但artist-mode提供的功能过于基础, 使用的时候, 最好进行进一步封装.

    [[https://github.com/clay9/emacs.d/blob/master/lisp/init-artist-mode.el][可参考笔者自用的线和矩形]], 提升artist-mode的使用体验


    | mode          | 简述      | 优点                          | 缺点                                      |
    |---------------+-----------+-------------------------------+-------------------------------------------|
    | artist-mode   | ASCII绘图 | 1.ASCII代码表示图形           | 1.功能少                                  |
    |               |           | 2.短小精悍                    | 2.需要手动绘制图形                        |
    |---------------+-----------+-------------------------------+-------------------------------------------|
    | graphviz-mode | dot绘图   | 1.只关注逻辑设计,布局自动生成 | 1.生成的为图片文件, 而非可嵌入的ASCII代码 |
    |               |           |                               | 2.需要学习dot语言                         |
    |---------------+-----------+-------------------------------+-------------------------------------------|

*** how
**** install
     1. emacs install graphviz-dot-mode
     2. system install graphviz
        : brew install graphviz  #mac
**** use
     1. create .dot | .org file
     2. write "The DOT Language"
     3. M-x graphviz-dot-preview
**** dot language
     DOT中使用图(digraph/graph), 节点(node)和边(edge)来描述关系和流程图.
***** graph
      - 有向图 digraph
      - 无向图 graph
      - 子图 subgraph
        : 可以进行和“父图”类似的设置，唯一注意的是子图必须以cluster做为名称的前缀


      在图的开头使用graph []对图进行设置，如：graph [bgcolor="gray"]将图背景色设置为灰色。
      属性设置语句也可以不包含在graph []中而直接使用。
      | 属性名称  | 默认值      | 含义                          | 备注                         |
      |-----------+-------------+-------------------------------+------------------------------|
      | color     | black       | 颜色                          | 支持如red和#FF00000两种形式  |
      |-----------+-------------+-------------------------------+------------------------------|
      | fontcolor | black       | 文本颜色                      |                              |
      |-----------+-------------+-------------------------------+------------------------------|
      | fontsiez  | 14          | 字体大小                      |                              |
      |-----------+-------------+-------------------------------+------------------------------|
      | label     |             | 显示的标签                    | 对于节点, 默认为节点名称     |
      |-----------+-------------+-------------------------------+------------------------------|
      | style     |             | 样式                          |                              |
      |-----------+-------------+-------------------------------+------------------------------|
      |-----------+-------------+-------------------------------+------------------------------|
      | bgcolor   |             | 背景颜色                      |                              |
      |-----------+-------------+-------------------------------+------------------------------|
      | nodesep   | .25         | 节点间隔(英寸)                |                              |
      |-----------+-------------+-------------------------------+------------------------------|
      | rank      |             | 节点顺序                      | same, min, source, max, sink |
      |-----------+-------------+-------------------------------+------------------------------|
      | rankdir   | TB          | 排序方向                      | TB(top->bottom)              |
      |-----------+-------------+-------------------------------+------------------------------|
      | size      |             | 图的大小                      |                              |
      |-----------+-------------+-------------------------------+------------------------------|
      | labelloc  |             | 调整图或子图的 标签的上下位置 |                              |
      |-----------+-------------+-------------------------------+------------------------------|
      | labeljust |             | 调整图或子图的 标签的左右位置 |                              |
      |-----------+-------------+-------------------------------+------------------------------|

***** node
      DOT中，节点可以不用声明直接使用，但如果需要设置节点的属性，则需声明节点并在声明处设
      置属性然后再使用。每个节点首次出现的名称做为该节点的唯一标识

      node []用于设置节点默认属性（对设置位置之后的点有效），在节点后面用[]设置单独一个点的属性。
      | 属性名称  | 默认值          | 含义                 | 备注                        |
      |-----------+-----------------+----------------------+-----------------------------|
      | color     | black           | 颜色                 | 支持如red和#FF00000两种形式 |
      |-----------+-----------------+----------------------+-----------------------------|
      | fontcolor | black           | 文本颜色             |                             |
      |-----------+-----------------+----------------------+-----------------------------|
      | fontsiez  | 14              | 字体大小             |                             |
      |-----------+-----------------+----------------------+-----------------------------|
      | label     |                 | 显示的标签           | 对于节点, 默认为节点名称    |
      |-----------+-----------------+----------------------+-----------------------------|
      | style     |                 | 样式                 |                             |
      |-----------+-----------------+----------------------+-----------------------------|
      |-----------+-----------------+----------------------+-----------------------------|
      | shape     | ellipse         | 节点形状             |                             |
      |-----------+-----------------+----------------------+-----------------------------|
      | fillcolor | lightgrey/black | 节点填充颜色         |                             |
      |-----------+-----------------+----------------------+-----------------------------|
      | fixedsize | false           | 标签是否影响节点大小 |                             |
      |-----------+-----------------+----------------------+-----------------------------|

***** edge
      DOT中有有向边（使用->表示）和无向边（使用--表示）两种，有向边用于有向图，无向边用于无向图，不可混用。

      和节点类似的，用edge []设置边默认属性，在边之后用[]设置单独一条边的属性。
      对于有向边，还可以设置边的起点/终点的位置（用n、e、s、w或它们的组合表示位置）。
      | 属性名称   | 默认值  | 含义                                | 备注                        |
      |------------+---------+-------------------------------------+-----------------------------|
      | color      | black   | 颜色                                | 支持如red和#FF00000两种形式 |
      |------------+---------+-------------------------------------+-----------------------------|
      | fontcolor  | black   | 文本颜色                            |                             |
      |------------+---------+-------------------------------------+-----------------------------|
      | fontsiez   | 14      | 字体大小                            |                             |
      |------------+---------+-------------------------------------+-----------------------------|
      | label      |         | 显示的标签                          | 对于节点, 默认为节点名称    |
      |------------+---------+-------------------------------------+-----------------------------|
      | style      |         | 样式                                |                             |
      |------------+---------+-------------------------------------+-----------------------------|
      |------------+---------+-------------------------------------+-----------------------------|
      | arrowhead  | normal  | 箭头头部形状                        |                             |
      |------------+---------+-------------------------------------+-----------------------------|
      | arrowtail  | normal  | 箭头尾部形状                        |                             |
      |------------+---------+-------------------------------------+-----------------------------|
      | constraint | ture    | 是否根据边来影响节点的排序          |                             |
      |------------+---------+-------------------------------------+-----------------------------|
      | decorate   |         | 设置之后会用一条线来连接edge和label |                             |
      |------------+---------+-------------------------------------+-----------------------------|
      | dir        | forward | 边的设置方向                        | forward,bcak,both,none      |
      |------------+---------+-------------------------------------+-----------------------------|
      | headlabel  |         | 边的头部显示的标签                  |                             |
      |------------+---------+-------------------------------------+-----------------------------|
      | taillabel  |         | 边的尾部显示的标签                  |                             |
      |------------+---------+-------------------------------------+-----------------------------|

** mail
   emacs 流行的email client 有mu4e, notmuch, gnus等
   因为对email不是刚需, 只是轻度使用, 所以这里选了内置对gnus. 理由如下:
   1. emacs 内置
   2. 顺便尝试 newsgroup
   3. 轻度使用email
   : 反而发现gnus非常难配置, 因为可定制的选项太多了, 所以不是很友好

   gnus的缺点:
   1. 配置复杂, 花了24h才看完官方文档. 发现实际用到的也就5% ?
   2. gnus是单线程, 所以如果网络不好, 非常容易把emacs卡住, 比如访问gmail的时候...

*** 基本概念
    gnus概念划分比较友好, server, group, summary, article
    各司其职, 又互相联系, 比较方便, 具体可以参考官方文档

*** 操作流程
    1. 设置server
    2. subscribe group
    3. enter group. show summary
    4. read article

*** group level
    group在gnus中是比较重要的概念. 而group level 可以更好的理解group

    官方描述中:
    subscribe  : 1 - guns-level-subscribed (5)
    unsubscribe: gnus-level-unsubscribed (7)
    zommbie: 8
    killed: 9
    : level越高越不重要

    可以发现killed group有最高的level, 而unsubscribe level 和 subscribe level实际在gnus中处理差异不大.
    所以如果不想看到某个组, 直接kill.
    因为Gnus 不会向server询问zoomibe && killed group的数据

    gnus-group-list-group 显示 unread subscribe
    gnus-group-list-all-group 显示 subscribe && unsubscribe


*** mail
    mail 在gnus中是一种特殊的group. 特殊在哪...TODO 待补充

    mail的设置非常简单, 因为我的需求只是阅读邮件, 所以使用了nnimap作为backend.
    实际上gnus支持的mail back非常的多, 功能也非常强大


**** gmail 或者 国外的mail
     不建议使用国外mail, 网络不好会卡住emacs
     如果一定要用, 推荐使用代理. 代理可以在emacs中配置, 也可以在代理软件中配置.
     比如gmail:
     imap.gmail.com:993
     smtp.gmail.com:587

     : 下面的为个人猜测, 未验证
     如果设置了代理, 还是无法连接, 有可能是短时间连接次数过多, 被gamil服务器暂时拦截了
     等一段时间再试即可

** gdb && gud
   emacs使用gud来绘制gdb的调试信息.
   gud可以认为是gdb的ui client.

   具体可以参考[[https://github.com/clay9/emacs.d/blob/master/lisp/init-gdb.el][github的init-gdb.el]]和[[https://github.com/clay9/emacs.d/blob/master/lisp/fun/init-gdb-fun.el][一些自定义gud函数]]

*** gdb使用
    | 指令       | 简写 | 描述                                                                             |
    |------------+------+----------------------------------------------------------------------------------|
    | attach     |      | 附加到已经运行的程序                                                             |
    |------------+------+----------------------------------------------------------------------------------|
    | run        | r    | 运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步命令           |
    |------------+------+----------------------------------------------------------------------------------|
    | continue   | c    | 继续执行，到下一个断点停止（或运行结束）                                         |
    |------------+------+----------------------------------------------------------------------------------|
    | next       | n    | 单步跟踪程序，当遇到函数调用时，也不进入此函数体                                 |
    |------------+------+----------------------------------------------------------------------------------|
    | step       | s    | 单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的           |
    |------------+------+----------------------------------------------------------------------------------|
    | until      | u    | 当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环             |
    |------------+------+----------------------------------------------------------------------------------|
    | until+行号 |      | 运行至某行，不仅仅用来跳出循环                                                   |
    |------------+------+----------------------------------------------------------------------------------|
    | finish     |      | 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息 |
    |------------+------+----------------------------------------------------------------------------------|
    | quit       | q    | 退出gdb                                                                          |
    |------------+------+----------------------------------------------------------------------------------|
    | up         |      | 上个stack                                                                        |
    |------------+------+----------------------------------------------------------------------------------|
    | down       |      | 下个stack                                                                        |
    |------------+------+----------------------------------------------------------------------------------|
    | watch      |      | 变量监控                                                                         |
    |------------+------+----------------------------------------------------------------------------------|
    | breakpoint | b    | file :line_num   文件:行号                                                       |
    |            |      | <fun_name>       函数名字                                                        |
    |------------+------+----------------------------------------------------------------------------------|

    run相当于重新启动程序, 但是由于某些原因(找不到库? 怀疑是变量不同), 容易导致程序启动失败
    continue 相当于继续执行, 一般在接attach和gdb Server之后使用, 使程序继续执行

*** gud使用
    | buffer名字 | 简述               | 备注                                 |
    |------------+--------------------+--------------------------------------|
    | gud        | gdb命令输入窗口    |                                      |
    |------------+--------------------+--------------------------------------|
    | source     | 调试时自动显示源码 | 不要edit, 否则导致source自动关联失效 |
    |------------+--------------------+--------------------------------------|
    | breakpoint | 断点               | 不会命中的断点显示为pending          |
    |------------+--------------------+--------------------------------------|
    | threads    | 线程               |                                      |
    |------------+--------------------+--------------------------------------|
    | stack      | 堆栈               |                                      |
    |------------+--------------------+--------------------------------------|
    | local      | local变量          |                                      |
    |------------+--------------------+--------------------------------------|
    | register   | 寄存器             |                                      |
    |------------+--------------------+--------------------------------------|
    | assembler  | 显示汇编           |                                      |
    |------------+--------------------+--------------------------------------|
    | memory     | 内存查看           |                                      |
    |------------+--------------------+--------------------------------------|

    为了显示方便,
    breakpoint与threads buffer同在一个frame;
    local与register buffer同在一个frame;
    可以按"TAB"快速切换

***** 例子
      1. emacs: M-x gdb RET
      2. gud: attch <program pid>
      3. 设置breakpoint
         - gud: b
         - source: gud-break; gud-tbreak
         - breakpoint: D 删除断点
      4. 设置watch
         - gud: watch
         - souce: gud-watch
***** 问题
      1. gud中在continue之后, 程序运行; 此时输入, gud并没有反应; 但是在程序运行到断点的时候, 之前的输入全部变成了命令.
         简单来说, gud没有舍弃之前的无效输入, 而是等待机会, 使之生效
      2. gdb continue之后 如何退出
         1) gdb进程中可以使用C-c, 退出attach所关联的进程
         2) emacs-gdb中如何退出 ?? TODONOW
  
** AI Code Assistants
   之前的IDE大多是基于语法的分析, AI代码助手提供了基于自然语义的分析.
   效果非常的惊艳, 能更好的帮助编写文档与程序

   当下流行的(2023-6)主要有:
   Github Copilot, Tabnine, Replit Ghostwriter, Amazon CodeWhisperer 和 Codeium
   具体可以参考 [[https://codeium.com/blog/code-assistant-comparison-copilot-tabnine-ghostwriter-codeium][测评文章]]

   基于以下原因, 暂时使用了github copilot:
   1. 配置方便, emacs使用体验良好

*** github copilot
**** 使用
     github copilot 没有emacs的官方插件, 使用的是第三方package [[https://github.com/zerolfx/copilot.el][copilot]].
     安装与配置均比较简单, 可以参考copilot官方文档
     : 其中需要开通github copilot, 建议在某宝购买github学生包, 便宜又方便, 但是容易被封, 千万不要使用自己的github账号

     #+BEGIN_SRC lisp
       ;;国内可能无法访问github copilot, 可以配置一下代理
       (setq copilot-network-proxy '(:host "127.0.0.1" :port "10887"))
     #+END_SRC
**** 快捷键配置
     copilot 与company-mode的一些快捷键容易冲突, 可以参考[[https://github.com/clay9/emacs.d/blob/master/lisp/init-local-shortkey.el][init-local-shortkey.el]]
**** 使用体验
     1. github copilot自身还好, 但是github学生包账号非常容易被封, 略微影响使用体验


