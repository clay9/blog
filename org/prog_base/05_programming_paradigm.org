#+title: 编程范式
#+date: 2025-11-13 16:26:17
#+hugo_section: docs
#+hugo_bundle: prog_base/05_programming_paradigm
#+export_file_name: index
#+hugo_weight: 5
#+hugo_draft: false
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :bookCollapseSection false
#+hugo_paired_shortcodes: qr %columns %details %hint mermaid %steps tabs tab

Programming paradigm 即编程范型, 编程范式, 程序设计法

#+hugo: more

* 简述
paradigm(范式) 表示一种基本的思维方式;
Programming paradigm(编程范式) 表示对于 =编程= 这件事的思维方式;

: 编程是把 =现实领域问题= 抽象为 =程序模型=

* 常见编程范型

  #+begin_example
  编程范型只是一种思维方式, 不是互斥的.

  比如面向对象编程中虽然把 =现实领域问题= 抽象为对象的交互
  但是对于 =对象的方法(成员函数)= 也许仍是 抽象为一个个过程调用(过程式编程)

  所以不要拘泥于某种编程范型
  #+end_example

  1. 指令性编程
     早期计算机还不智能(抽象层面还不够), 需要更多注意力在硬件层面.
     =现实领域问题= 就是按顺序一步步执行
     =程序模型= 也更多的是对硬件层面的关注, 需要对硬件精细控制
  2. 过程式编程
     =现实领域问题= 被分解为一个个过程(function)
     =程序模型= 就是一个个过程调用(function call)
  3. 基于对象编程
     =现实领域问题= 被分解为对象之间的交互
     =程序模型= 就是对象的管理

     : 此时的对象仅仅是对数据和方法的封装
  4. 面向对象编程
     =现实领域问题= 被分解为对象之间的交互
     =程序模型= 就是对象的管理

     #+begin_example
     与基于对象编程不同的是, 这里的对象含义有所区别
     这里对对象进行了扩展(继承), 丰富了对象的功能
     #+end_example
  5. 函数式编程
     函数式编程将电脑运算视为函数运算，并且避免使用程序状态以及可变对象

     : TODO 还不是很了解
* 函数式编程

  [[https://www.reddit.com/r/learnprogramming/comments/1i83lpq/what_is_functional_programming_actually_useful_for/?tl=zh-hans][函数式编程问答]] (重点看 tzaeru的回答)

  #+begin_example 函数式编程主要思想
    可以从几个不同的角度来看待这个问题，但我会从可读性/便利性的角度出发；
    所以，编程基本上就是获取数据、转换数据，然后输出数据。

    函数式编程允许更明确地关注数据的实际转换，而不是关注计算机需要采取的步骤来转换数据。这种更关注“是什么”而不是“怎么做”的范式被称为声明式编程。

    例如，假设我们有一个用户列表，我们想找到生日在 1 月份的用户（你可能会在 SQL 或类似的东西中真正做到这一点，但这只是一个假设的例子）
    如果你主要用命令式风格来做，它可能看起来像这样：

    const users = getUsers()
    var birthdayUsers = array[]
    for (i = 0; i < users.length(); i++)
    if (users[i].birthdate.month == months.January)
    birthdayUsers.push(users[i])

    与更函数式的风格相比：
    const birthdayUsers = getUsers().filter(user => user.birthdate.month == months.January)
    一旦你习惯了后一种风格，它就更具可读性（因为；你立刻知道这是关于过滤的，并且已经知道 filter 函数是如何工作的），更具可扩展性（你可以立即链接另一个函数调用）并且更不容易出错（在这种情况下，它并不那么明显，但在更大的例子中，命令式风格更容易出现例如差一错误等等）

    函数式编程的一个潜在陷阱是，人们最终会编写出过于聪明的代码，一眼难以理解。尤其是在更纯粹的函数式编程语言中的代码可能有点难以阅读，因为可能更喜欢使用大量的内部匿名函数、非常短且无意义的变量名等等，是的，这是一个真正的问题。
    一些语言明确希望避免开箱即用的对更函数式编程风格的支持。例如 Go。那里的想法是，该语言应该显而易见、简单，并且不提供太多选项来做同样的事情。对于 Go 来说，这是一个不错的选择。就我个人而言，我有点不喜欢它，而且为那些用简单的 map 或 filter 编写更方便的东西编写 C 风格的循环很烦人。

    根据我的经验——虽然我不想把它变成一个权威的争论，但为了说明情况，我想说这种经验非常广泛和多样——最易读、最容易处理的代码库是那些_更喜欢_函数式，但使用命令式概念而不是长函数链或大型嵌套函数结构来将东西分解成更小的步骤的代码库。
    函数式编程的实际要点确实不是例如“函数是一等公民”；它们在某些我们不认为特别函数式的语言中是这样的。它不是嵌套函数。它甚至不是匿名函数。

    实际要点是命令式编程和声明式编程之间的区别。关注“是什么”而不是“怎么做”。函数式编程是一种声明式编程，它侧重于通过组合函数来描述“是什么”。不幸的是，这通常是一个非常抽象的事情，很难理解，有时也很难解释。因此，许多文章和在线评论都侧重于技术细节，例如“对于函数式语言，你需要将函数作为一等公民”（然后我们可以争论“函数作为一等公民”的含义）。
    要点是这样的；我不想向计算机描述我想要一个索引变量，并在索引变量小于 10 时重复这段代码，并在每次迭代时将索引变量递增 1 .. 我不想这样做的原因是因为这与实际数据、与我想对数据进行的实际转换无关。
    相反，我想告诉计算机“我有这些数据，我只想从中获取 ID，按降序排列”。我可以更接近于这样做的一种方法是组合函数；一个从数据中仅选择 ID 并返回一个数组的函数，以及一个然后对数组进行排序以使 ID 排序的函数。
  #+end_example

  #+begin_example 函数式编程优缺点
  函数式编程的核心思想是你的函数没有副作用。这意味着它们不会改变自身之外的任何东西。这意味着，任何时候你用相同的输入调用你的函数，你都会得到完全相同的输出。行为将完全相同。
  例如，如果你的函数接受一个指针/引用到某个其他对象并增加一个计数器，那将是一个副作用。每次你运行你的函数时，都会发生不同的事情。所以那不是一个“纯”函数。如果函数改为将一个计数器对象作为输入，并返回一个新的计数器对象，其值已增加，那么你现在就有一个纯函数。

  这就是核心思想，仅此而已。这个核心思想有很多后果：

  单元测试一个函数更容易，因为你知道如果你给它一个特定的输入，你应该得到一个特定的输出。你不需要先检查数据库或外部对象的状态，就知道输出应该是什么。
  出于同样的原因，更容易推断该函数
  函数可以组合。如果你有一个函数可以向上移动玩家，还有一个函数可以发射玩家的枪，你可以安全地将这些函数组合在一起，进行跳跃-射击，并确信它会按预期工作。将函数传递给函数和部分应用函数都变得更安全，并且效果更好。
  使用此类函数的多线程更容易，因为你可以确保多个线程不会同时触及相同的内存

  也有一些缺点，首先，一个没有任何副作用的程序是无用的。必须在某个时候向屏幕、数据库或网络输出一些内容才能做一些有用的事情。函数式程序员只是试图最小化它并隔离它。
  然后，许多保持最小化副作用的方法都有糟糕的性能后果，所以在某些情况下，你必须在某种程度上放弃它。但即使是像 John Carmack 这样的硬核游戏程序员也写过关于尝试尽可能函数式 *的价值*，这将取决于你正在构建什么。
  #+end_example



  =命令式编程例子=
  向计算机描述我想要一个索引变量，并在索引变量小于10时重复这段代码，并在每次迭代时将索引变量递增1
  : 我不想这样做的原因是因为这与实际数据、与我想对数据进行的实际转换无关

  =函数式编程例子=
  我想告诉计算机“我有这些数据，我只想从中获取ID，按降序排列”。
  我可以更接近于这样做的一种方法是组合函数；一个从数据中仅选择ID并返回一个数组的函数，以及一个然后对数组进行排序以使ID排序的函数。
