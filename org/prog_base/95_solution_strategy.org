#+title: 解题思路
#+date: 2025-11-18 18:05:11
#+hugo_section: docs
#+hugo_bundle: prog_base/95_solution_strategy
#+export_file_name: index
#+hugo_weight: 95
#+hugo_draft: false
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :bookCollapseSection false
#+hugo_paired_shortcodes: qr %columns %details %hint mermaid %steps tabs tab

* 解题思路
  1. 分治 -- 有序数组
  2. 回溯
  3. 动态规划 -- 最优解
  4. 贪心 -- 最优解
  5. *滑动窗口

* TODO 滑动窗口
* 整数反转
  1. 获得反转后的数字
     获得数字低位 - 高位

     123 % 10 = 3;  123 / 10 = 12
     12 % 10 = 2;  12/ 10 = 1
     1 % 10 = 1;  1 / 10 = 0

     可以看出终止条件为 x = 0
  2. 获得符号
     > 0 ? + : -
  3. 范围判断
     拿到反转后的数字之后, 就是判断范围
     3*100 + 2*10 + 1 结果是否在[-2^31, 2^31 -1] 中

  思路有了, 存储的结构体选择.
  使用int[32] 即可. 但会导致浪费空间, 直接使用vector<int>

  -----
  有必要获得符号吗?

  1. 获取反转后的数字的话, 没必要使用符号
     -1 + -2*10 + -3*100 = -321
  2. 判断结果是否在[-2^31, 2^31-1]
     之前如果是正的, 则判断max - 完后的结果是否 > 0

     正 - 正:  > 0,表示在里面

     负 - 负
     -20 - (-1) = -19 还在区间
     -20 - (-30) = 10 不在区间了

  看下来好像还是需要获取正负符号

  -----
  遇到的新问题, vec[i] * dig 之后在int 中放不下了, 导致无法与INT_MAX 或 INT_MIN 进行比较

  -----
  刚刚看了一下, 之前的提交记录, 真的是wtf

  改进:
  1. 没必要使用vecor<int>进行存储, 因为每次循环中, 都可以继续累加


  ps: 看了官方题解, 才明白为什么只要校验 ans*10 > INT_MAX, 而不需要校验ans*10 + dig > INT_MAX

  -----
  总结一下, 为什么思路差异这么大?

  第一眼获取反转数字的方法是 把数字放到某个结构中保存, 然后再进行反转
  最优解的方法是 获取的时候,也进行了反转

  #+begin_example
  放到vecotr<int> {3, 2, 1}
  然后再对vecotr for循环, 反转数字
  #+end_example

  #+begin_example
  123 -> 321
  获取3, 可以放到ans=3
  获取2, ans = ans * 10 + 2
  获取1, ans = ans * 10 + 1
  #+end_example

  仔细想想确实是有蛛丝马迹的, 第一眼思路中获取的时候 /10,  反转的时候*10.
  这明显的关联, 表明两者可以同步进行
* 字符串转换整数

  流程就是题目中描述的:
  1. 舍弃空格
  2. 符号检查
  3. 转换 -- 终止条件
  4. 舍入: 额外条件判断


  程序internal state
  q0 -- 空格判断
  q1 -- 符号检查
  q2 -- 跳过0
  q3 -- 转换


  // 伪代码
  int state = skip_space;
  bool postive = true;
  int ans;
  for (auto & v : s ) {
     // 跳过空格
     if (state = skip_space) {
        if (v = ' ') continue;
        else state = symbol;
     }

     // 判断符号
     if (state = symbol) {
        if (v = '-') postive = false;

        state = skip0;
        if (v = '-' || v = '+') continue;
     }

     // 跳过0
     if (state = skip0) {
         if (v = '0') continue;
         else state = translate
     }

     // 读取数字
     if (state = translate){
         if (v < '0' || v > '9') break;
         else {
            if (ans > INT_MAX/10) return INT_MAX;
            if (ans < INT_MAX/10) return INT_MIN;
            ans *= 10;
            ans += positve ? v - '0' : -(v - '0')
         }
     }
  }

  return ans;

  -----
  这里遇到小坑了, 就是
  if (ans > INT_MAX/10) return INT_MAX;
  if (ans < INT_MAX/10) return INT_MIN;

  习惯性的被上次的题目整数反转影响了, 实际判断应该是
  ans * 10 + dig > INT_MAX ->
  ans > (INT_MAX - dig) / 10

  ans * 10 + dig < INT_MIN ->
  ans < (INT_MIN - dig) / 10

  考虑到越界问题, 完整的判断是
  if (postive && ans > (INT_MAX - dig) / 10) return INT_MAX;
  if (!postive && ans < (INT_MIN - dig) / 10) return INT_MIN;


  -----
  总结:

  图灵机的internal state 非常适合处理这种多状态的问题, 而且简单易懂


  以前总以为解体思路就是
  1. 分治
  2. 回溯
  3. DP
  4. 贪心
  5. 滑动窗口
  6. 双指针

  但现在才发现并不是所有的题目都需要, 很多问题, 其实就是简单的图灵机问题, 使用基本的internal state 就可以了

  ps: turing 和 λ验算的blog 要快点补充完整
* 盛最多水的容器
  int[] 找出索引x,y. 使得 (y - x) * min(int[x], int[y]) 最大

  暴力算法
  for(int x = 1; x < size; ++x)
    for (int y = 0; y < x; ++y)
       result = (y - x) * min(int[y], int[x]);
       if (result > max) max = result;


  -----
  暴力算法时间复杂度为O(n^2). 需要简化

  读取第一个数字,
  读取第二个数字,
  继续读, 会有三种情况
  1. 舍弃第一个数字
  2. 舍弃第二个数字
  3. 不舍弃, 继续读


  例子: 1, 1, 6, 6, 1, 1, 1, 1, 1
  left 1
  right 1

  read 6: ans = 2, left 1, right 6
  read 6: ans = 6, left 6, right 6
  read 1: ans = 2
  read 1: ans= 3
  read 1: ans = 4
  read 1: ans = 5
  read 1: ans = 6
  read 1: ans = 7, left 6, right 1


  但是上面的方法好像是错误的, 因为没有考虑之前的. 这里还应该保留之前的数字num
  map[length] = first_occur_index

  找到map 中不小于当前int[i] 的数值. 同时参与比较.
  但是这样 只是把对int[] 的遍历, 变更为了对map 的遍历, 没有实际改变. 所以算法不应该是这样的

  感觉还是滑动窗口相关, 甚至可能是典型应用

  -----

  看到题目中的提示2, 使用双指针

    int ans = 0;
    int l = 0, r = height.size() - 1;

    while(l != r){
      int value = (r - l) * std::min(height[r], height[l]);
      if (value > ans) ans = value;

      if(height[l] < height[r]) ++l;
      else --r;
    }

    return ans;


  双指针疑问, 如果height[l] == height[r], 这里使用的把--r. 即把右指针往左靠拢,
  是否与把左指针往右靠拢, 效果是一样的呢?

  例子: 数组10 个数字(0, 9), 且int[0] == int[9]

  会不会出现最大值在(2, 9) ?
  不会
  因为int[0] = int[9]. 即使int[2] > int[9], 但min[int2, int9] 还是int[9]


  会不会出现在(2, 7) ?
  如果出现在(2, 7), 说明min(2, 7) > int[0]/int[9]. 说明后续指针变化的时候, l 也会改变, 所以不影响

  综上, 当l, r指针的数据一致的时候, 先改变l 或 r 都不会影响结果


  -----
  总结:

  1. 为什么可以使用双指针, 符合了什么条件?

     因为可以舍弃最短的木板, 继续往前测试. 说白了就是有++l 或 --r 的判断条件.
     可以控制什么时候++l, 什么时候--r.

  2. 为什么第一眼很难联想到双指针?

     思维习惯问题, 碰到题目的时候, 第一眼的想法是从左往右去思考.
     所以会想l=0, r=1. 然后继续往下去改变l 或 r. 也就变成了暴力破解

     但仔细想想, 这个暴力破解(双循环) 还是和双指针有一定联系的, 比如都是在指定左右边界.
     不同在于暴力破解中 r 只是简单递增, l 也只是符合 l < r 的判断条件;
     而双指针r, l 的判断条件, 则于int[l], int[r] 有关联, 不仅仅是 l < r

  3. 双指针可以把for for 循环简化为单层for 循环;
     有点像hash 算法, 把搜索中的for for 循环, 变为了单层for 循环

     hash 算法是处理搜索的,
     双指针 ?
