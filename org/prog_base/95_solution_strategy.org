#+title: 解题思路
#+date: 2025-11-18 18:05:11
#+hugo_section: docs
#+hugo_bundle: prog_base/95_solution_strategy
#+export_file_name: index
#+hugo_weight: 95
#+hugo_draft: false
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :bookCollapseSection false
#+hugo_paired_shortcodes: qr %columns %details %hint mermaid %steps tabs tab

* 解题思路
  1. 分治 -- 有序数组
  2. 回溯
  3. 动态规划 -- 最优解
  4. 贪心 -- 最优解
  5. *滑动窗口

* TODO 滑动窗口
* 整数反转
  1. 获得反转后的数字
     获得数字低位 - 高位

     123 % 10 = 3;  123 / 10 = 12
     12 % 10 = 2;  12/ 10 = 1
     1 % 10 = 1;  1 / 10 = 0

     可以看出终止条件为 x = 0
  2. 获得符号
     > 0 ? + : -
  3. 范围判断
     拿到反转后的数字之后, 就是判断范围
     3*100 + 2*10 + 1 结果是否在[-2^31, 2^31 -1] 中

  思路有了, 存储的结构体选择.
  使用int[32] 即可. 但会导致浪费空间, 直接使用vector<int>

  -----
  有必要获得符号吗?

  1. 获取反转后的数字的话, 没必要使用符号
     -1 + -2*10 + -3*100 = -321
  2. 判断结果是否在[-2^31, 2^31-1]
     之前如果是正的, 则判断max - 完后的结果是否 > 0

     正 - 正:  > 0,表示在里面

     负 - 负
     -20 - (-1) = -19 还在区间
     -20 - (-30) = 10 不在区间了

  看下来好像还是需要获取正负符号

  -----
  遇到的新问题, vec[i] * dig 之后在int 中放不下了, 导致无法与INT_MAX 或 INT_MIN 进行比较

  -----
  刚刚看了一下, 之前的提交记录, 真的是wtf

  改进:
  1. 没必要使用vecor<int>进行存储, 因为每次循环中, 都可以继续累加


  ps: 看了官方题解, 才明白为什么只要校验 ans*10 > INT_MAX, 而不需要校验ans*10 + dig > INT_MAX

  -----
  总结一下, 为什么思路差异这么大?

  第一眼获取反转数字的方法是 把数字放到某个结构中保存, 然后再进行反转
  最优解的方法是 获取的时候,也进行了反转

  #+begin_example
  放到vecotr<int> {3, 2, 1}
  然后再对vecotr for循环, 反转数字
  #+end_example

  #+begin_example
  123 -> 321
  获取3, 可以放到ans=3
  获取2, ans = ans * 10 + 2
  获取1, ans = ans * 10 + 1
  #+end_example

  仔细想想确实是有蛛丝马迹的, 第一眼思路中获取的时候 /10,  反转的时候*10.
  这明显的关联, 表明两者可以同步进行
