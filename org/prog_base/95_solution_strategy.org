#+title: 解题思路
#+date: 2025-11-18 18:05:11
#+hugo_section: docs
#+hugo_bundle: prog_base/95_solution_strategy
#+export_file_name: index
#+hugo_weight: 95
#+hugo_draft: false
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :bookCollapseSection false
#+hugo_paired_shortcodes: qr %columns %details %hint mermaid %steps tabs tab

* 解题思路
  1. 分治 -- 有序数组
  2. 回溯
  3. 动态规划 -- 最优解
  4. 贪心 -- 最优解
  5. *滑动窗口

* TODO 滑动窗口
* 整数反转
  1. 获得反转后的数字
     获得数字低位 - 高位

     123 % 10 = 3;  123 / 10 = 12
     12 % 10 = 2;  12/ 10 = 1
     1 % 10 = 1;  1 / 10 = 0

     可以看出终止条件为 x = 0
  2. 获得符号
     > 0 ? + : -
  3. 范围判断
     拿到反转后的数字之后, 就是判断范围
     3*100 + 2*10 + 1 结果是否在[-2^31, 2^31 -1] 中

  思路有了, 存储的结构体选择.
  使用int[32] 即可. 但会导致浪费空间, 直接使用vector<int>

  -----
  有必要获得符号吗?

  1. 获取反转后的数字的话, 没必要使用符号
     -1 + -2*10 + -3*100 = -321
  2. 判断结果是否在[-2^31, 2^31-1]
     之前如果是正的, 则判断max - 完后的结果是否 > 0

     正 - 正:  > 0,表示在里面

     负 - 负
     -20 - (-1) = -19 还在区间
     -20 - (-30) = 10 不在区间了

  看下来好像还是需要获取正负符号

  -----
  遇到的新问题, vec[i] * dig 之后在int 中放不下了, 导致无法与INT_MAX 或 INT_MIN 进行比较

  -----
  刚刚看了一下, 之前的提交记录, 真的是wtf

  改进:
  1. 没必要使用vecor<int>进行存储, 因为每次循环中, 都可以继续累加


  ps: 看了官方题解, 才明白为什么只要校验 ans*10 > INT_MAX, 而不需要校验ans*10 + dig > INT_MAX

  -----
  总结一下, 为什么思路差异这么大?

  第一眼获取反转数字的方法是 把数字放到某个结构中保存, 然后再进行反转
  最优解的方法是 获取的时候,也进行了反转

  #+begin_example
  放到vecotr<int> {3, 2, 1}
  然后再对vecotr for循环, 反转数字
  #+end_example

  #+begin_example
  123 -> 321
  获取3, 可以放到ans=3
  获取2, ans = ans * 10 + 2
  获取1, ans = ans * 10 + 1
  #+end_example

  仔细想想确实是有蛛丝马迹的, 第一眼思路中获取的时候 /10,  反转的时候*10.
  这明显的关联, 表明两者可以同步进行
* 字符串转换整数

  流程就是题目中描述的:
  1. 舍弃空格
  2. 符号检查
  3. 转换 -- 终止条件
  4. 舍入: 额外条件判断


  程序internal state
  q0 -- 空格判断
  q1 -- 符号检查
  q2 -- 跳过0
  q3 -- 转换


  // 伪代码
  int state = skip_space;
  bool postive = true;
  int ans;
  for (auto & v : s ) {
     // 跳过空格
     if (state = skip_space) {
        if (v = ' ') continue;
        else state = symbol;
     }

     // 判断符号
     if (state = symbol) {
        if (v = '-') postive = false;

        state = skip0;
        if (v = '-' || v = '+') continue;
     }

     // 跳过0
     if (state = skip0) {
         if (v = '0') continue;
         else state = translate
     }

     // 读取数字
     if (state = translate){
         if (v < '0' || v > '9') break;
         else {
            if (ans > INT_MAX/10) return INT_MAX;
            if (ans < INT_MAX/10) return INT_MIN;
            ans *= 10;
            ans += positve ? v - '0' : -(v - '0')
         }
     }
  }

  return ans;

  -----
  这里遇到小坑了, 就是
  if (ans > INT_MAX/10) return INT_MAX;
  if (ans < INT_MAX/10) return INT_MIN;

  习惯性的被上次的题目整数反转影响了, 实际判断应该是
  ans * 10 + dig > INT_MAX ->
  ans > (INT_MAX - dig) / 10

  ans * 10 + dig < INT_MIN ->
  ans < (INT_MIN - dig) / 10

  考虑到越界问题, 完整的判断是
  if (postive && ans > (INT_MAX - dig) / 10) return INT_MAX;
  if (!postive && ans < (INT_MIN - dig) / 10) return INT_MIN;


  -----
  总结:

  图灵机的internal state 非常适合处理这种多状态的问题, 而且简单易懂


  以前总以为解体思路就是
  1. 分治
  2. 回溯
  3. DP
  4. 贪心
  5. 滑动窗口
  6. 双指针

  但现在才发现并不是所有的题目都需要, 很多问题, 其实就是简单的图灵机问题, 使用基本的internal state 就可以了

  ps: turing 和 λ验算的blog 要快点补充完整
