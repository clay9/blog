#+title: 数据结构与算法分析
#+date: 2025-11-13 16:27:01
#+hugo_section: docs
#+hugo_bundle: prog_base/99_algorithm
#+export_file_name: index
#+hugo_weight: 99
#+hugo_draft: false
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :bookCollapseSection false
#+hugo_paired_shortcodes: qr %columns %details %hint mermaid %steps tabs tab

* 概述|总结
** 什么是
   数据结构分为
   - 物理结构
     即在内存中的结构. 有顺序存储(内存连续) 和 链式存储(内存可不连续)
   - 逻辑结构
     线性关系, 一对一, 一对多, 多对多
** 逻辑结构
*** 线性关系
    数组, 链表
    栈, 队列
*** 一对一
    hash table
*** 一对多
    - tree 树
    - binary tree 二叉树
    - search binary tree 搜索二叉树
    - blance binary tree 平衡二叉树
    - complet binary tree 完全二叉树
    - 堆

    | name                | 特征                                         | 备注 |
    |---------------------+----------------------------------------------+------|
    | tree                |                                              |      |
    |---------------------+----------------------------------------------+------|
    | binary tree         | 1.任意节点 叶度 <=2                          |      |
    |---------------------+----------------------------------------------+------|
    | search bianry tree  | 1.binary tree                                |      |
    |                     | 2.任意节点 left-child, root, right-child有序 |      |
    |---------------------+----------------------------------------------+------|
    | blanced binary tree | 1.search binary tree                         |      |
    |                     | 2.任意节点的 <左树高度-右树高度>  <=1        |      |
    |---------------------+----------------------------------------------+------|
    | complet binary tree | 1.search tree                                |      |
    |                     | 2.节点依次从左到右                           |      |
    |---------------------+----------------------------------------------+------|
*** 多对多
    graph 图
* 数据结构
  | type        | type         | Access           | 查找             | 增加,删除        | 适用场景                   | c++类型            |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
  | array       | 1.数组       | O(1)             | O(n)             | O(n)             | 数据访问                   | std::array         |
  |             | 2.动态数组   |                  |                  |                  |                            | std::vector        |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
  | linked-list | 1.单链表     | O(n)             | O(n)             | O(1)             | 数据增删, 查找较少         | std::list          |
  |             | 2.双链表     |                  |                  |                  |                            |                    |
  |             | 3.循环链表   |                  |                  |                  |                            |                    |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
  | skip list   |              | O(n),Θ(logN)    | O(n),Θ(logN)    | O(n),Θ(logN)    | 介于array与linked list中间 |                    |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
  | stack       |              | O(n)             | O(n)             | O(1)             | LIFO 数据增删              | std::stack         |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
  | queue       | 1.队列       | O(n)             | O(n)             | O(1)             | FIFO 数据增删              | std::queue         |
  |             | 2.双端队列   |                  |                  |                  |                            | std::deque         |
  |             | 3.优先队列   |                  |                  |                  |                            |                    |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
  | hash        |              | N/A              | O(1)             | O(1)             | 数据查找                   | std::unordered_map |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
  | tree        | 1.二叉查找树 | O(n),Θ(logN)    | O(n),Θ(logN)    | O(n),Θ(logN)    |                            | std::set           |
  |             |              |                  |                  |                  |                            | std::map           |
  |             | 2.平衡二叉树 |                  |                  |                  |                            |                    |
  |             |              |                  |                  |                  |                            |                    |
  |             | 3.红黑树     | O(logN),Θ(logN) | O(logN),Θ(logN) | O(logN),Θ(logN) |                            |                    |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
  | heap        | 1.最大堆     |                  |                  |                  |                            |                    |
  |             | 2.最小堆     |                  |                  |                  |                            |                    |
  |             |              |                  |                  |                  |                            |                    |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
  | graph       |              |                  |                  |                  |                            |                    |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
  | trie        |              |                  |                  |                  |                            |                    |
  |-------------+--------------+------------------+------------------+------------------+----------------------------+--------------------|
* 搜索算法
  线性查找: 遍历. 线性查找可以进化为哈希查找来降低时间复杂度
  二分查找: 数组, 有序 log(n)
  哈希查找: 借助额外的hash table

* 排序算法
  | name           | 定义                                              | T(n) θ              | T(n) O   | S(n) | 稳定性 | 适用场景 | 适用结构 | 备注                                               |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | bubble sort    | 循环n次                                           | θ(n^2)              | O(n^2)   | O(1) | yes    | 数据较少 | 1.数组   | 循环结束判定:                                      |
  |                | 每第i次循环, 集合[0-i]中相邻元素按序交换          |                      |          |      |        | 基本有序 | 2.链表   | 1.循环了size-1次                                   |
  |                | 每第i次循环, 可确定n-i位置上的元素                |                      |          |      |        |          |          | 2.上次循环中没有发生元素交换                       |
  |                |                                                   |                      |          |      |        |          |          | 就表示是已序的了                                   |
  |                |                                                   |                      |          |      |        |          |          |                                                    |
  |                |                                                   |                      |          |      |        |          |          | 排序只用到指针 && flag, 原地排序,                  |
  |                |                                                   |                      |          |      |        |          |          | 因此空间复杂度为O(1)                               |
  |                |                                                   |                      |          |      |        |          |          |                                                    |
  |                |                                                   |                      |          |      |        |          |          | 元素交换O(n^2)                                     |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | selection sort | 循环n次                                           | θ(n^2)              | O(n^2)   | O(1) | no     | 数据较少 | 1.数组   | 元素交换O(n)                                       |
  |                | 每第i次循环, 选择集合[i, n]中最小的元素,放在i位置 |                      |          |      |        |          | 2.链表   |                                                    |
  |                | 每第i次循环, 可确定i位置上的元素                  |                      |          |      |        |          |          |                                                    |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | insertion sort | 循环n次                                           | θ(n^2)              | O(n^2)   | O(1) | yes    |          |          | 元素交换O(n^2)                                     |
  |                | 每第i次循环, 将i位置的元素放到集合[0-i]的有序位置 |                      |          |      |        |          |          |                                                    |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | quick sort     |                                                   |                      |          |      |        |          |          |                                                    |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | shell sort     | 循环gap()拆分数组, 对拆分后的数组们进行插入排序   | Hibbard:   θ(n^3/2) | O(n^5/4) | O(1) | no     |          |          | 拆分后的数组们进行排序时没必要sort完A后再sort B, C |
  |                |                                                   | Sedgewick: θ(n^7/6) | O(n^4/3) |      |        |          |          | 可以A, B, C的sort在同一个for循环进行               |
  |                |                                                   |                      |          |      |        |          |          |                                                    |
  |                |                                                   |                      |          |      |        |          |          | T(n)与gap的选择有关                                |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | merge sort     | 分而治之                                          | θ(nlogN)            | O(nlogN) | O(n) | yes    |          |          | 递归 与 非递归两种实现                             |
  |                | 分: 分为有序集合A, B                              |                      |          |      |        |          |          |                                                    |
  |                | 治: 有序集合A, B => C                             |                      |          |      |        |          |          |                                                    |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | heap sort      | 循环n次                                           | θ(nlogN)            | O(nlogN) | O(1) | no     |          |          | selection sort的优化版                             |
  |                | 每第i次循环, 最大堆root元素放到n-i位置            |                      |          |      |        |          |          |                                                    |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | bucket sort    |                                                   |                      |          |      |        |          |          |                                                    |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | counting sort  |                                                   |                      |          |      |        |          |          |                                                    |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | radix sort     |                                                   |                      |          |      |        |          |          |                                                    |
  |----------------+---------------------------------------------------+----------------------+----------+------+--------+----------+----------+----------------------------------------------------|

* 算法思路
  类似于之前的解题思路

  1. 分治
  2. 回溯
  3. 动态规划
  4. 贪心

* TODO 待整理
    1. 滑动窗口

** 条件判断中的边界
   Q: 为什么边界判断逻辑很难

   导致逻辑复杂的原因:
   1. 判断逻辑中依赖的变量 与变量变化 不在同一个位置
   2. 应该使用前缀++/--, 代替后缀, 便于理清边界
** 前缀++ vs 后缀++
** Z 字形变换引发的思考
   先观察思考, 再编码

   -----
   状态的思考:

   发现这里面的状态(turing internal state)只有
   q0:down
   q1: up

   转化条件:
   down->up: row = numRows - 1
   up->down: row = 0

   这里只有两种状态, 而状态的action可以形成toggle
   所以可以隐藏状态, 条件到了toggle切换一下即可.
   使用单个变量 action = !action 来处理


   -----
   思路的思考:

   0    6
   1  5 7
   2 4  8
   3    9


   对于这样的结构, 习惯性的往二维数组上面去思考, 其实是一个很大的误区.
   因为空闲的区域太多, 很容易造成空间上的浪费.

   需要的是: 第一行 + 第二行 + 第三行 ...
   而每一行都可以使用动态char[]数组, 也就是string 来存储
   所以结果就变为了string1 + string2 + ...
   大大简化了构造难度.
   构造vector<string> 要比构造char[][]方便很多


   -----
   对于算法或算法题的思考

   以前的解题思路总是:

   1. 分治: 有序数组
   2. 回溯
   3. DP
   4. 贪心
   5. *滑动窗口


   做了这道题, 才发现, 最基本的思路其实是图灵机 (或许λ演算也是相同的)
   图灵机中的internal state 真的非常有用, 而且还不容易导致出错

   而且相对于算法来说, 使用什么样的数据结构更加重要.
   一定是先使用合理的数据结构, 才能做出更好的算法


   -----

   边界的控制, 是非常薄弱的一环, 需要深入去了解一下
