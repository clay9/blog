#+title: 数据结构与算法分析
#+date: 2024-02-10 21:40:17
#+hugo_section: docs
#+hugo_bundle: prog_base/algorithm
#+export_file_name: index
#+hugo_weight: 1
#+hugo_draft: false
#+hugo_auto_set_lastmod: t
#+hugo_custom_front_matter: :bookCollapseSection false

* 概述|总结
** 什么是
   数据结构分为
   - 物理结构
     即在内存中的结构. 有顺序存储(内存连续) 和 链式存储(内存可不连续)
   - 逻辑结构
     一对一的线性, 一对多的树, 多对多的图
** 逻辑结构
*** 一对一
    - stack (LIFO)
      堆栈, 后进先出
    - queue (FIFO)
      队列, 先进先出
*** 一对多
    - tree 树
    - binary tree 二叉树
    - search binary tree 搜索二叉树
    - blance binary tree 平衡二叉树
    - complet binary tree 完全二叉树

    | name                | 特征                                         | 备注 |
    |---------------------+----------------------------------------------+------|
    | tree                |                                              |      |
    |---------------------+----------------------------------------------+------|
    | binary tree         | 1.任意节点 叶度 <=2                          |      |
    |---------------------+----------------------------------------------+------|
    | search bianry tree  | 1.binary tree                                |      |
    |                     | 2.任意节点 left-child, root, right-child有序 |      |
    |---------------------+----------------------------------------------+------|
    | blanced binary tree | 1.search binary tree                         |      |
    |                     | 2.任意节点的 <左树高度-右树高度>  <=1        |      |
    |---------------------+----------------------------------------------+------|
    | complet binary tree | 1.search tree                                |      |
    |                     | 2.节点依次从左到右                           |      |
    |---------------------+----------------------------------------------+------|
*** 多对多
    graph 图
* 数据结构比较

  | type        | type         | Access          | 查找            | 增加,删除       | 适用场景                   | c++类型            | 备注                                 |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|
  | array       | 1.数组       | O(1)            | O(n)            | O(n)            | 数据访问                   | 基础类型           | 1.Access快, 是因为内存连续, 寻址方便 |
  |             | 2.动态数组   |                 |                 |                 |                            | std::array         |                                      |
  |             |              |                 |                 |                 |                            | std::vector        |                                      |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|
  | linked-list | 1.单链表     | O(n)            | O(n)            | O(1)            | 数据增删, 查找较少         | std::list          |                                      |
  |             | 2.双链表     |                 |                 |                 |                            |                    |                                      |
  |             | 3.循环链表   |                 |                 |                 |                            |                    |                                      |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|
  | skip list   |              | O(n),Θ(logN)    | O(n),Θ(logN)    | O(n),Θ(logN)    | 介于array与linked list中间 |                    |                                      |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|
  | stack       |              | O(n)            | O(n)            | O(1)            | LIFO 数据增删              | std::stack         |                                      |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|
  | queue       | 1.队列       | O(n)            | O(n)            | O(1)            | FIFO 数据增删              | std::queue         |                                      |
  |             | 2.双端队列   |                 |                 |                 |                            | std::deque         |                                      |
  |             | 3.优先队列   |                 |                 |                 |                            |                    |                                      |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|
  | hash        |              | N/A             | O(1)            | O(1)            | 数据查找                   | std::unordered_map | T(n) = O(1) + hash函数 + 冲突        |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|
  | tree        | 1.二叉查找树 | O(n),Θ(logN)    | O(n),Θ(logN)    | O(n),Θ(logN)    |                            | std::set           |                                      |
  |             |              |                 |                 |                 |                            | std::map           |                                      |
  |             | 2.平衡二叉树 |                 |                 |                 |                            |                    |                                      |
  |             |              |                 |                 |                 |                            |                    |                                      |
  |             | 3.红黑树     | O(logN),Θ(logN) | O(logN),Θ(logN) | O(logN),Θ(logN) |                            |                    |                                      |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|
  | heap        | 1.最大堆     |                 |                 |                 |                            |                    | 1.完全二叉树 存储                    |
  |             | 2.最小堆     |                 |                 |                 |                            |                    | 2.最大(小)堆, 任意node > 其子树      |
  |             |              |                 |                 |                 |                            |                    | 3.实际是优先队列                     |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|
  | graph       |              |                 |                 |                 |                            |                    |                                      |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|
  | trie        |              |                 |                 |                 |                            |                    |                                      |
  |-------------+--------------+-----------------+-----------------+-----------------+----------------------------+--------------------+--------------------------------------|

* 排序算法比较

  | name           | type     | 定义                                              | T(n) θ              | T(n) O   | S(n) | 稳定性 | 适用场景 | 适用结构 | 备注                                               |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | bubble sort    | 冒泡排序 | 循环n次                                           | θ(n^2)              | O(n^2)   | O(1) | yes    | 数据较少 | 1.数组   | 循环结束判定:                                      |
  |                |          | 每第i次循环, 集合[0-i]中相邻元素按序交换          |                     |          |      |        | 基本有序 | 2.链表   | 1.循环了size-1次                                   |
  |                |          | 每第i次循环, 可确定n-i位置上的元素                |                     |          |      |        |          |          | 2.上次循环中没有发生元素交换                       |
  |                |          |                                                   |                     |          |      |        |          |          | 就表示是已序的了                                   |
  |                |          |                                                   |                     |          |      |        |          |          |                                                    |
  |                |          |                                                   |                     |          |      |        |          |          | 排序只用到指针 && flag, 原地排序,                  |
  |                |          |                                                   |                     |          |      |        |          |          | 因此空间复杂度为O(1)                               |
  |                |          |                                                   |                     |          |      |        |          |          |                                                    |
  |                |          |                                                   |                     |          |      |        |          |          | 元素交换O(n^2)                                     |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | selection sort | 选择排序 | 循环n次                                           | θ(n^2)              | O(n^2)   | O(1) | no     | 数据较少 | 1.数组   | 元素交换O(n)                                       |
  |                |          | 每第i次循环, 选择集合[i, n]中最小的元素,放在i位置 |                     |          |      |        |          | 2.链表   |                                                    |
  |                |          | 每第i次循环, 可确定i位置上的元素                  |                     |          |      |        |          |          |                                                    |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | insertion sort | 插入排序 | 循环n次                                           | θ(n^2)              | O(n^2)   | O(1) | yes    |          |          | 元素交换O(n^2)                                     |
  |                |          | 每第i次循环, 将i位置的元素放到集合[0-i]的有序位置 |                     |          |      |        |          |          |                                                    |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | shell sort     | 希尔排序 | 循环gap()拆分数组, 对拆分后的数组们进行插入排序   | Hibbard:   θ(n^3/2) | O(n^5/4) | O(1) | no     |          |          | 拆分后的数组们进行排序时没必要sort完A后再sort B, C |
  |                |          |                                                   | Sedgewick: θ(n^7/6) | O(n^4/3) |      |        |          |          | 可以A, B, C的sort在同一个for循环进行               |
  |                |          |                                                   |                     |          |      |        |          |          |                                                    |
  |                |          |                                                   |                     |          |      |        |          |          | T(n)与gap的选择有关                                |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | merge sort     | 归并排序 | 分而治之                                          | θ(nlogN)            | O(nlogN) | O(n) | yes    |          |          | 递归 与 非递归两种实现                             |
  |                |          | 分: 分为有序集合A, B                              |                     |          |      |        |          |          |                                                    |
  |                |          | 治: 有序集合A, B => C                             |                     |          |      |        |          |          |                                                    |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  | heap sort      | 堆排序   | 循环n次                                           | θ(nlogN)            | O(nlogN) | O(1) | no     |          |          | selection sort的优化版                             |
  |                |          | 每第i次循环, 最大堆root元素放到n-i位置            |                     |          |      |        |          |          |                                                    |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  |                | 快速排序 |                                                   |                     |          |      |        |          |          |                                                    |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  |                | 计数排序 |                                                   |                     |          |      |        |          |          |                                                    |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  |                | 基数排序 |                                                   |                     |          |      |        |          |          |                                                    |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|
  |                | 桶排序   |                                                   |                     |          |      |        |          |          |                                                    |
  |----------------+----------+---------------------------------------------------+---------------------+----------+------+--------+----------+----------+----------------------------------------------------|

