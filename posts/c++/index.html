<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>c++历史 - 飘</title><meta name=Description content><meta property="og:title" content="c++历史"><meta property="og:description" content="通过C++历史, 更好的了解C++特性"><meta property="og:type" content="article"><meta property="og:url" content="https://www.wcq.life/posts/c++/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-12T20:04:00+00:00"><meta property="article:modified_time" content="2023-06-07T08:32:10+00:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="c++历史"><meta name=twitter:description content="通过C++历史, 更好的了解C++特性"><meta name=application-name content="飘"><meta name=apple-mobile-web-app-title content="飘"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://www.wcq.life/posts/c++/><link rel=prev href=https://www.wcq.life/posts/calibre/><link rel=stylesheet href=/lib/normalize/normalize.min.css><link rel=stylesheet href=/css/style.min.css><link rel=stylesheet href=/lib/fontawesome-free/all.min.css><link rel=stylesheet href=/lib/animate/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"c++历史","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.wcq.life\/posts\/c\u002b\u002b\/"},"genre":"posts","keywords":"c\u002b\u002b","wordcount":12860,"url":"https:\/\/www.wcq.life\/posts\/c\u002b\u002b\/","datePublished":"2023-04-12T20:04:00+00:00","dateModified":"2023-06-07T08:32:10+00:00","publisher":{"@type":"Organization","name":"wcq"},"author":{"@type":"Person","name":"wcq"},"description":""}</script></head><body header-desktop header-mobile><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":""==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:""==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=飘>飘</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/emacs/index.html>Emacs </a><a class=menu-item href=/about>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=飘>飘</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/emacs/index.html title>Emacs</a><a class=menu-item href=/about title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">c++历史</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw"></i>wcq</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/c++/><i class="far fa-folder fa-fw"></i>c++</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2023-04-12>2023-04-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 12860 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 26 分钟&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#演变>演变</a><ul><li><a href=#1979-诞生>1979 诞生</a></li><li><a href=#1983-改名c-plus-plus>1983 改名C++</a></li><li><a href=#1985-发布第一版>1985 发布第一版<span class=org-target id=org-target--C--------></span></a></li><li><a href=#1989-发布release-2-dot-0>1989 发布Release 2.0</a></li><li><a href=#1990-出版了-标准化基础>1990 出版了<span class=org-target id=org-target--The-Annotated-C---Reference-Manual></span> 标准化基础</a></li><li><a href=#1998-c-plus-plus-98-第一个c-plus-plus-标准>1998 C++98 第一个C++标准</a></li><li><a href=#2003-c-plus-plus-03-第二个c-plus-plus-标准>2003 C++03 第二个C++标准</a></li><li><a href=#2006-c-plus-plus-性能技术报告>2006 C++性能技术报告</a></li><li><a href=#2007-c-plus-plus-技术报告-库扩展>2007 C++技术报告: 库扩展</a></li><li><a href=#2010-数学函数扩展>2010 数学函数扩展</a></li><li><a href=#2011-c-plus-plus-11-第三个c-plus-plus-标准>2011 C++11 第三个C++标准</a></li><li><a href=#2011-十进制浮点数扩展>2011 十进制浮点数扩展</a></li><li><a href=#2014-c-plus-plus-14-第四个c-plus-plus-标准>2014 C++14 第四个C++标准</a></li><li><a href=#2015-文件系统>2015 文件系统</a></li><li><a href=#2015-用于并行计算的扩展>2015 用于并行计算的扩展</a></li><li><a href=#2015-事务性内存操作>2015 事务性内存操作</a></li><li><a href=#2015-概念库-用于优化编译期信息>2015 概念库, 用于优化编译期信息</a></li><li><a href=#2016-用于并行计算的扩展>2016 用于并行计算的扩展</a></li><li><a href=#2017-标准库扩展>2017 标准库扩展</a></li><li><a href=#2017-提供范围机制>2017 提供范围机制</a></li><li><a href=#2017-协程库扩展>2017 协程库扩展</a></li><li><a href=#2017-c-plus-plus-17-第五个c-plus-plus-标准>2017 C++17 第五个C++标准</a></li><li><a href=#2018-网络库>2018 网络库</a></li><li><a href=#2018-并行扩展>2018 并行扩展</a></li><li><a href=#2018-模块>2018 模块</a></li><li><a href=#2020-c-plus-plus-20-第五个c-plus-plus-标准>2020 C++20 第五个C++标准</a></li></ul></li><li><a href=#设计原则>设计原则</a></li><li><a href=#待学习>待学习</a></li></ul></nav></div></div><div class=content id=content><p>通过C++历史, 更好的了解C++特性</p><h2 id=演变>演变</h2><h3 id=1979-诞生>1979 诞生</h3><p>刚开始叫做New C, 后改名C with Classes
诞生目的: 便于大型软件开发 && 运行效率
过 程: 增强C语言特性 (选C原因: C用途广, 快速, 可移植性)
新增特性:</p><ol><li>类别</li><li>衍生类别</li><li>存储类型检查</li><li>内联</li><li>缺省参数</li></ol><h3 id=1983-改名c-plus-plus>1983 改名C++</h3><p>新增特性:</p><ol><li>虚拟函数</li><li>函数名</li><li>运算子多载</li><li>参考 ???</li><li>常数</li><li>使用者可控制的自由空间存储区控制</li><li>改良的型别检查</li><li>单行注释 //</li></ol><h3 id=1985-发布第一版>1985 发布第一版<span class=org-target id=org-target--C--------></span></h3><p>非官方发布 ?? 这时候有官方了???</p><h3 id=1989-发布release-2-dot-0>1989 发布Release 2.0</h3><p>新增特性:</p><ol><li>多重继承</li><li>抽象类别</li><li>静态成员函数</li><li>常数成员函数</li><li>成员保护</li></ol><h3 id=1990-出版了-标准化基础>1990 出版了<span class=org-target id=org-target--The-Annotated-C---Reference-Manual></span> 标准化基础</h3><p>??哪一年??稍后还引入了模板例外处理、命名空间、新的强制类型转换，以及布林类型</p><h3 id=1998-c-plus-plus-98-第一个c-plus-plus-标准>1998 C++98 第一个C++标准</h3><p>标准分为 核心语言 && C++标准程序库
C++标准程序库主要包含 STL && C标准库的稍加修改版</p><p>语言特性:</p><ol><li>classes 相关<ol><li>构造 && 析构</li><li>friend</li><li>继承</li><li>多态</li><li>静态成员</li></ol></li><li>new delete</li><li>高级概念 ?? 高级在哪?? 需要对比当时的环境<ol><li>模板</li><li>命名空间</li><li>异常</li><li>类型转换
隐式转换 && 显式转换</li></ol></li></ol><p>stl:</p><ol><li>异常 &lt;exception></li><li>类型检查 &lt;typeinfo></li><li>输入输出 &lt;iostream></li></ol><h3 id=2003-c-plus-plus-03-第二个c-plus-plus-标准>2003 C++03 第二个C++标准</h3><p>C++03 主要是在C++98基础上针对实现方的一些问题进行了修复，从而在各个实现间达到一致、保持了可移植性。
该版本共涉及 92 项核心语言缺陷报告、125 项库缺陷报告，所提供的新特性只有一项：值初始化（value initialization）</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>实现方是指编译器 ??需要重点看一下当时的编译器有哪些??
</span></span><span class=line><span class=cl>对于使用者(程序员)来说, C++03与C++98差异不大(只有一条 值初始化)
</span></span></code></pre></td></tr></table></div></div><h3 id=2006-c-plus-plus-性能技术报告>2006 C++性能技术报告</h3><h3 id=2007-c-plus-plus-技术报告-库扩展>2007 C++技术报告: 库扩展</h3><h3 id=2010-数学函数扩展>2010 数学函数扩展</h3><h3 id=2011-c-plus-plus-11-第三个c-plus-plus-标准>2011 C++11 第三个C++标准</h3><p>先前被称作C++0x, 本预计2000-2009间会发布, 结果一直拖到了2011年. 因此改名C++11. <a href=https://zh.wikipedia.org/wiki/C%2B%2B11 target=_blank rel="noopener noreffer">参考资料</a></p><p>相比于C++03，C++11标准包含核心语言的新机能，
而且扩展C++标准程序库，并入了大部分的C++ Technical Report 1程序库（数学的特殊函数除外)</p><h4 id=设计原则>设计原则</h4><ol><li>维持稳定性和与C++98，可能的话还有C之间的兼容性；</li><li>尽可能不透过核心语言的扩展，而是透过标准程序库来引进新的特性；</li><li>能够演进编程技术的变更优先；</li><li>改进C++以帮助系统以及库设计，而不是引进只针对特别应用的新特性；</li><li>增进类别安全，提供对现行不安全的技术更安全的替代方案；</li><li>增进直接对硬件工作的能力与表现；</li><li>提供现实世界中问题的适当解决方案；</li><li>实行“zero-overhead”原则（某些功能要求的额外支持只有在该功能被使用时才能使用）；</li><li>使C++易于教授与学习</li></ol><h4 id=语言变更>语言变更</h4><p>C++委员会的主要作用之一是改善语言核心。核心语言将被大幅改善的领域包括</p><ul><li>多线程支持</li><li>泛型编程</li><li>统一的初始化</li><li>以及性能表现的加强</li></ul><p>在此分成4个区块来讨论核心语言的特色以及变更:
执行期表现强化、构造期表现强化、可用性强化，还有新的功能。
某些特性可能会同时属于多个区块，但在此仅于其最具代表性的区块描述</p><ul><li><p>执行期表现强化</p><p>提升某些性能表现, 像是内存或者速度上的提升</p><ul><li>右值引用 && std::move && std::forward</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>右值引用是语言特性,  std::move &amp;&amp; std::forward是stl中新增的函数 (头文件&lt;utility&gt;)
</span></span><span class=line><span class=cl>符合设计原则2, 使用stl补充语言特性
</span></span></code></pre></td></tr></table></div></div><p>右值引用的本质是为了解决C++之前版本的深度copy问题. <a href=https://zh.wikipedia.org/wiki/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8 target=_blank rel="noopener noreffer">wiki参考资料</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>template &lt;typename T, typename Arg&gt;
</span></span><span class=line><span class=cl>shared_ptr&lt;T&gt; factory(Arg arg)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>return shared_ptr&lt;T&gt;( new T(arg));
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>template &lt;typename T, typename Arg&gt;
</span></span><span class=line><span class=cl>shared_ptr&lt;T&gt; factory(Arg&amp; arg)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>return shared_ptr&lt;T&gt;( new T(arg));
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>template&lt; typename T, typename Arg&gt;
</span></span><span class=line><span class=cl>shared_ptr&lt;T&gt; factory(const Arg&amp; arg)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>//无法修改arg对象
</span></span><span class=line><span class=cl>return shared_ptr&lt;T&gt;( new T(arg));
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>template&lt;typename T, typename Arg&gt;
</span></span><span class=line><span class=cl>shared_ptr&lt;T&gt; factory(Arg&amp;&amp; arg)
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>return shared_ptr&lt;T&gt;(new T(std::forward&lt;Arg&gt;(arg)));
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>/*
</span></span><span class=line><span class=cl>调用时候, 参数如果是左值, 只需要std::move()获取对应的右值
</span></span><span class=line><span class=cl>*/
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//两者都在&lt;utility&gt;头文件
</span></span><span class=line><span class=cl>//std::move(arg)       可以获取左值的右值引用
</span></span><span class=line><span class=cl>//                     因为右值引用是将原对象的内容移动到新对象, 所以原对象移动后不应再使用
</span></span><span class=line><span class=cl>//std::forward&lt;T&gt;(arg) 可以获取arg的T属性.
</span></span><span class=line><span class=cl>//                     T如果为int,  则使用arg的右值
</span></span><span class=line><span class=cl>//                     T若果为int&amp;, 则使用arg的左值
</span></span></code></pre></td></tr></table></div></div><p>右值引用使用场景:</p><ol><li><p>上面的exp所展示的</p></li><li><p>就是在以传值方式传递对象时隐式发生的耗时且不必要的深度拷贝。
举例而言，std::vector&lt;T>本质上是一个C-style数组及其大小的封装，
如果一个std::vector&lt;T>的临时对象是在函数内部或者函数返回时创建，
要将其存储就只能透过生成新的std::vector&lt;T>并且把该临时对象所有的资料复制过去
然后该临时对象会被析构，其使用的内存会被释放</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>std::vector&lt;int&gt; test(){
</span></span><span class=line><span class=cl>  std::vector&lt;int&gt; vec_data;
</span></span><span class=line><span class=cl>   //一些操作
</span></span><span class=line><span class=cl>   //...
</span></span><span class=line><span class=cl>   //返回vec_data实际是
</span></span><span class=line><span class=cl>   //1.创建了一个新的std::vector&lt;int&gt; 临时对象
</span></span><span class=line><span class=cl>   //2.把vec_data对象深度copy给 临时对象
</span></span><span class=line><span class=cl>   //3.返回临时对象
</span></span><span class=line><span class=cl>   //4.销毁vec_data对象
</span></span><span class=line><span class=cl>   //
</span></span><span class=line><span class=cl>   // 其中深度copy会造成非常大的开销, 导致性能低下
</span></span><span class=line><span class=cl>   return vec_data;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>std::vector&lt;int&gt; test(){
</span></span><span class=line><span class=cl>  std::vector&lt;int&gt; vec_data;
</span></span><span class=line><span class=cl>  //一些操作
</span></span><span class=line><span class=cl>  //...
</span></span><span class=line><span class=cl>  //
</span></span><span class=line><span class=cl>  //1.创建一个新的std::vector&lt;int&gt; 临时对象
</span></span><span class=line><span class=cl>  //2.把vec_data对象移动到 临时对象
</span></span><span class=line><span class=cl>  //3.返回临时对象
</span></span><span class=line><span class=cl>  //4.销毁vec_data对象
</span></span><span class=line><span class=cl>  //
</span></span><span class=line><span class=cl>  //对比旧版本, 这里少了深度copy这一层
</span></span><span class=line><span class=cl>  return std::vector&lt;int&gt; (std::move(vec_data) );
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></li></ol><p>注意事项</p><ol><li>对象被右值引用后, 再操作会导致不可预知的问题(内存相关信息已被置为null)</li><li>并非所有情形都合适. 应该使用在避免深度copy的场合</li></ol><ul><li>constexpr 泛化的常量表达式</li></ul><p>constexpr确保对象在编译期完成初始化操作, 因此加快运行期的效率</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//const 与 constexpr 均表示该表达式(对象或函数)被声明为常量
</span></span><span class=line><span class=cl>//const     不保证对象经历哪种类型的初始化, 可能是编译器初始化, 也可能是运行期初始化
</span></span><span class=line><span class=cl>//constexpr 保证对象使用编译器初始化
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//const演示
</span></span><span class=line><span class=cl>int get_number(){ return 5; }
</span></span><span class=line><span class=cl>const int mx = get_number();  //mx是常量对象, 但在运行期获得初始化
</span></span><span class=line><span class=cl>int arr[mx] ; //错误. 因为mx是在运行期获得初始化; 而int[]需要编译器的常量
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//constexpr演示
</span></span><span class=line><span class=cl>constexpr int get_number(){ return 5; }
</span></span><span class=line><span class=cl>int arr[get_number()]; //正确. 因为constexpr保证函数get_number调用在编译器初始化
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span><span class=lnt>30
</span><span class=lnt>31
</span><span class=lnt>32
</span><span class=lnt>33
</span><span class=lnt>34
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//修饰函数表达式
</span></span><span class=line><span class=cl>//函数主体必须是非虚拟的，并且除了 typedef 和静态断言之外，仅包含一个 return 语句
</span></span><span class=line><span class=cl>constexpr int max() { return 4; } // ok
</span></span><span class=line><span class=cl>constexpr long long_max() { return 23423424; } //ok
</span></span><span class=line><span class=cl>constexpr bool get_val(){
</span></span><span class=line><span class=cl>  bool res = false;
</span></span><span class=line><span class=cl>  return res;
</span></span><span class=line><span class=cl>} //error: body只能有一个return statement
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//修饰变量
</span></span><span class=line><span class=cl>//与const类似
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//修饰构造函数
</span></span><span class=line><span class=cl>//构造函数可以有一个成员初始化列表, 但body必须是空的
</span></span><span class=line><span class=cl>//constexpr构造函数 允许编译器在编译时初始化对象, 前提是构造函数的参数都是常量表达式
</span></span><span class=line><span class=cl>struct complex
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  constexpr complex(double r, double i) : re(r), im(i) { } // ok
</span></span><span class=line><span class=cl>  double re;
</span></span><span class=line><span class=cl>  double im;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>constexpr complex cx0(0.0, 1.0); //ok. 编译期初始化
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>double x = 1.0;
</span></span><span class=line><span class=cl>constexpr complex cx1(x, 0); //error: x不是常量表达式
</span></span><span class=line><span class=cl>const     complex cx2(x, 0); //ok. 运行期初始化
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>constexpr double xx = 1.0;
</span></span><span class=line><span class=cl>constexpr complex cx3(xx, 0); //ok 编译期初始化
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>complex cx4(1.0, 2.0); //ok 运行期初始化
</span></span></code></pre></td></tr></table></div></div><ul><li>对POD定义的修正</li></ul><p>?? 这是什么, 完全没有看懂 ??</p></li></ul><ul><li><p>构造期表现强化</p><ul><li>外部模版</li></ul><p>在标准C++中，只要在编译单元内遇到被完整定义的模板，编译器都必须将其实例化（instantiate）
这会大大增加编译时间，特别是模板在许多编译单元内使用相同的参数实例化。</p><p>C++11之前, 可以告诉编译器在特定位置开始实例化, 但无法告诉编译器不要引发模板实例化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>template class std::vector&lt;MyClass&gt;;
</span></span></code></pre></td></tr></table></div></div><p>C++11增加了 阻止编译器在编译期间引发模板实例化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>extern template class std::vector&lt;MyClass&gt;;
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>可用性的加强</p><ul><li>初始化列表</li></ul><p>初始化列表的构想是 结构(或数组)的成员依据定义的顺序 由一串形参产生.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>struct Test{
</span></span><span class=line><span class=cl>  int a;
</span></span><span class=line><span class=cl>  double b;
</span></span><span class=line><span class=cl>  int c;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//给予 Test一串形参,  Test的成员根据位置,自动获得初始化
</span></span><span class=line><span class=cl>//Test成员a, b, c根据自己在Test结构中定义的顺序, 自动与形参1, 2.0, 3获得匹配的初始化
</span></span><span class=line><span class=cl>//即a=1, b=2.0, c=3
</span></span><span class=line><span class=cl>Test t1{1, 2.0, 3};
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++11 增加了初始化列表构造函数 std::initializer_list&lt;&gt;
</span></span><span class=line><span class=cl>class Test{
</span></span><span class=line><span class=cl>public:
</span></span><span class=line><span class=cl>  Test(std::initializer_list&lt;int&gt; list); //初始化列表构造函数
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>Test test{1, 2, 3, 4}; //允许Test对象可以像这样初始化
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//初始化列表构造函数的优先级大于普通的构造函数
</span></span><span class=line><span class=cl>class Test{
</span></span><span class=line><span class=cl>public:
</span></span><span class=line><span class=cl>  Test(std::initializer_list&lt;int&gt; list); //初始化列表构造函数
</span></span><span class=line><span class=cl>  Test(int i): m_i(i) { };               //普通构造函数
</span></span><span class=line><span class=cl>private:
</span></span><span class=line><span class=cl>  int m_i;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>//当初始化列表构造函数 与 普通构造函数形参一致的时候,
</span></span><span class=line><span class=cl>//如果使用{}初始化, 将调用的是初始化列表构造函数
</span></span><span class=line><span class=cl>//比如下面调用的是 Test(std::initializer_list&lt;int&gt; list);
</span></span><span class=line><span class=cl>Test test{1};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//如果想调用普通构造函数, 应该使用标准的构造函数语法
</span></span><span class=line><span class=cl>//调用的是 Test(init i);
</span></span><span class=line><span class=cl>Test test(1);
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//std::initializer_list除了可以在构造函数中使用, 也可用于普通函数
</span></span><span class=line><span class=cl>void Fun(std::initializer_list&lt;int&gt; list);
</span></span><span class=line><span class=cl>Fun(1, 2, 3);
</span></span></code></pre></td></tr></table></div></div><ul><li>统一的初始化</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>struct BasicStruct{
</span></span><span class=line><span class=cl>  int x;
</span></span><span class=line><span class=cl>  float y;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct AltStruct{
</span></span><span class=line><span class=cl>  AltStruct(int _x, float _y): x(_x), y(_y) {}
</span></span><span class=line><span class=cl>private:
</span></span><span class=line><span class=cl>  int x;
</span></span><span class=line><span class=cl>  float y;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//两者都可以采用一样的初始化样式
</span></span><span class=line><span class=cl>BasicStruct val1 {5, 2.1f};
</span></span><span class=line><span class=cl>AltStruct   val2 {2, 2.1f};
</span></span></code></pre></td></tr></table></div></div><ul><li>auto && decltype</li></ul><p>C++03使用参数必须明确的指出其类别.
然而随着模板类别的出现以及模板元编程的技巧, 某物的类别, 特被是函数定义明确的返回类别, 不容易表示.
C++11提供了auto 自动类别推导, 来解决该问题</p><p>有被明确初始化的参数可以使用auto.
对于指针类型, 使用auto 和 auto*是一样的.
对于引用类型, 必须使用auto&. 因为auto总是推断出非引用类型</p><ul><li>基于范围的for循环</li></ul><p>简化了for循环. 可以使用在C型数组, 初始化列表, 和任何定义了begin(), end()的类型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>int my_array[5] {1, 2, 3, 4, 5};
</span></span><span class=line><span class=cl>//每个元素 * 2
</span></span><span class=line><span class=cl>//注意这里是auto&amp;, 而非auto
</span></span><span class=line><span class=cl>for (auto&amp; x : my_array){
</span></span><span class=line><span class=cl>  x *= 2;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li>lambda函数表达式</li></ul><ul><li>返回类别后置的函数声明</li></ul><p>?? 看样子, 主要用于模板中函数的返回类别 ??</p><ul><li>class对象构造改良</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++11之前, 构造函数不允许调用其他构造函数
</span></span><span class=line><span class=cl>//C++11, 取消了该限制, 允许构造函数调用其他构造函数, 这种做法称为委托构造
</span></span><span class=line><span class=cl>class SomeType{
</span></span><span class=line><span class=cl>public:
</span></span><span class=line><span class=cl>  SomeType() : SomeType(0, &#34;hahah&#34;) {}
</span></span><span class=line><span class=cl>  SomeType(int i) : SomeType(i, &#34;haha222&#34;) {}
</span></span><span class=line><span class=cl>  SomeType(string&amp; s) : SomeType(1, s) { test(); }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>private:
</span></span><span class=line><span class=cl>  SomeType(int i, string&amp; s): m_i(i), m_s(s) {}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  int m_i;
</span></span><span class=line><span class=cl>  string m_s;
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++03 基类的构造函数不能直接作为派生类的构造函数, 每个派生类必须实现自己的构造函数
</span></span><span class=line><span class=cl>//C++11 取消了该限制. 编译器可以使用基类的构造函数完成派生类的构造
</span></span><span class=line><span class=cl>//而将基类的构造函数带入派生类的动作. 无法选择性的部分带入.
</span></span><span class=line><span class=cl>//要么全部带入, 要么一个都不带入
</span></span><span class=line><span class=cl>class BaseClass{
</span></span><span class=line><span class=cl>public:
</span></span><span class=line><span class=cl>  BaseClass(int v);
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>class DerivedClass :public BaseClass {
</span></span><span class=line><span class=cl>public:
</span></span><span class=line><span class=cl>  using BaseClass::BaseClass; //使用基类的构造函数
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++03 class 成员变量只能在构造函数中被初始化
</span></span><span class=line><span class=cl>//C++11 取消了该限制, 使其可以在声明的地方初始化
</span></span><span class=line><span class=cl>class SomeClass{
</span></span><span class=line><span class=cl>public:
</span></span><span class=line><span class=cl>  SomeClass() {}   //当构造函数中未初始化m_val时, 使用定义的值45
</span></span><span class=line><span class=cl>  SomeClass(int i) : m_val(i) {} //如果构造函数中初始化了m_val, 则使用构造函数中的值
</span></span><span class=line><span class=cl>private:
</span></span><span class=line><span class=cl>  int m_val = 45;
</span></span><span class=line><span class=cl>  int m_test {45}; //也可以使用列表初始化的样式
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><ul><li>显示虚函数重载</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>struct Base{
</span></span><span class=line><span class=cl>  virtual void func(int);
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct Derived : Base{
</span></span><span class=line><span class=cl>  virtual void func(int) override;    //ok 显示重载
</span></span><span class=line><span class=cl>  virtual void func(float) override;  //error: struct Base中没有对应的虚函数
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>struct Base{
</span></span><span class=line><span class=cl>  virtual void func(int) final;
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>struct Derived : Base{
</span></span><span class=line><span class=cl>  virtual void func(int);  //error: struct Base:func 禁止重载
</span></span><span class=line><span class=cl>};
</span></span></code></pre></td></tr></table></div></div><ul><li>空指针</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++11之前, 使用NULL来表示0和空指针 ( C的做法 )
</span></span><span class=line><span class=cl>//但是在函数重载时候, 就容易引发歧义
</span></span><span class=line><span class=cl>void foo (char*);
</span></span><span class=line><span class=cl>void foo (int);
</span></span><span class=line><span class=cl>void foo (nullptr_t);
</span></span><span class=line><span class=cl>//调用的实际是 void foo(int);  而非void foo(nullptr_t)
</span></span><span class=line><span class=cl>foo(NULL)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//C++11引入了nullptr 用来表示指针
</span></span><span class=line><span class=cl>//这样调用的就是 void foo(nullptr_t)
</span></span><span class=line><span class=cl>foo(nullptr)
</span></span></code></pre></td></tr></table></div></div><ul><li>强类型枚举</li></ul><p>?? 不是很明白 这个的意义在哪 ??
?? 枚举不和int比较, 不会很限制使用场景吗 ??</p><ul><li>角括号</li></ul><p>C++03的分析器一律把 >> 视为右移运算符. 为了避免, 编码时候不能把>>连着写. 尤其在模板编码中
C++11变更了分析器规则, 使其更加智能</p><ul><li>显式类别转换 explicit</li></ul><p>?? 完全没有印象 ??</p><ul><li>模板的别名</li></ul><p>?? 对模板 完全不熟悉 ??</p><ul><li>模板参数的缺省值</li></ul><ul><li>无限制的unions</li></ul><p>?? 需要详细了解一下 ??</p></li></ul><ul><li><p>能力的提升</p><p>这些特性让C++语言能够做一些以前做不到的，或者极其复杂的，或者需求一些不可移植的库的事情。</p><ul><li>可变参数模板</li></ul><p>?? 又是模板&mldr; ??</p><ul><li>字符串字面值</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++03 提供了两种字符串字面值
</span></span><span class=line><span class=cl>&#34;abc&#34;   //产生以空字符\0结尾的 const char 数组
</span></span><span class=line><span class=cl>L&#34;abc&#34;  //产生以空字符\0结尾的 const wchat_t数组
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//C++11加强了对Unicode的支持,
</span></span><span class=line><span class=cl>//类别char的定义被修改为其大小至少能够存储UTF-8的8位编码, 并且能够容纳编译器的基本字符集的任何成员
</span></span><span class=line><span class=cl>//新增char16_t, char32_t, 分别对应UTF-16, UTF-32
</span></span><span class=line><span class=cl>u8&#34;I&#39;m a UTF-8 string.&#34;
</span></span><span class=line><span class=cl>u&#34;I&#39;m a UTF-16 string.&#34;
</span></span><span class=line><span class=cl>U&#34;I&#39;m a UTF-32 string.&#34;
</span></span><span class=line><span class=cl>//并且允许直接在字符串内插入unicode codepoints
</span></span><span class=line><span class=cl>// \u之后的是16 bits的十六进制数值;
</span></span><span class=line><span class=cl>// \U之后的是32 bits的十六进制数值
</span></span><span class=line><span class=cl>u8&#34;This is a Unicode Character: \u2018.&#34;
</span></span><span class=line><span class=cl>u&#34;This is a bigger Unicode Character: \u2018.&#34;
</span></span><span class=line><span class=cl>u8&#34;This is a Unicode Character: \U00002018.&#34;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>R&#34;(The String Data \ Stuff &#34; )&#34; //()中的内容不会被转义
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//R 可以和 u8/u/U组合使用
</span></span><span class=line><span class=cl>u8R&#34;(I&#39;m a &#34;raw UTF-8&#34; string.)&#34;
</span></span></code></pre></td></tr></table></div></div><ul><li>用户定义字面值</li></ul><p>C++11开放用户定义新的字面修饰符（literal modifier），利用自定义的修饰符完成由字面值构造对象。</p><p>字面值转换可以定义为两个阶段：原始与转换后（raw与cooked)
原始字面值指特定类型的字符序列，而转换后的字面值则代表另一种类别。
如字面值1234，原始字面值是'1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &lsquo;4&rsquo;的字符序列；
而转换后的字面值是整数值1234。另外，字面值0xA转换前是序列'0&rsquo;, &lsquo;x&rsquo;, &lsquo;A&rsquo;；转换后代表整数值10。</p><p>?? 如何使用 ??</p><ul><li>多线程编程支持</li></ul><p>C++标准委员会计划统一对多线程编程的支持. 这将涉及两个部分：</p><ol><li>设计一个可以使多个线程在一个进程中共存的内存模型；</li><li>为线程之间的交互提供支持. 这部分将由程序库提供支持</li></ol><p>在多个线程可能会访问相同内存的情形下，由一个内存模型对它们进行调度是非常有必要的。
遵守模型规则的程序是被保证正确运行的，
但违反规则的程序会发生不可预料的行为，这些行为依赖于编译器的优化和内存一致性的问题。</p><p>虽然C++11会在语言的定义上提供一个内存模型以支持线程，但线程的使用主要将以C++11标准库的方式呈现。
C++11标准库会提供类别thread（std::thread）。若要执行一个线程，可以创建一个类别thread的实体，其初始参数为一个函数对象，以及该函数对象所需要的参数。透过成员函数std::thread::join()对线程会合的支持，一个线程可以暂停直到其它线程执行完毕。若有底层平台支持，成员函数std::thread::native_handle()将可提供对原生线程对象执行平台特定的操作。
对于线程间的同步，标准库将会提供适当的互斥锁（像是std::mutex，std::recursive_mutex等等）和条件参数（std::condition_variable和std::condition_variable_any）。前述同步机制将会以RAII锁（std::lock_guard和std::unique_lock）和锁相关算法的方式呈现，以方便程序员使用。
对于要求高性能，或是极底层的工作，有时或甚至是必须的，我们希望线程间的通信能避免互斥锁使用上的开销。以原子操作来访问内存可以达成此目的。针对不同情况，我们可以透过显性的内存屏障改变该访问内存动作的可见性。
对于线程间异步的传输，C++11标准库加入了以及std::packaged_task用来包装一个会传回异步结果的函数调用。因为缺少结合数个future的功能，和无法判定一组promise集合中的某一个promise是否完成，futures此一提案因此而受到了批评。
更高级的线程支持，如线程池，已经决定留待在未来的Technical Report加入此类支持。更高级的线程支持不会是C++11的一部分，但设想是其最终实现将创建在目前已有的线程支持之上。
std::async提供了一个简便方法以用来执行线程，并将线程绑定在std::future。用户可以选择一个工作是要多个线程上异步的执行，或是在一个线程上执行并等待其所需要的资料。默认的情况，实现可以根据底层硬件选择前面两个选项的其中之一。另外在较简单的使用情形下，实现也可以利用线程池提供支持。</p><p>?? 后期重点查看 ??</p><ul><li>thread-local的存储期限</li></ul><ul><li>使用或禁用对象的默认函数</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++03中, 用户无法精确控制class的默认函数, 比如默认构造函数, 默认复制构造函数, 默认赋值运算符等
</span></span><span class=line><span class=cl>//比方说, 要让class不能被copy, 必须将复制构造函数 与 赋值运算符声明为private, 并不去定义他们.
</span></span><span class=line><span class=cl>//        这样尝试使用这些为定义的函数会导致编译期或连接器错误
</span></span><span class=line><span class=cl>//        但这种手法一点也不理想
</span></span><span class=line><span class=cl>//
</span></span><span class=line><span class=cl>//C++11允许显示的声明采用或禁用编译器提供的内置函数
</span></span><span class=line><span class=cl>//
</span></span><span class=line><span class=cl>struct SomeType{
</span></span><span class=line><span class=cl>  SomeType() = default; //使用默认的构造函数
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//
</span></span><span class=line><span class=cl>struct NonCopyable{
</span></span><span class=line><span class=cl>  //禁用复制构造函数 &amp;&amp; 赋值运算符
</span></span><span class=line><span class=cl>  NonCopyable &amp; operator=(const NonCopyable&amp; ) = delete;
</span></span><span class=line><span class=cl>  NonCopyable (const NonCopyable&amp; ) = delete;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  NonCopyable () = default;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><ul><li>long long int类型</li></ul><p>在32位系统上，一个long long int是保有至少64个有效比特的整数类别。
C99将这个类别引入了标准C中，目前大多数的C++编译器也支持这种类别。
C++11将把这种类别添加到标准C++中。</p><ul><li>静态assertion</li></ul><ul><li>sizeof运算符可以作用于class的所有成员</li></ul><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++11之前, sizeof运算符只能用于class的静态成员
</span></span><span class=line><span class=cl>//C++11修改为均可使用
</span></span><span class=line><span class=cl>struct SomeType{
</span></span><span class=line><span class=cl>  OtherType member;
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>sizeof(SomeType::member); //传回OtherType的大小
</span></span><span class=line><span class=cl>//?? 如果成员是vector数组, 会是什么样 ??
</span></span></code></pre></td></tr></table></div></div><ul><li>垃圾回收机制</li></ul><p>?? 没明白&mldr; ??</p></li></ul><h4 id=stl变更>stl变更</h4><ul><li><p>stl组件上的升级</p><p>基于C++11新特性, 实现stl的更优</p><ol><li>右值引用和其相关的move支持</li><li>支持UTF-16编码，和UTF-32字符集</li><li>变长参数模板（与右值引用搭配可以达成完美转发（perfect forwarding））</li><li>编译期常量表达式</li><li>Decltype</li><li>显式类别转换子</li><li>使用或禁用对象的默认函数</li></ol></li></ul><ul><li>线程支持</li></ul><ul><li>多元组类别</li></ul><ul><li>散列表</li></ul><ul><li>正则表达式</li></ul><ul><li>通用智能指针</li></ul><ul><li><p>可扩展的随机数功能</p><p>?? C++版本的 也太麻烦了把 &mldr; ??</p></li></ul><ul><li><p>包装引用</p><p>?? 与模板有关 ??</p></li></ul><ul><li>对函数对象的包装</li></ul><ul><li><p>用于元编程的类别属性</p><p>?? ?? ??</p></li></ul><ul><li>用于计算函数对象返回类型的统一方法</li></ul><ul><li><p>itoa函数</p><p>iota 函数可将给定区间的值设定为从某值开始的连续值，
例如将连续十个整数设定为从 1 开始的连续整数（即 1、2、3、4、5、6、7、8、9、10）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>#include &lt;iostream&gt;
</span></span><span class=line><span class=cl>#include &lt;array&gt;
</span></span><span class=line><span class=cl>#include &lt;numeric&gt;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>std::array&lt;int, 10&gt; ai;
</span></span><span class=line><span class=cl>std::iota(ai.begin(), ai.end(), 1);
</span></span><span class=line><span class=cl>for(int i: ai){
</span></span><span class=line><span class=cl>  std::cout&lt;&lt;i&lt;&lt;&#34; &#34;;//1 2 3 4 5 6 7 8 9 10
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div><p>?? 貌似 作用不大呀 ??</p></li></ul><h3 id=2011-十进制浮点数扩展>2011 十进制浮点数扩展</h3><h3 id=2014-c-plus-plus-14-第四个c-plus-plus-标准>2014 C++14 第四个C++标准</h3><p>C++14旨在作为C++11的一个小扩展, 主要提供漏洞修复和小的改进. <a href=https://zh.wikipedia.org/wiki/C%2B%2B14 target=_blank rel="noopener noreffer">参考资料</a></p><h4 id=语言特性变更>语言特性变更</h4><ul><li><p>泛型的lambda</p><p>?? 这是什么玩意 ??</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++11中, lambda函数的形参必须被声明为具体的类型
</span></span><span class=line><span class=cl>//C++14 放宽了这个要求
</span></span><span class=line><span class=cl>auto lambda = [](auto x, auto y) { return x + y; }
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>lambda捕获部分中使用表达式</p><p>C++11的lambda函数允许通过 [值copy 或 引用] 捕获已在外层作用域声明的变量.
C++14允许lambda成员用任意的被捕获表达式初始化.意味着:</p><ol><li>允许 capture by value-move</li><li>允许任意声明的lambda成员, 而不需要外层作用域有一个具有相应名字的变量.这称为广义捕获.
即使在闭包区域中存在相同的变量也会被新变量覆盖(只是在lambda中被覆盖).
新变量类型由他的初始化表达式推导, 类似与auto</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//val新变量不需要特意声明类型, 会根据auto自动推导
</span></span><span class=line><span class=cl>//lambda的返回值为1, 说明新变量val成功被初始化
</span></span><span class=line><span class=cl>auto lambda = [val = 1]{ return val; }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//另一个例子
</span></span><span class=line><span class=cl>auto x = 1;
</span></span><span class=line><span class=cl>//lambda捕获中, r是x(外部x)的引用; x是新变量(会在lambda中覆盖外部变量x)
</span></span><span class=line><span class=cl>//此处的新变量r为1; 新变量x为10
</span></span><span class=line><span class=cl>auto f = [&amp;r=x, x=x*10]{
</span></span><span class=line><span class=cl>  ++ r;
</span></span><span class=line><span class=cl>  return r + x;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>//结果是外部变量x被设置为2;  f()返回12
</span></span><span class=line><span class=cl>f();
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>函数返回类型推导</p><p>C++11允许lambda函数根据return语句的表达式类型推断返回类型;
C++14为一般的函数也提供了这个功能.</p><p>?? 真的完全想不通这种不易阅读的特性 到底有什么用 ??</p></li></ul><ul><li><p>decltype(auto)</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>const int x = 0;
</span></span><span class=line><span class=cl>auto x1 = x; //x1为int类型
</span></span><span class=line><span class=cl>decltype(auto) x2 = x; //x2为const int类型
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int y =0;
</span></span><span class=line><span class=cl>int&amp; y1 = y;
</span></span><span class=line><span class=cl>auto y2 = y1; //int类型
</span></span><span class=line><span class=cl>decltype(auto) y3=y1; //int&amp;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>int&amp;&amp; z =0;
</span></span><span class=line><span class=cl>auto z1 = std::move(z); //int
</span></span><span class=line><span class=cl>decltype(auto) z2 = std::move(z); //int&amp;&amp;
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//函数返回类型为int
</span></span><span class=line><span class=cl>auto f (const int&amp; i) { return i; }
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//函数返回类型为const int&amp;
</span></span><span class=line><span class=cl>decltype(auto) g (const int&amp; i) { return i; }
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>constexpr函数放宽限制</p><p>C++11对constexpr函数做了严格的限制, 允许的语句非常少(基本就是一条return语句&mldr;)
C++14放宽了该限制. 允许constexpr有以下内容:</p><ol><li>任何声明, 除了</li></ol><ul><li>static 或 thread_local变量</li><li>没有初始化的变量声明</li></ul><ol start=2><li>条件分支语句 if && switch</li><li>所有的循环语句, 包含range for 循环</li><li>表达式可以改变一个对象的值
需要该对象的生命期在声明为constexpr的函数内部开始, 包括对有constexpr声明的任何非const非静态成员函数的调用.</li></ol><p>此外，C++11指出，所有被声明为constexpr的非静态成员函数也隐含声明为const（即函数不能修改*this的值）
C++14中这点已经被删除，非静态成员函数可以为非const</p></li></ul><ul><li><p>变量模板</p><p>C++14之前模板可以是函数模板或类模板
C++14中引入了变量模板</p></li></ul><ul><li><p>class对象构造优化 (聚合类的成员初始化)</p><p>C++11中class的成员变量可以在声明的地方初始化. 但是如果构造函数中未定义该变量, 那么该class就不允许使用聚合初始化;
C++14中放松了这一限制</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>struct Test{
</span></span><span class=line><span class=cl>  int m_x;
</span></span><span class=line><span class=cl>  int m_y = 40;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>  Test(int x) : m_x(x) {}
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Test t1{1}; //在C++11中是不允许的, 因为Test的构造函数Test(int x)中未初始化m_y
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Test t2{1}; //在C++14中是合法的. m_y会使用默认值40
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>二进制字面量</p><p>C++14的数字允许使用二进制形式指定.使用前缀0b或0B.</p></li></ul><ul><li><p>数字分位符</p><p>C++14引入单引号 &rsquo; 作为数字分位符号, 使得数值型的字母量更好的可读性.</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>auto integer_literal = 100&#39;0000;
</span></span><span class=line><span class=cl>auto floating_point_literal = 1.797&#39;693&#39;134&#39;862&#39;315&#39;7E+308;
</span></span><span class=line><span class=cl>auto binary_literal = 0b0100&#39;1100&#39;0110;
</span></span><span class=line><span class=cl>auto silly_example = 1&#39;0&#39;0&#39;000&#39;00;
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>deprecated属性</p><p>deprecated属性允许标记不推荐使用的实体，该实体仍然能合法使用，
但会让用户注意到使用它是不受欢迎的，并且可能会导致在编译期间输出警告消息。
deprecated可以有一个可选的字符串文字作为参数，以解释弃用的原因和/或建议替代者。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>[[deprecated]] void f();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>[[deprecated(&#34;g() is unsafe, use h() instead&#34;)]]
</span></span><span class=line><span class=cl>void g();
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>void test(){
</span></span><span class=line><span class=cl>  f(); //warnning: f()已被弃用
</span></span><span class=line><span class=cl>  g(); //warnning: g() is unsafe, use h() instead
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=stl变更>stl变更</h4><ul><li><p>共享的互斥体和锁</p><p>C++14增加了一类共享的互斥体和相应的共享锁
起初选择的名字是std::shared_mutex，但由于后来增加了与std::timed_mutex相似的特性，std::shared_timed_mutex成为了更适合的名字</p></li></ul><ul><li>元函数的别名</li></ul><ul><li><p>关联容器中的异构查找</p><p>C++标准库定义了四个关联容器类。
set和multiset允许用户根据一个值在容器中查找对应的的同类型的值。
map和multimap容器允许用户指定键（key）和值（value）的类型，根据键进行查找并返回对应的值。
然而，查找只能接受指定类型的参数，在map和multimap中是键的类型，而在set和multiset容器中就是值本身的类型。</p><p>C++14允许通过其他类型进行查找，只需要这个类型和实际的键类型之间可以进行比较操作。[
这允许std::set&lt;std::string>使用const char*，或任何可以通过operator&lt; 与std::string比较的类型作为查找的参数。</p><p>为保证向后兼容性，这种异构查找只在提供给关联容器的比较器允许的情况下有效。
标准库的泛型比较器，如std::less&lt;>与std::greater&lt;>允许异构查找</p></li></ul><ul><li><p>stl自定义字面量</p><p>C++11增加了自定义字面量的语言特性. C++14的stl中利用了这个特性
C++14 stl定义了如下字面量后缀</p><ol><li>s 创建各种std::basic_string类型</li><li>h, min, s, ms, us, ns 创建相应的std::chrono::duration时间间隔</li><li>if, i, il 创建std::complex&lt;float>, std::complex&lt;double>, std::complex&lt;long double>复数类型</li></ol><p>这些字面量可以用于编译时的constexpr</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//两个s互补干扰, 表示std::basic_string的s只能对字符串字面量操作, 而表示秒的只针对数字.
</span></span><span class=line><span class=cl>auto str = &#34;hello world&#34;s;
</span></span><span class=line><span class=cl>auto dur = 60s;
</span></span><span class=line><span class=cl>auto z   = 99i;
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>通过类型寻址多元组</p><p>C++11引入的std::tuple类型允许不同类型的值的聚合体用编译期整型常数索引。
C++14还允许使用类型代替常数索引，从多元组中获取对象。
若多元组含有多于一个这个类型的对象，将会产生一个编译错误</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>tuple&lt;string, string, int&gt; t(&#34;foo&#34;, &#34;bar&#34;, 7);
</span></span><span class=line><span class=cl>int i = get&lt;2&gt;(t);    //i = 7; C++11
</span></span><span class=line><span class=cl>int j = get&lt;int&gt;(t);  //j = 7; C++14新增
</span></span><span class=line><span class=cl>string s = get&lt;string&gt;(t); //编译错误, 歧义
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>较小的标准库特性</p><ol><li>std::make_unique可以像std::make_shared一样使用, 用于产生std::unique_str对象</li><li>std::is_finale用于识别一个class类型是否禁止被继承</li><li>std::integral_constant增加了一个返回常量值的operator()</li><li>全局std::begin/std::end函数之外, 增加了std::cbegin/std::cend函数, 用于返回常量迭代器 constant iterators</li></ol></li></ul><h3 id=2015-文件系统>2015 文件系统</h3><h3 id=2015-用于并行计算的扩展>2015 用于并行计算的扩展</h3><h3 id=2015-事务性内存操作>2015 事务性内存操作</h3><h3 id=2015-概念库-用于优化编译期信息>2015 概念库, 用于优化编译期信息</h3><h3 id=2016-用于并行计算的扩展>2016 用于并行计算的扩展</h3><h3 id=2017-标准库扩展>2017 标准库扩展</h3><h3 id=2017-提供范围机制>2017 提供范围机制</h3><h3 id=2017-协程库扩展>2017 协程库扩展</h3><h3 id=2017-c-plus-plus-17-第五个c-plus-plus-标准>2017 C++17 第五个C++标准</h3><p>C++17旨在作为大型扩展. <a href=https://zh.wikipedia.org/wiki/C%2B%2B17 target=_blank rel="noopener noreffer">参考资料</a></p><h4 id=新功能>?? 新功能 ??</h4><ul><li>static_assert无需提供出错信息</li></ul><ul><li>具有模板形式的模板参数允许使用typename (之前只能使用class)</li></ul><ul><li>std::uncaught_excepitions取代std::uncaught_exception</li></ul><ul><li>变长参数模板的Folding运算</li></ul><ul><li>容器访问操作表示方法的统一化</li></ul><ul><li>连续迭代器</li></ul><ul><li>新增特殊数学函数</li></ul><h4 id=语言特性>语言特性</h4><ul><li><p>u8字面量</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++11的时候, u8可以修饰字符串
</span></span><span class=line><span class=cl>//C++17新增了u8可以修饰单个字符
</span></span><span class=line><span class=cl>char x = u8&#39;x&#39;;
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>使noexcept成为系统的一部分</p><p>?? 需要再仔细的查看 ??
noexcept在C++11中首次加入, 作用是抛出异常, 取代throw ?? 为什么取代throw ??</p><p>C++17中使其成为了系统的一部分 ??什么意思??</p></li></ul><ul><li><p>{}列表初始化的自动推导规则</p><p>具体详见C++11中的说明 <a href=#%e5%88%9d%e5%a7%8b%e5%8c%96%e5%88%97%e8%a1%a8 rel>初始化列表</a></p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++11中会被推导为 std::initializer_list&lt;int&gt;
</span></span><span class=line><span class=cl>//C++17中推导为 int
</span></span><span class=line><span class=cl>auto x {3};
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>lambda函数按值捕获this指针</p><p>C++17之前, lambda只能按引用捕获this指针
C++17允许使用*this捕获对象的副本</p></li></ul><ul><li><p>class 构造函数</p><p>?? 完全没有概念 ??</p><ol><li>编译时 if constexpr</li><li>构造函数lambda</li></ol></li></ul><ul><li><p>内联变量 inline</p><p>过去inline用于函数声明, 现在也可以用于变量声明, 表示函数或定义可定义多次(内容必须完全相同)
这允许在头文件中定义一个内联变量</p></li></ul><ul><li><p>结构化绑定</p><p>变量定义初始化时, 允许形如auto [x,y,z] = expr;
其中expr的 元组类似的对象包括 std::tuple, std::pair, std::array等聚合结构</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//例子1
</span></span><span class=line><span class=cl>using Coordinate = std::pair&lt;int, int&gt;;
</span></span><span class=line><span class=cl>Coordinate origin() { return Coordinate{1,2}; }
</span></span><span class=line><span class=cl>const auto [x, y] = origin(); //x=1; y=2
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//例子2
</span></span><span class=line><span class=cl>std::unordered_map&lt;std::string, int&gt; mapping{
</span></span><span class=line><span class=cl>  {&#34;a&#34;, 1},
</span></span><span class=line><span class=cl>  {&#34;b&#34;, 2},
</span></span><span class=line><span class=cl>  {&#34;c&#34;, 3},
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>for (const auto&amp; [key, value] : mapping:){
</span></span><span class=line><span class=cl>   //do something
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>if/switch选择语句可以带初始化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//例子1
</span></span><span class=line><span class=cl>//之前需要放到语句块中限制锁的范围
</span></span><span class=line><span class=cl>{
</span></span><span class=line><span class=cl>  std::lock_guard&lt;std::mutex&gt; lk(mx);
</span></span><span class=line><span class=cl>  if (v.empty()) v.push_back(val);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>//现在可以直接放到if中
</span></span><span class=line><span class=cl>if (std::lock_guard&lt;std::mutex&gt; lk(mx); v.empty()) {
</span></span><span class=line><span class=cl>  v.push_back(val);
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//例子2
</span></span><span class=line><span class=cl>//更好的限制了变量的作用域
</span></span><span class=line><span class=cl>Foo gadget(args);
</span></span><span class=line><span class=cl>switch (auto s = gadget.status()) {
</span></span><span class=line><span class=cl>  case OK: gadget.zip(); break;
</span></span><span class=line><span class=cl>  case Bad: throw BadFoo(s.message());
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>//vs.现在
</span></span><span class=line><span class=cl>switch (Foo gadget(args); auto s = gadget.status()) {
</span></span><span class=line><span class=cl>  case OK: gadget.zip(); break;
</span></span><span class=line><span class=cl>  case Bad: throw BadFoo(s.message());
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>嵌套的namespace</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//C++17以前
</span></span><span class=line><span class=cl>namespace A{
</span></span><span class=line><span class=cl>  namespace B{
</span></span><span class=line><span class=cl>namespace C{
</span></span><span class=line><span class=cl>  int i;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//C++17简化了
</span></span><span class=line><span class=cl>namespace A::B::C{
</span></span><span class=line><span class=cl>  int i;
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>fallthrough, nodiscard, maybe_unused特性</p><p>C++17中新增</p></li></ul><h4 id=stl>stl</h4><ul><li>std::variant</li></ul><ul><li>std::optional</li></ul><ul><li>std::any</li></ul><ul><li>std::string_view</li></ul><ul><li>std::filesystem</li></ul><ul><li>std::invoke</li></ul><ul><li>std::apply</li></ul><ul><li>std::byte</li></ul><ul><li>maps && sets更优效率的移动节点</li></ul><ul><li><p>并行算法</p><p>许多stl算法, 如copy, find和sort支持并行执行策略</p></li></ul><h3 id=2018-网络库>2018 网络库</h3><h3 id=2018-并行扩展>2018 并行扩展</h3><h3 id=2018-模块>2018 模块</h3><h3 id=2020-c-plus-plus-20-第五个c-plus-plus-标准>2020 C++20 第五个C++标准</h3><p>C++20是一项非常大的改动. <a href="https://zhuanlan.zhihu.com/p/137646370?utm_id=0" target=_blank rel="noopener noreffer">参考资料</a></p><h4 id=语言特性>语言特性</h4><ul><li><p>新增关键字</p><ol><li>concept</li><li>requires</li><li>constinit</li><li>consteval</li><li>co_await</li><li>co_return</li><li>co_yield</li><li>char8_t</li></ol></li></ul><ul><li><p>新增标识符</p><ol><li>import</li><li>module</li></ol></li></ul><ul><li><p>modules 模块</p><p>优点:</p><ol><li>没有头文件</li><li>声明实现仍然可以分离, 但非必要</li><li>可以显示指定哪些导出(类, 函数等)</li><li>不需要头文件重复引入宏 include</li><li>模块之间名称可以相同 不会冲突</li><li>模块只处理一次, 编译更快 (头文件每次引入都需要处理)</li><li>预处理宏只在模块内有效</li><li>模块引入顺序无关紧要 (头文件引入顺序不同,可能发生不同结果)</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//创建模块
</span></span><span class=line><span class=cl>//export导出模块; 模块的名字是cppcon
</span></span><span class=line><span class=cl>export module cppcon;
</span></span><span class=line><span class=cl>namespace CppCon{
</span></span><span class=line><span class=cl>  auto GetWelcomeHelper() { return &#34;Hello World&#34;; }
</span></span><span class=line><span class=cl>  export auto GetWelcome() { return GetWelcomehelper(); }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//引用模块
</span></span><span class=line><span class=cl>import cppcon;
</span></span><span class=line><span class=cl>int main(){
</span></span><span class=line><span class=cl>  std::cout &lt;&lt; CppCon::GetWelcome();
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>import头文件</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//隐式的将 iostream 转换为模块
</span></span><span class=line><span class=cl>//加速构建, 因为iosteam只会处理一次
</span></span><span class=line><span class=cl>//和预编译PCH具有相似的效果 ?? PCH是什么 ??
</span></span><span class=line><span class=cl>import &lt;iostream&gt;
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>Ranges</p><p>Range代表一串元素或者一串元素中的一段
意义:</p><ol><li>简化语法, 方便使用</li><li>防止begin/end不配对</li><li>使变换/过滤等串联操作成为可能</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>vector&lt;int&gt; data{11, 22, 33};
</span></span><span class=line><span class=cl>sort(begin(data), end(data));
</span></span><span class=line><span class=cl>sort(data); //使用Ranges
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//View: 延迟计算, 不持有, 不改写
</span></span><span class=line><span class=cl>//Actions: 即时处理, 改写
</span></span><span class=line><span class=cl>//Algorithms: 所有接受begin/end对的算法都可以使用
</span></span><span class=line><span class=cl>//View和Ations使用管道符 | 串联
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//例子1 串联view
</span></span><span class=line><span class=cl>vector&lt;int&gt; data{1,2,3,4,5,6,7,8,9,10};
</span></span><span class=line><span class=cl>auto result = data |
</span></span><span class=line><span class=cl>	  views::remove_if([] (int i) { return i % 2 == 1;}) |
</span></span><span class=line><span class=cl>	  views::transform([])(int i) { return to_string(i);});
</span></span><span class=line><span class=cl>//result = {&#34;2&#34;,&#34;4&#34;,&#34;6&#34;,&#34;8&#34;,&#34;10&#34;};
</span></span><span class=line><span class=cl>//注意 以上操作被延迟, 只有便利result的时候才触发
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//例子2 串联actions
</span></span><span class=line><span class=cl>//排序然后去重
</span></span><span class=line><span class=cl>//操作会原地对data进行更改, 然后返回
</span></span><span class=line><span class=cl>vector&lt;int&gt; data{4, 3, 4, 1, 8, 0, 8};
</span></span><span class=line><span class=cl>vector&lt;int&gt; result = data| actions::sort | actions::unique;
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>//例子3 过滤和变换
</span></span><span class=line><span class=cl>//所有的计算延迟到accumulate累加遍历的时候发生
</span></span><span class=line><span class=cl>int total = accumulate( view::ints(1) |  //产生一个无限对整型数列
</span></span><span class=line><span class=cl>		    view::transform([] (int i) { return i * i;}) | //平方
</span></span><span class=line><span class=cl>		    view::take(10), //取前10个元素
</span></span><span class=line><span class=cl>		    0); //累加
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>协程</p><p>意义:</p><ol><li>异步I/O</li><li>延迟计算</li><li>事件驱动的程序</li><li>generator</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//co_wait    挂起协程, 等待其他计算完成
</span></span><span class=line><span class=cl>//co_return  从协程返回 (协程禁用return)
</span></span><span class=line><span class=cl>//co_yield   弹出一个值, 挂起协程, 下一次调用继续协程的运行
</span></span><span class=line><span class=cl>//for co_await 循环体
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>Concepts</p><p>?? 模板相关 ??</p></li></ul><ul><li><p>lambda</p><ol><li>需要显示捕获this变量
C++20之前 [=] 隐式捕获this
C++20开始 需要显示捕获this [=, this]</li><li>模板形式的lambda表达式</li><li>lambda表达式捕获 支持打包展开</li></ol></li></ul><ul><li>constexpr 更新</li></ul><ul><li><p>原子智能指针 Atomic</p><p>智能指针对于数据读写并非线程安全.
C++20之前, 多线程中使用智能指针, 需要使用mutex控制访问.
C++20新增 atomic&lt;shared_ptr&lt;T>>, atomic&lt;weak_ptr&lt;T>></p></li></ul><ul><li><p>class 指定初始化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>struct Data{
</span></span><span class=line><span class=cl>  int m_x = 0;
</span></span><span class=line><span class=cl>  std::string m_s;
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>Data d{.m_s = &#34;Hellow&#34;};
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>&lt;=> 运算符</p><p>三路比较运算符</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>//类似C的strcmp函数返回-1, 0, 1
</span></span><span class=line><span class=cl>//但实际&lt;=&gt;返回的并非int类型, 而是&lt;compare&gt;头中的对象
</span></span><span class=line><span class=cl>(a &lt;=&gt; b ) &lt; 0 //如果a&lt;b为true
</span></span><span class=line><span class=cl>(a &lt;=&gt; b ) == 0 //如果a==b为true
</span></span><span class=line><span class=cl>(a &lt;=&gt; b ) &gt; 0 //如果a&gt;b为true
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>范围for循环语句 支持初始化语句</p><p>C++17 if, switch语句支持了初始化语句
C++20 新增for循环语句的支持</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>for (auto data = GetData(); auto&amp; value : data){
</span></span><span class=line><span class=cl>  //do something
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>特性测试宏</p><p>__has_cpp_attribute(fallthrough)
__cpp_binary_literals
__cpp_chart_t
__cpp_coroutines</p></li></ul><ul><li><p>consteval</p><p>constexpr函数可能编译期执行, 也可以在运行期执行;
consteval只能在编译期执行</p></li></ul><ul><li><p>constinit</p><p>强制指定以常量方式初始化</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>const char* GetStringDyn() {
</span></span><span class=line><span class=cl>  return &#34;dynamic init&#34;;
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>constexpr const char* GetString(bool constInit) {
</span></span><span class=line><span class=cl>  return constInit ?
</span></span><span class=line><span class=cl>&#34;constant init&#34; :
</span></span><span class=line><span class=cl>GetStringDyn();
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>constinit const char* a = GetString(true); // ✔
</span></span><span class=line><span class=cl>constinit const char* b = GetString(false); // ❌
</span></span></code></pre></td></tr></table></div></div></li></ul><ul><li><p>用using引用enum类型</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span><span class=lnt>24
</span><span class=lnt>25
</span><span class=lnt>26
</span><span class=lnt>27
</span><span class=lnt>28
</span><span class=lnt>29
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>enum class CardTypeSuit {
</span></span><span class=line><span class=cl>  Clubs,
</span></span><span class=line><span class=cl>  Diamonds,
</span></span><span class=line><span class=cl>  Hearts,
</span></span><span class=line><span class=cl>  Spades
</span></span><span class=line><span class=cl>};
</span></span><span class=line><span class=cl>//C++20之前
</span></span><span class=line><span class=cl>std::string_view GetString(const CardTypeSuit cardTypeSuit) {
</span></span><span class=line><span class=cl>switch (cardTypeSuit) {
</span></span><span class=line><span class=cl>case CardTypeSuit::Clubs:
</span></span><span class=line><span class=cl>  return &#34;Clubs&#34;;
</span></span><span class=line><span class=cl>case CardTypeSuit::Diamonds:
</span></span><span class=line><span class=cl>  return &#34;Diamonds&#34;;
</span></span><span class=line><span class=cl>case CardTypeSuit::Hearts:
</span></span><span class=line><span class=cl>   return &#34;Hearts&#34;;
</span></span><span class=line><span class=cl>case CardTypeSuit::Spades:
</span></span><span class=line><span class=cl>   return &#34;Spades&#34;;
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span><span class=line><span class=cl>//C++20
</span></span><span class=line><span class=cl>std::string_view GetString(const CardTypeSuit cardTypeSuit) {
</span></span><span class=line><span class=cl>switch (cardTypeSuit) {
</span></span><span class=line><span class=cl>   using enum CardTypeSuit; // 这里
</span></span><span class=line><span class=cl>   case Clubs: return &#34;Clubs&#34;;
</span></span><span class=line><span class=cl>   case Diamonds: return &#34;Diamonds&#34;;
</span></span><span class=line><span class=cl>   case Hearts: return &#34;Hearts&#34;;
</span></span><span class=line><span class=cl>   case Spades: return &#34;Spades&#34;;
</span></span><span class=line><span class=cl>  }
</span></span><span class=line><span class=cl>}
</span></span></code></pre></td></tr></table></div></div></li></ul><h4 id=stl>stl</h4><ul><li>choron 增加日历和时区的支持</li></ul><ul><li><p>std::span</p><p>某段连续数据的视图
不持有数据, 不分配和销毁数据
copy非常快
不支持数据跨步
可通过运行期确定长度, 也可编译期确定长度</p></li></ul><ul><li><p>特性测试宏</p><p>__cpp_lib_conceps
__cpp_lib_ranges
__cpp_lib_scoped_lock</p></li></ul><ul><li><p>&lt;version></p><p>包含c++标准库版本, 发布日期, 版权证书, 特性宏等</p></li></ul><ul><li><p>std::format</p><p>?? C++ 也有format了 &mldr;. ??</p></li></ul><h2 id=设计原则>设计原则</h2><ol><li>C++设计成直接的和广泛的支援多种程式设计风格（过程化程式设计、数据抽象、物件导向程式设计、泛型程式设计）。</li><li>C++设计成给程式设计者更多的选择，即使可能导致程式设计者选择错误。</li><li>C++设计成尽可能与C相容，借此提供一个从C到C++的平滑过渡。</li><li>C++避免平台限定或没有普遍用途的特性。</li><li>C++不使用会带来额外开销的特性。</li><li>C++设计成无需复杂的程式设计环境。</li></ol><h2 id=待学习>待学习</h2><ol><li>stl
C++中很重要的功能, 必须要尽快了解常用的</li><li>新的概念
C++20中增加了很多新概念</li><li>新的语言特性
只需要学习常用的特性, 有些特性是为了配合模板而来的, 暂时不需要学习</li><li>其他常用的库
比如网络库Asio, 格式库protobuf</li><li>模板
模板的作用 更多的是用在stl的编写上, 日常开发使用的比较少, 可以暂时先不学习</li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-06-07</span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/tags/c++/>c++</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/calibre/ class=prev rel=prev title="calibre 图书管理软件"><i class="fas fa-angle-left fa-fw"></i>calibre 图书管理软件</a></div></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2019 - 2023</span>&nbsp;|&nbsp;<span class=license><a rel="license external nofollow noopener noreffer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=/lib/smooth-scroll/smooth-scroll.min.js></script><script type=text/javascript src=/lib/autocomplete/autocomplete.min.js></script><script type=text/javascript src=/lib/lunr/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=/lib/lazysizes/lazysizes.min.js></script><script type=text/javascript src=/lib/clipboard/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:100,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>