<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>c++历史 - 飘</title><meta name=Description content="This is my cool site"><meta property="og:title" content="c++历史">
<meta property="og:description" content="通过C++历史, 更好的了解C++特性 演变 1979 诞生 刚开始叫做New C, 后改名C with Classes 诞生目的: 便于大型软件开发 && 运行效率 过 程: 增强C语言特性 (选C原"><meta property="og:type" content="article"><meta property="og:url" content="https://www.wcq.life/posts/c++/c++/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-04-12T20:04:50+00:00"><meta property="article:modified_time" content="2023-04-12T20:04:50+00:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary"><meta name=twitter:title content="c++历史"><meta name=twitter:description content="通过C++历史, 更好的了解C++特性 演变 1979 诞生 刚开始叫做New C, 后改名C with Classes 诞生目的: 便于大型软件开发 && 运行效率 过 程: 增强C语言特性 (选C原"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://www.wcq.life/posts/c++/c++/><link rel=prev href=https://www.wcq.life/posts/tool/calibre/><link rel=next href=https://www.wcq.life/posts/tool/hugo/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"c++历史","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.wcq.life\/posts\/c\u002b\u002b\/c\u002b\u002b\/"},"genre":"posts","wordcount":12363,"url":"https:\/\/www.wcq.life\/posts\/c\u002b\u002b\/c\u002b\u002b\/","datePublished":"2023-04-12T20:04:50+00:00","dateModified":"2023-04-12T20:04:50+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"wcq"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"light"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"light"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=飘>飘</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/emacs/index.html>Emacs </a><a class=menu-item href=/about>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=飘>飘</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/emacs/index.html title>Emacs</a><a class=menu-item href=/about title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class=toc-content id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">c++历史</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>wcq</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-04-12>2023-04-12</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 12363 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 25 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#headline-1>演变</a><ul><li><a href=#headline-2>1979 诞生</a></li><li><a href=#headline-3>1983 改名C++</a></li><li><a href=#headline-4>1985 发布第一版&lt;&lt;C++程式设计语言>></a></li><li><a href=#headline-5>1989 发布Release 2.0</a></li><li><a href=#headline-6>1990 出版了&lt;&lt;The Annotated C++ Reference Manual>> 标准化基础</a></li><li><a href=#headline-7>1998 C++98 第一个C++标准</a></li><li><a href=#headline-8>2003 C++03 第二个C++标准</a></li><li><a href=#headline-9>2006 C++性能技术报告</a></li><li><a href=#headline-10>2007 C++技术报告: 库扩展</a></li><li><a href=#headline-11>2010 数学函数扩展</a></li><li><a href=#headline-12>2011 C++11 第三个C++标准</a><ul><li><a href=#headline-13>设计原则</a></li><li><a href=#headline-14>语言变更</a><ul><li><a href=#headline-15>执行期表现强化</a><ul><li><a href=#headline-16>右值引用 && std::move && std::forward</a></li><li><a href=#headline-17>constexpr 泛化的常量表达式</a></li><li><a href=#headline-18>对POD定义的修正</a></li></ul></li><li><a href=#headline-19>构造期表现强化</a><ul><li><a href=#headline-20>外部模版</a></li></ul></li><li><a href=#headline-21>可用性的加强</a><ul><li><a href=#headline-22>初始化列表</a></li><li><a href=#headline-23>统一的初始化</a></li><li><a href=#headline-24>auto && decltype</a></li><li><a href=#headline-25>基于范围的for循环</a></li><li><a href=#headline-26>lambda函数表达式</a></li><li><a href=#headline-27>返回类别后置的函数声明</a></li><li><a href=#headline-28>class对象构造改良</a></li><li><a href=#headline-29>显示虚函数重载</a></li><li><a href=#headline-30>空指针</a></li><li><a href=#headline-31>强类型枚举</a></li><li><a href=#headline-32>角括号</a></li><li><a href=#headline-33>显式类别转换 explicit</a></li><li><a href=#headline-34>模板的别名</a></li><li><a href=#headline-35>模板参数的缺省值</a></li><li><a href=#headline-36>无限制的unions</a></li></ul></li><li><a href=#headline-37>能力的提升</a><ul><li><a href=#headline-38>可变参数模板</a></li><li><a href=#headline-39>字符串字面值</a></li><li><a href=#headline-40>用户定义字面值</a></li><li><a href=#headline-41>多线程编程支持</a></li><li><a href=#headline-42>thread-local的存储期限</a></li><li><a href=#headline-43>使用或禁用对象的默认函数</a></li><li><a href=#headline-44>long long int类型</a></li><li><a href=#headline-45>静态assertion</a></li><li><a href=#headline-46>sizeof运算符可以作用于class的所有成员</a></li><li><a href=#headline-47>垃圾回收机制</a></li></ul></li></ul></li><li><a href=#headline-48>stl变更</a><ul><li><a href=#headline-49>stl组件上的升级</a></li><li><a href=#headline-50>线程支持</a></li><li><a href=#headline-51>多元组类别</a></li><li><a href=#headline-52>散列表</a></li><li><a href=#headline-53>正则表达式</a></li><li><a href=#headline-54>通用智能指针</a></li><li><a href=#headline-55>可扩展的随机数功能</a></li><li><a href=#headline-56>包装引用</a></li><li><a href=#headline-57>对函数对象的包装</a></li><li><a href=#headline-58>用于元编程的类别属性</a></li><li><a href=#headline-59>用于计算函数对象返回类型的统一方法</a></li><li><a href=#headline-60>itoa函数</a></li></ul></li></ul></li><li><a href=#headline-61>2011 十进制浮点数扩展</a></li><li><a href=#headline-62>2014 C++14 第四个C++标准</a><ul><li><a href=#headline-63>语言特性变更</a><ul><li><a href=#headline-64>泛型的lambda</a></li><li><a href=#headline-65>lambda捕获部分中使用表达式</a></li><li><a href=#headline-66>函数返回类型推导</a></li><li><a href=#headline-67>decltype(auto)</a></li><li><a href=#headline-68>constexpr函数放宽限制</a></li><li><a href=#headline-69>变量模板</a></li><li><a href=#headline-70>class对象构造优化 (聚合类的成员初始化)</a></li><li><a href=#headline-71>二进制字面量</a></li><li><a href=#headline-72>数字分位符</a></li><li><a href=#headline-73>deprecated属性</a></li></ul></li><li><a href=#headline-74>stl变更</a><ul><li><a href=#headline-75>共享的互斥体和锁</a></li><li><a href=#headline-76>元函数的别名</a></li><li><a href=#headline-77>关联容器中的异构查找</a></li><li><a href=#headline-78>stl自定义字面量</a></li><li><a href=#headline-79>通过类型寻址多元组</a></li><li><a href=#headline-80>较小的标准库特性</a></li></ul></li></ul></li><li><a href=#headline-81>2015 文件系统</a></li><li><a href=#headline-82>2015 用于并行计算的扩展</a></li><li><a href=#headline-83>2015 事务性内存操作</a></li><li><a href=#headline-84>2015 概念库, 用于优化编译期信息</a></li><li><a href=#headline-85>2016 用于并行计算的扩展</a></li><li><a href=#headline-86>2017 标准库扩展</a></li><li><a href=#headline-87>2017 提供范围机制</a></li><li><a href=#headline-88>2017 协程库扩展</a></li><li><a href=#headline-89>2017 C++17 第五个C++标准</a><ul><li><a href=#headline-90>?? 新功能 ??</a><ul><li><a href=#headline-91>static_assert无需提供出错信息</a></li><li><a href=#headline-92>具有模板形式的模板参数允许使用typename (之前只能使用class)</a></li><li><a href=#headline-93>std::uncaught_excepitions取代std::uncaught_exception</a></li><li><a href=#headline-94>变长参数模板的Folding运算</a></li><li><a href=#headline-95>容器访问操作表示方法的统一化</a></li><li><a href=#headline-96>连续迭代器</a></li><li><a href=#headline-97>新增特殊数学函数</a></li></ul></li><li><a href=#headline-98>语言特性</a><ul><li><a href=#headline-99>u8字面量</a></li><li><a href=#headline-100>使noexcept成为系统的一部分</a></li><li><a href=#headline-101>{}列表初始化的自动推导规则</a></li><li><a href=#headline-102>lambda函数按值捕获this指针</a></li><li><a href=#headline-103>class 构造函数</a></li><li><a href=#headline-104>内联变量 inline</a></li><li><a href=#headline-105>结构化绑定</a></li><li><a href=#headline-106>if/switch选择语句可以带初始化</a></li><li><a href=#headline-107>嵌套的namespace</a></li><li><a href=#headline-108>fallthrough, nodiscard, maybe_unused特性</a></li></ul></li><li><a href=#headline-109>stl</a><ul><li><a href=#headline-110>std::variant</a></li><li><a href=#headline-111>std::optional</a></li><li><a href=#headline-112>std::any</a></li><li><a href=#headline-113>std::string_view</a></li><li><a href=#headline-114>std::filesystem</a></li><li><a href=#headline-115>std::invoke</a></li><li><a href=#headline-116>std::apply</a></li><li><a href=#headline-117>std::byte</a></li><li><a href=#headline-118>maps && sets更优效率的移动节点</a></li><li><a href=#headline-119>并行算法</a></li></ul></li></ul></li><li><a href=#headline-120>2018 网络库</a></li><li><a href=#headline-121>2018 并行扩展</a></li><li><a href=#headline-122>2018 模块</a></li><li><a href=#headline-123>2020 C++20 第五个C++标准</a><ul><li><a href=#headline-124>语言特性</a><ul><li><a href=#headline-125>新增关键字</a></li><li><a href=#headline-126>新增标识符</a></li><li><a href=#headline-127>modules 模块</a></li><li><a href=#headline-128>import头文件</a></li><li><a href=#headline-129>Ranges</a></li><li><a href=#headline-130>协程</a></li><li><a href=#headline-131>Concepts</a></li><li><a href=#headline-132>lambda</a></li><li><a href=#headline-133>constexpr 更新</a></li><li><a href=#headline-134>原子智能指针 Atomic</a></li><li><a href=#headline-135>class 指定初始化</a></li><li><a href=#headline-136>&lt;=> 运算符</a></li><li><a href=#headline-137>范围for循环语句 支持初始化语句</a></li><li><a href=#headline-138>特性测试宏</a></li><li><a href=#headline-139>consteval</a></li><li><a href=#headline-140>constinit</a></li><li><a href=#headline-141>用using引用enum类型</a></li></ul></li><li><a href=#headline-142>stl</a><ul><li><a href=#headline-143>choron 增加日历和时区的支持</a></li><li><a href=#headline-144>std::span</a></li><li><a href=#headline-145>特性测试宏</a></li><li><a href=#headline-146>&lt;version></a></li><li><a href=#headline-147>std::format</a></li></ul></li></ul></li></ul></li><li><a href=#headline-148>设计原则</a></li><li><a href=#headline-149>待学习</a></li></ul></nav></div></div><div class=content id=content><p>通过C++历史, 更好的了解C++特性</p><div id=outline-container-headline-1 class=outline-2><h2 id=headline-1>演变</h2><div id=outline-text-headline-1 class=outline-text-2><div id=outline-container-headline-2 class=outline-3><h3 id=headline-2>1979 诞生</h3><div id=outline-text-headline-2 class=outline-text-3><p>刚开始叫做New C, 后改名C with Classes
诞生目的: 便于大型软件开发 && 运行效率
过 程: 增强C语言特性 (选C原因: C用途广, 快速, 可移植性)
新增特性:</p><ol><li>类别</li><li>衍生类别</li><li>存储类型检查</li><li>内联</li><li>缺省参数</li></ol></div></div><div id=outline-container-headline-3 class=outline-3><h3 id=headline-3>1983 改名C++</h3><div id=outline-text-headline-3 class=outline-text-3><p>新增特性:</p><ol><li>虚拟函数</li><li>函数名</li><li>运算子多载</li><li>参考 ???</li><li>常数</li><li>使用者可控制的自由空间存储区控制</li><li>改良的型别检查</li><li>单行注释 //</li></ol></div></div><div id=outline-container-headline-4 class=outline-3><h3 id=headline-4>1985 发布第一版&lt;&lt;C++程式设计语言>></h3><div id=outline-text-headline-4 class=outline-text-3><p>非官方发布 ?? 这时候有官方了???</p></div></div><div id=outline-container-headline-5 class=outline-3><h3 id=headline-5>1989 发布Release 2.0</h3><div id=outline-text-headline-5 class=outline-text-3><p>新增特性:</p><ol><li>多重继承</li><li>抽象类别</li><li>静态成员函数</li><li>常数成员函数</li><li>成员保护</li></ol></div></div><div id=outline-container-headline-6 class=outline-3><h3 id=headline-6>1990 出版了&lt;&lt;The Annotated C++ Reference Manual>> 标准化基础</h3><div id=outline-text-headline-6 class=outline-text-3><p>??哪一年??稍后还引入了模板例外处理、命名空间、新的强制类型转换，以及布林类型</p></div></div><div id=outline-container-headline-7 class=outline-3><h3 id=headline-7>1998 C++98 第一个C++标准</h3><div id=outline-text-headline-7 class=outline-text-3><p>标准分为 核心语言 && C++标准程序库
C++标准程序库主要包含 STL && C标准库的稍加修改版</p><p>语言特性:</p><ol><li><p>classes 相关</p><ol><li>构造 && 析构</li><li>friend</li><li>继承</li><li>多态</li><li>静态成员</li></ol></li><li>new delete</li><li><p>高级概念 ?? 高级在哪?? 需要对比当时的环境</p><ol><li>模板</li><li>命名空间</li><li>异常</li><li>类型转换
隐式转换 && 显式转换</li></ol></li></ol><p>stl:</p><ol><li>异常 &lt;exception></li><li>类型检查 &lt;typeinfo></li><li>输入输出 &lt;iostream></li></ol></div></div><div id=outline-container-headline-8 class=outline-3><h3 id=headline-8>2003 C++03 第二个C++标准</h3><div id=outline-text-headline-8 class=outline-text-3><p>C++03 主要是在C++98基础上针对实现方的一些问题进行了修复，从而在各个实现间达到一致、保持了可移植性。
该版本共涉及 92 项核心语言缺陷报告、125 项库缺陷报告，所提供的新特性只有一项：值初始化（value initialization）</p><pre class=example>
实现方是指编译器 ??需要重点看一下当时的编译器有哪些??
对于使用者(程序员)来说, C++03与C++98差异不大(只有一条 值初始化)
</pre></div></div><div id=outline-container-headline-9 class=outline-3><h3 id=headline-9>2006 C++性能技术报告</h3></div><div id=outline-container-headline-10 class=outline-3><h3 id=headline-10>2007 C++技术报告: 库扩展</h3></div><div id=outline-container-headline-11 class=outline-3><h3 id=headline-11>2010 数学函数扩展</h3></div><div id=outline-container-headline-12 class=outline-3><h3 id=headline-12>2011 C++11 第三个C++标准</h3><div id=outline-text-headline-12 class=outline-text-3><p>先前被称作C++0x, 本预计2000-2009间会发布, 结果一直拖到了2011年. 因此改名C++11. <a href=https://zh.wikipedia.org/wiki/C%2B%2B11>参考资料</a></p><p>相比于C++03，C++11标准包含核心语言的新机能，
而且扩展C++标准程序库，并入了大部分的C++ Technical Report 1程序库（数学的特殊函数除外)</p><div id=outline-container-headline-13 class=outline-4><h4 id=headline-13>设计原则</h4><div id=outline-text-headline-13 class=outline-text-4><ol><li>维持稳定性和与C++98，可能的话还有C之间的兼容性；</li><li>尽可能不透过核心语言的扩展，而是透过标准程序库来引进新的特性；</li><li>能够演进编程技术的变更优先；</li><li>改进C++以帮助系统以及库设计，而不是引进只针对特别应用的新特性；</li><li>增进类别安全，提供对现行不安全的技术更安全的替代方案；</li><li>增进直接对硬件工作的能力与表现；</li><li>提供现实世界中问题的适当解决方案；</li><li>实行“zero-overhead”原则（某些功能要求的额外支持只有在该功能被使用时才能使用）；</li><li>使C++易于教授与学习</li></ol></div></div><div id=outline-container-headline-14 class=outline-4><h4 id=headline-14>语言变更</h4><div id=outline-text-headline-14 class=outline-text-4><p>C++委员会的主要作用之一是改善语言核心。核心语言将被大幅改善的领域包括</p><ul><li>多线程支持</li><li>泛型编程</li><li>统一的初始化</li><li>以及性能表现的加强</li></ul><p>在此分成4个区块来讨论核心语言的特色以及变更:
执行期表现强化、构造期表现强化、可用性强化，还有新的功能。
某些特性可能会同时属于多个区块，但在此仅于其最具代表性的区块描述</p><div id=outline-container-headline-15 class=outline-5><h5 id=headline-15>执行期表现强化</h5><div id=outline-text-headline-15 class=outline-text-5><p>提升某些性能表现, 像是内存或者速度上的提升</p><div id=outline-container-headline-16 class=outline-6><h6 id=headline-16>右值引用 && std::move && std::forward</h6><div id=outline-text-headline-16 class=outline-text-6><pre class=example>
右值引用是语言特性,  std::move &amp;&amp; std::forward是stl中新增的函数 (头文件&lt;utility&gt;)
符合设计原则2, 使用stl补充语言特性
</pre><p>右值引用的本质是为了解决C++之前版本的深度copy问题. <a href=https://zh.wikipedia.org/wiki/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8>wiki参考资料</a></p><pre class=example>
template &lt;typename T, typename Arg&gt;
shared_ptr&lt;T&gt; factory(Arg arg)
{
return shared_ptr&lt;T&gt;( new T(arg));
}
</pre><pre class=example>
template &lt;typename T, typename Arg&gt;
shared_ptr&lt;T&gt; factory(Arg&amp; arg)
{
return shared_ptr&lt;T&gt;( new T(arg));
}
</pre><pre class=example>
template&lt; typename T, typename Arg&gt;
shared_ptr&lt;T&gt; factory(const Arg&amp; arg)
{
//无法修改arg对象
return shared_ptr&lt;T&gt;( new T(arg));
}
</pre><pre class=example>
template&lt;typename T, typename Arg&gt;
shared_ptr&lt;T&gt; factory(Arg&amp;&amp; arg)
{
return shared_ptr&lt;T&gt;(new T(std::forward&lt;Arg&gt;(arg)));
}

/*
调用时候, 参数如果是左值, 只需要std::move()获取对应的右值
*/
</pre><pre class=example>
//两者都在&lt;utility&gt;头文件
//std::move(arg)       可以获取左值的右值引用
//                     因为右值引用是将原对象的内容移动到新对象, 所以原对象移动后不应再使用
//std::forward&lt;T&gt;(arg) 可以获取arg的T属性.
//                     T如果为int,  则使用arg的右值
//                     T若果为int&amp;, 则使用arg的左值
</pre><p>右值引用使用场景:</p><ol><li>上面的exp所展示的</li><li><p>就是在以传值方式传递对象时隐式发生的耗时且不必要的深度拷贝。
举例而言，std::vector&lt;T>本质上是一个C-style数组及其大小的封装，
如果一个std::vector&lt;T>的临时对象是在函数内部或者函数返回时创建，
要将其存储就只能透过生成新的std::vector&lt;T>并且把该临时对象所有的资料复制过去
然后该临时对象会被析构，其使用的内存会被释放</p><pre class=example>
std::vector&lt;int&gt; test(){
  std::vector&lt;int&gt; vec_data;
   //一些操作
   //...
   //返回vec_data实际是
   //1.创建了一个新的std::vector&lt;int&gt; 临时对象
   //2.把vec_data对象深度copy给 临时对象
   //3.返回临时对象
   //4.销毁vec_data对象
   //
   // 其中深度copy会造成非常大的开销, 导致性能低下
   return vec_data;
}
</pre><pre class=example>
std::vector&lt;int&gt; test(){
  std::vector&lt;int&gt; vec_data;
  //一些操作
  //...
  //
  //1.创建一个新的std::vector&lt;int&gt; 临时对象
  //2.把vec_data对象移动到 临时对象
  //3.返回临时对象
  //4.销毁vec_data对象
  //
  //对比旧版本, 这里少了深度copy这一层
  return std::vector&lt;int&gt; (std::move(vec_data) );
}
</pre></li></ol><p>注意事项</p><ol><li>对象被右值引用后, 再操作会导致不可预知的问题(内存相关信息已被置为null)</li><li>并非所有情形都合适. 应该使用在避免深度copy的场合</li></ol></div></div><div id=outline-container-headline-17 class=outline-6><h6 id=headline-17>constexpr 泛化的常量表达式</h6><div id=outline-text-headline-17 class=outline-text-6><p>constexpr确保对象在编译期完成初始化操作, 因此加快运行期的效率</p><pre class=example>
//const 与 constexpr 均表示该表达式(对象或函数)被声明为常量
//const     不保证对象经历哪种类型的初始化, 可能是编译器初始化, 也可能是运行期初始化
//constexpr 保证对象使用编译器初始化

//const演示
int get_number(){ return 5; }
const int mx = get_number();  //mx是常量对象, 但在运行期获得初始化
int arr[mx] ; //错误. 因为mx是在运行期获得初始化; 而int[]需要编译器的常量

//constexpr演示
constexpr int get_number(){ return 5; }
int arr[get_number()]; //正确. 因为constexpr保证函数get_number调用在编译器初始化
</pre><pre class=example>
//修饰函数表达式
//函数主体必须是非虚拟的，并且除了 typedef 和静态断言之外，仅包含一个 return 语句
constexpr int max() { return 4; } // ok
constexpr long long_max() { return 23423424; } //ok
constexpr bool get_val(){
  bool res = false;
  return res;
} //error: body只能有一个return statement


//修饰变量
//与const类似


//修饰构造函数
//构造函数可以有一个成员初始化列表, 但body必须是空的
//constexpr构造函数 允许编译器在编译时初始化对象, 前提是构造函数的参数都是常量表达式
struct complex
{
  constexpr complex(double r, double i) : re(r), im(i) { } // ok
  double re;
  double im;
}

constexpr complex cx0(0.0, 1.0); //ok. 编译期初始化

double x = 1.0;
constexpr complex cx1(x, 0); //error: x不是常量表达式
const     complex cx2(x, 0); //ok. 运行期初始化

constexpr double xx = 1.0;
constexpr complex cx3(xx, 0); //ok 编译期初始化

complex cx4(1.0, 2.0); //ok 运行期初始化
</pre></div></div><div id=outline-container-headline-18 class=outline-6><h6 id=headline-18>对POD定义的修正</h6><div id=outline-text-headline-18 class=outline-text-6><p>?? 这是什么, 完全没有看懂 ??</p></div></div></div></div><div id=outline-container-headline-19 class=outline-5><h5 id=headline-19>构造期表现强化</h5><div id=outline-text-headline-19 class=outline-text-5><div id=outline-container-headline-20 class=outline-6><h6 id=headline-20>外部模版</h6><div id=outline-text-headline-20 class=outline-text-6><p>在标准C++中，只要在编译单元内遇到被完整定义的模板，编译器都必须将其实例化（instantiate）
这会大大增加编译时间，特别是模板在许多编译单元内使用相同的参数实例化。</p><p>C++11之前, 可以告诉编译器在特定位置开始实例化, 但无法告诉编译器不要引发模板实例化</p><pre class=example>
template class std::vector&lt;MyClass&gt;;
</pre><p>C++11增加了 阻止编译器在编译期间引发模板实例化</p><pre class=example>
extern template class std::vector&lt;MyClass&gt;;
</pre></div></div></div></div><div id=outline-container-headline-21 class=outline-5><h5 id=headline-21>可用性的加强</h5><div id=outline-text-headline-21 class=outline-text-5><div id=outline-container-headline-22 class=outline-6><h6 id=headline-22>初始化列表</h6><div id=outline-text-headline-22 class=outline-text-6><p>初始化列表的构想是 结构(或数组)的成员依据定义的顺序 由一串形参产生.</p><pre class=example>
struct Test{
  int a;
  double b;
  int c;
}

//给予 Test一串形参,  Test的成员根据位置,自动获得初始化
//Test成员a, b, c根据自己在Test结构中定义的顺序, 自动与形参1, 2.0, 3获得匹配的初始化
//即a=1, b=2.0, c=3
Test t1{1, 2.0, 3};
</pre><pre class=example>
//C++11 增加了初始化列表构造函数 std::initializer_list&lt;&gt;
class Test{
public:
  Test(std::initializer_list&lt;int&gt; list); //初始化列表构造函数
}
Test test{1, 2, 3, 4}; //允许Test对象可以像这样初始化


//初始化列表构造函数的优先级大于普通的构造函数
class Test{
public:
  Test(std::initializer_list&lt;int&gt; list); //初始化列表构造函数
  Test(int i): m_i(i) { };               //普通构造函数
private:
  int m_i;
}
//当初始化列表构造函数 与 普通构造函数形参一致的时候,
//如果使用{}初始化, 将调用的是初始化列表构造函数
//比如下面调用的是 Test(std::initializer_list&lt;int&gt; list);
Test test{1};

//如果想调用普通构造函数, 应该使用标准的构造函数语法
//调用的是 Test(init i);
Test test(1);
</pre><pre class=example>
//std::initializer_list除了可以在构造函数中使用, 也可用于普通函数
void Fun(std::initializer_list&lt;int&gt; list);
Fun(1, 2, 3);
</pre></div></div><div id=outline-container-headline-23 class=outline-6><h6 id=headline-23>统一的初始化</h6><div id=outline-text-headline-23 class=outline-text-6><pre class=example>
struct BasicStruct{
  int x;
  float y;
}

struct AltStruct{
  AltStruct(int _x, float _y): x(_x), y(_y) {}
private:
  int x;
  float y;
}

//两者都可以采用一样的初始化样式
BasicStruct val1 {5, 2.1f};
AltStruct   val2 {2, 2.1f};
</pre></div></div><div id=outline-container-headline-24 class=outline-6><h6 id=headline-24>auto && decltype</h6><div id=outline-text-headline-24 class=outline-text-6><p>C++03使用参数必须明确的指出其类别.
然而随着模板类别的出现以及模板元编程的技巧, 某物的类别, 特被是函数定义明确的返回类别, 不容易表示.
C++11提供了auto 自动类别推导, 来解决该问题</p><p>有被明确初始化的参数可以使用auto.
对于指针类型, 使用auto 和 auto*是一样的.
对于引用类型, 必须使用auto&. 因为auto总是推断出非引用类型</p></div></div><div id=outline-container-headline-25 class=outline-6><h6 id=headline-25>基于范围的for循环</h6><div id=outline-text-headline-25 class=outline-text-6><p>简化了for循环. 可以使用在C型数组, 初始化列表, 和任何定义了begin(), end()的类型</p><pre class=example>
int my_array[5] {1, 2, 3, 4, 5};
//每个元素 * 2
//注意这里是auto&amp;, 而非auto
for (auto&amp; x : my_array){
  x *= 2;
}
</pre></div></div><div id=outline-container-headline-26 class=outline-6><h6 id=headline-26>lambda函数表达式</h6></div><div id=outline-container-headline-27 class=outline-6><h6 id=headline-27>返回类别后置的函数声明</h6><div id=outline-text-headline-27 class=outline-text-6><p>?? 看样子, 主要用于模板中函数的返回类别 ??</p></div></div><div id=outline-container-headline-28 class=outline-6><h6 id=headline-28>class对象构造改良</h6><div id=outline-text-headline-28 class=outline-text-6><pre class=example>
//C++11之前, 构造函数不允许调用其他构造函数
//C++11, 取消了该限制, 允许构造函数调用其他构造函数, 这种做法称为委托构造
class SomeType{
public:
  SomeType() : SomeType(0, &#34;hahah&#34;) {}
  SomeType(int i) : SomeType(i, &#34;haha222&#34;) {}
  SomeType(string&amp; s) : SomeType(1, s) { test(); }

private:
  SomeType(int i, string&amp; s): m_i(i), m_s(s) {}

  int m_i;
  string m_s;
};
</pre><pre class=example>
//C++03 基类的构造函数不能直接作为派生类的构造函数, 每个派生类必须实现自己的构造函数
//C++11 取消了该限制. 编译器可以使用基类的构造函数完成派生类的构造
//而将基类的构造函数带入派生类的动作. 无法选择性的部分带入.
//要么全部带入, 要么一个都不带入
class BaseClass{
public:
  BaseClass(int v);
};

class DerivedClass :public BaseClass {
public:
  using BaseClass::BaseClass; //使用基类的构造函数
};
</pre><pre class=example>
//C++03 class 成员变量只能在构造函数中被初始化
//C++11 取消了该限制, 使其可以在声明的地方初始化
class SomeClass{
public:
  SomeClass() {}   //当构造函数中未初始化m_val时, 使用定义的值45
  SomeClass(int i) : m_val(i) {} //如果构造函数中初始化了m_val, 则使用构造函数中的值
private:
  int m_val = 45;
  int m_test {45}; //也可以使用列表初始化的样式
};
</pre></div></div><div id=outline-container-headline-29 class=outline-6><h6 id=headline-29>显示虚函数重载</h6><div id=outline-text-headline-29 class=outline-text-6><pre class=example>
struct Base{
  virtual void func(int);
};

struct Derived : Base{
  virtual void func(int) override;    //ok 显示重载
  virtual void func(float) override;  //error: struct Base中没有对应的虚函数
};
</pre><pre class=example>
struct Base{
  virtual void func(int) final;
};

struct Derived : Base{
  virtual void func(int);  //error: struct Base:func 禁止重载
};
</pre></div></div><div id=outline-container-headline-30 class=outline-6><h6 id=headline-30>空指针</h6><div id=outline-text-headline-30 class=outline-text-6><pre class=example>
//C++11之前, 使用NULL来表示0和空指针 ( C的做法 )
//但是在函数重载时候, 就容易引发歧义
void foo (char*);
void foo (int);
void foo (nullptr_t);
//调用的实际是 void foo(int);  而非void foo(nullptr_t)
foo(NULL)

//C++11引入了nullptr 用来表示指针
//这样调用的就是 void foo(nullptr_t)
foo(nullptr)
</pre></div></div><div id=outline-container-headline-31 class=outline-6><h6 id=headline-31>强类型枚举</h6><div id=outline-text-headline-31 class=outline-text-6><p>?? 不是很明白 这个的意义在哪 ??
?? 枚举不和int比较, 不会很限制使用场景吗 ??</p></div></div><div id=outline-container-headline-32 class=outline-6><h6 id=headline-32>角括号</h6><div id=outline-text-headline-32 class=outline-text-6><p>C++03的分析器一律把 >> 视为右移运算符. 为了避免, 编码时候不能把>>连着写. 尤其在模板编码中
C++11变更了分析器规则, 使其更加智能</p></div></div><div id=outline-container-headline-33 class=outline-6><h6 id=headline-33>显式类别转换 explicit</h6><div id=outline-text-headline-33 class=outline-text-6><p>?? 完全没有印象 ??</p></div></div><div id=outline-container-headline-34 class=outline-6><h6 id=headline-34>模板的别名</h6><div id=outline-text-headline-34 class=outline-text-6><p>?? 对模板 完全不熟悉 ??</p></div></div><div id=outline-container-headline-35 class=outline-6><h6 id=headline-35>模板参数的缺省值</h6></div><div id=outline-container-headline-36 class=outline-6><h6 id=headline-36>无限制的unions</h6><div id=outline-text-headline-36 class=outline-text-6><p>?? 需要详细了解一下 ??</p></div></div></div></div><div id=outline-container-headline-37 class=outline-5><h5 id=headline-37>能力的提升</h5><div id=outline-text-headline-37 class=outline-text-5><p>这些特性让C++语言能够做一些以前做不到的，或者极其复杂的，或者需求一些不可移植的库的事情。</p><div id=outline-container-headline-38 class=outline-6><h6 id=headline-38>可变参数模板</h6><div id=outline-text-headline-38 class=outline-text-6><p>?? 又是模板… ??</p></div></div><div id=outline-container-headline-39 class=outline-6><h6 id=headline-39>字符串字面值</h6><div id=outline-text-headline-39 class=outline-text-6><pre class=example>
//C++03 提供了两种字符串字面值
&#34;abc&#34;   //产生以空字符\0结尾的 const char 数组
L&#34;abc&#34;  //产生以空字符\0结尾的 const wchat_t数组

//C++11加强了对Unicode的支持,
//类别char的定义被修改为其大小至少能够存储UTF-8的8位编码, 并且能够容纳编译器的基本字符集的任何成员
//新增char16_t, char32_t, 分别对应UTF-16, UTF-32
u8&#34;I&#39;m a UTF-8 string.&#34;
u&#34;I&#39;m a UTF-16 string.&#34;
U&#34;I&#39;m a UTF-32 string.&#34;
//并且允许直接在字符串内插入unicode codepoints
// \u之后的是16 bits的十六进制数值;
// \U之后的是32 bits的十六进制数值
u8&#34;This is a Unicode Character: \u2018.&#34;
u&#34;This is a bigger Unicode Character: \u2018.&#34;
u8&#34;This is a Unicode Character: \U00002018.&#34;
</pre><pre class=example>
R&#34;(The String Data \ Stuff &#34; )&#34; //()中的内容不会被转义

//R 可以和 u8/u/U组合使用
u8R&#34;(I&#39;m a &#34;raw UTF-8&#34; string.)&#34;
</pre></div></div><div id=outline-container-headline-40 class=outline-6><h6 id=headline-40>用户定义字面值</h6><div id=outline-text-headline-40 class=outline-text-6><p>C++11开放用户定义新的字面修饰符（literal modifier），利用自定义的修饰符完成由字面值构造对象。</p><p>字面值转换可以定义为两个阶段：原始与转换后（raw与cooked)
原始字面值指特定类型的字符序列，而转换后的字面值则代表另一种类别。
如字面值1234，原始字面值是'1', '2', '3', '4'的字符序列；
而转换后的字面值是整数值1234。另外，字面值0xA转换前是序列'0', 'x', 'A'；转换后代表整数值10。</p><p>?? 如何使用 ??</p></div></div><div id=outline-container-headline-41 class=outline-6><h6 id=headline-41>多线程编程支持</h6><div id=outline-text-headline-41 class=outline-text-6><p>C++标准委员会计划统一对多线程编程的支持. 这将涉及两个部分：</p><ol><li>设计一个可以使多个线程在一个进程中共存的内存模型；</li><li>为线程之间的交互提供支持. 这部分将由程序库提供支持</li></ol><p>在多个线程可能会访问相同内存的情形下，由一个内存模型对它们进行调度是非常有必要的。
遵守模型规则的程序是被保证正确运行的，
但违反规则的程序会发生不可预料的行为，这些行为依赖于编译器的优化和内存一致性的问题。</p><p>虽然C++11会在语言的定义上提供一个内存模型以支持线程，但线程的使用主要将以C++11标准库的方式呈现。
C++11标准库会提供类别thread（std::thread）。若要执行一个线程，可以创建一个类别thread的实体，其初始参数为一个函数对象，以及该函数对象所需要的参数。透过成员函数std::thread::join()对线程会合的支持，一个线程可以暂停直到其它线程执行完毕。若有底层平台支持，成员函数std::thread::native_handle()将可提供对原生线程对象执行平台特定的操作。
对于线程间的同步，标准库将会提供适当的互斥锁（像是std::mutex，std::recursive_mutex等等）和条件参数（std::condition_variable和std::condition_variable_any）。前述同步机制将会以RAII锁（std::lock_guard和std::unique_lock）和锁相关算法的方式呈现，以方便程序员使用。
对于要求高性能，或是极底层的工作，有时或甚至是必须的，我们希望线程间的通信能避免互斥锁使用上的开销。以原子操作来访问内存可以达成此目的。针对不同情况，我们可以透过显性的内存屏障改变该访问内存动作的可见性。
对于线程间异步的传输，C++11标准库加入了以及std::packaged_task用来包装一个会传回异步结果的函数调用。因为缺少结合数个future的功能，和无法判定一组promise集合中的某一个promise是否完成，futures此一提案因此而受到了批评。
更高级的线程支持，如线程池，已经决定留待在未来的Technical Report加入此类支持。更高级的线程支持不会是C++11的一部分，但设想是其最终实现将创建在目前已有的线程支持之上。
std::async提供了一个简便方法以用来执行线程，并将线程绑定在std::future。用户可以选择一个工作是要多个线程上异步的执行，或是在一个线程上执行并等待其所需要的资料。默认的情况，实现可以根据底层硬件选择前面两个选项的其中之一。另外在较简单的使用情形下，实现也可以利用线程池提供支持。</p><p>?? 后期重点查看 ??</p></div></div><div id=outline-container-headline-42 class=outline-6><h6 id=headline-42>thread-local的存储期限</h6></div><div id=outline-container-headline-43 class=outline-6><h6 id=headline-43>使用或禁用对象的默认函数</h6><div id=outline-text-headline-43 class=outline-text-6><pre class=example>
//C++03中, 用户无法精确控制class的默认函数, 比如默认构造函数, 默认复制构造函数, 默认赋值运算符等
//比方说, 要让class不能被copy, 必须将复制构造函数 与 赋值运算符声明为private, 并不去定义他们.
//        这样尝试使用这些为定义的函数会导致编译期或连接器错误
//        但这种手法一点也不理想
//
//C++11允许显示的声明采用或禁用编译器提供的内置函数
//
struct SomeType{
  SomeType() = default; //使用默认的构造函数
};

//
struct NonCopyable{
  //禁用复制构造函数 &amp;&amp; 赋值运算符
  NonCopyable &amp; operator=(const NonCopyable&amp; ) = delete;
  NonCopyable (const NonCopyable&amp; ) = delete;

  NonCopyable () = default;
}
</pre></div></div><div id=outline-container-headline-44 class=outline-6><h6 id=headline-44>long long int类型</h6><div id=outline-text-headline-44 class=outline-text-6><p>在32位系统上，一个long long int是保有至少64个有效比特的整数类别。
C99将这个类别引入了标准C中，目前大多数的C++编译器也支持这种类别。
C++11将把这种类别添加到标准C++中。</p></div></div><div id=outline-container-headline-45 class=outline-6><h6 id=headline-45>静态assertion</h6></div><div id=outline-container-headline-46 class=outline-6><h6 id=headline-46>sizeof运算符可以作用于class的所有成员</h6><div id=outline-text-headline-46 class=outline-text-6><pre class=example>
//C++11之前, sizeof运算符只能用于class的静态成员
//C++11修改为均可使用
struct SomeType{
  OtherType member;
};

sizeof(SomeType::member); //传回OtherType的大小
//?? 如果成员是vector数组, 会是什么样 ??
</pre></div></div><div id=outline-container-headline-47 class=outline-6><h6 id=headline-47>垃圾回收机制</h6><div id=outline-text-headline-47 class=outline-text-6><p>?? 没明白… ??</p></div></div></div></div></div></div><div id=outline-container-headline-48 class=outline-4><h4 id=headline-48>stl变更</h4><div id=outline-text-headline-48 class=outline-text-4><div id=outline-container-headline-49 class=outline-5><h5 id=headline-49>stl组件上的升级</h5><div id=outline-text-headline-49 class=outline-text-5><p>基于C++11新特性, 实现stl的更优</p><ol><li>右值引用和其相关的move支持</li><li>支持UTF-16编码，和UTF-32字符集</li><li>变长参数模板（与右值引用搭配可以达成完美转发（perfect forwarding））</li><li>编译期常量表达式</li><li>Decltype</li><li>显式类别转换子</li><li>使用或禁用对象的默认函数</li></ol></div></div><div id=outline-container-headline-50 class=outline-5><h5 id=headline-50>线程支持</h5></div><div id=outline-container-headline-51 class=outline-5><h5 id=headline-51>多元组类别</h5></div><div id=outline-container-headline-52 class=outline-5><h5 id=headline-52>散列表</h5></div><div id=outline-container-headline-53 class=outline-5><h5 id=headline-53>正则表达式</h5></div><div id=outline-container-headline-54 class=outline-5><h5 id=headline-54>通用智能指针</h5></div><div id=outline-container-headline-55 class=outline-5><h5 id=headline-55>可扩展的随机数功能</h5><div id=outline-text-headline-55 class=outline-text-5><p>?? C++版本的 也太麻烦了把 … ??</p></div></div><div id=outline-container-headline-56 class=outline-5><h5 id=headline-56>包装引用</h5><div id=outline-text-headline-56 class=outline-text-5><p>?? 与模板有关 ??</p></div></div><div id=outline-container-headline-57 class=outline-5><h5 id=headline-57>对函数对象的包装</h5></div><div id=outline-container-headline-58 class=outline-5><h5 id=headline-58>用于元编程的类别属性</h5><div id=outline-text-headline-58 class=outline-text-5><p>?? ?? ??</p></div></div><div id=outline-container-headline-59 class=outline-5><h5 id=headline-59>用于计算函数对象返回类型的统一方法</h5></div><div id=outline-container-headline-60 class=outline-5><h5 id=headline-60>itoa函数</h5><div id=outline-text-headline-60 class=outline-text-5><p>iota 函数可将给定区间的值设定为从某值开始的连续值，
例如将连续十个整数设定为从 1 开始的连续整数（即 1、2、3、4、5、6、7、8、9、10）。</p><pre class=example>
#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;numeric&gt;

std::array&lt;int, 10&gt; ai;
std::iota(ai.begin(), ai.end(), 1);
for(int i: ai){
  std::cout&lt;&lt;i&lt;&lt;&#34; &#34;;//1 2 3 4 5 6 7 8 9 10
}
</pre><p>?? 貌似 作用不大呀 ??</p></div></div></div></div></div></div><div id=outline-container-headline-61 class=outline-3><h3 id=headline-61>2011 十进制浮点数扩展</h3></div><div id=outline-container-headline-62 class=outline-3><h3 id=headline-62>2014 C++14 第四个C++标准</h3><div id=outline-text-headline-62 class=outline-text-3><p>C++14旨在作为C++11的一个小扩展, 主要提供漏洞修复和小的改进. <a href=https://zh.wikipedia.org/wiki/C%2B%2B14>参考资料</a></p><div id=outline-container-headline-63 class=outline-4><h4 id=headline-63>语言特性变更</h4><div id=outline-text-headline-63 class=outline-text-4><div id=outline-container-headline-64 class=outline-5><h5 id=headline-64>泛型的lambda</h5><div id=outline-text-headline-64 class=outline-text-5><p>?? 这是什么玩意 ??</p><pre class=example>
//C++11中, lambda函数的形参必须被声明为具体的类型
//C++14 放宽了这个要求
auto lambda = [](auto x, auto y) { return x + y; }
</pre></div></div><div id=outline-container-headline-65 class=outline-5><h5 id=headline-65>lambda捕获部分中使用表达式</h5><div id=outline-text-headline-65 class=outline-text-5><p>C++11的lambda函数允许通过 [值copy 或 引用] 捕获已在外层作用域声明的变量.
C++14允许lambda成员用任意的被捕获表达式初始化.意味着:</p><ol><li>允许 capture by value-move</li><li>允许任意声明的lambda成员, 而不需要外层作用域有一个具有相应名字的变量.这称为广义捕获.
即使在闭包区域中存在相同的变量也会被新变量覆盖(只是在lambda中被覆盖).
新变量类型由他的初始化表达式推导, 类似与auto</li></ol><pre class=example>
//val新变量不需要特意声明类型, 会根据auto自动推导
//lambda的返回值为1, 说明新变量val成功被初始化
auto lambda = [val = 1]{ return val; }


//另一个例子
auto x = 1;
//lambda捕获中, r是x(外部x)的引用; x是新变量(会在lambda中覆盖外部变量x)
//此处的新变量r为1; 新变量x为10
auto f = [&amp;r=x, x=x*10]{
  ++ r;
  return r + x;
}
//结果是外部变量x被设置为2;  f()返回12
f();
</pre></div></div><div id=outline-container-headline-66 class=outline-5><h5 id=headline-66>函数返回类型推导</h5><div id=outline-text-headline-66 class=outline-text-5><p>C++11允许lambda函数根据return语句的表达式类型推断返回类型;
C++14为一般的函数也提供了这个功能.</p><p>?? 真的完全想不通这种不易阅读的特性 到底有什么用 ??</p></div></div><div id=outline-container-headline-67 class=outline-5><h5 id=headline-67>decltype(auto)</h5><div id=outline-text-headline-67 class=outline-text-5><pre class=example>
const int x = 0;
auto x1 = x; //x1为int类型
decltype(auto) x2 = x; //x2为const int类型

int y =0;
int&amp; y1 = y;
auto y2 = y1; //int类型
decltype(auto) y3=y1; //int&amp;

int&amp;&amp; z =0;
auto z1 = std::move(z); //int
decltype(auto) z2 = std::move(z); //int&amp;&amp;
</pre><pre class=example>
//函数返回类型为int
auto f (const int&amp; i) { return i; }

//函数返回类型为const int&amp;
decltype(auto) g (const int&amp; i) { return i; }
</pre></div></div><div id=outline-container-headline-68 class=outline-5><h5 id=headline-68>constexpr函数放宽限制</h5><div id=outline-text-headline-68 class=outline-text-5><p>C++11对constexpr函数做了严格的限制, 允许的语句非常少(基本就是一条return语句…)
C++14放宽了该限制. 允许constexpr有以下内容:</p><ol><li><p>任何声明, 除了</p><ul><li>static 或 thread_local变量</li><li>没有初始化的变量声明</li></ul></li><li>条件分支语句 if && switch</li><li>所有的循环语句, 包含range for 循环</li><li>表达式可以改变一个对象的值
需要该对象的生命期在声明为constexpr的函数内部开始, 包括对有constexpr声明的任何非const非静态成员函数的调用.</li></ol><p>此外，C++11指出，所有被声明为constexpr的非静态成员函数也隐含声明为const（即函数不能修改*this的值）
C++14中这点已经被删除，非静态成员函数可以为非const</p></div></div><div id=outline-container-headline-69 class=outline-5><h5 id=headline-69>变量模板</h5><div id=outline-text-headline-69 class=outline-text-5><p>C++14之前模板可以是函数模板或类模板
C++14中引入了变量模板</p></div></div><div id=outline-container-headline-70 class=outline-5><h5 id=headline-70>class对象构造优化 (聚合类的成员初始化)</h5><div id=outline-text-headline-70 class=outline-text-5><p>C++11中class的成员变量可以在声明的地方初始化. 但是如果构造函数中未定义该变量, 那么该class就不允许使用聚合初始化;
C++14中放松了这一限制</p><pre class=example>
struct Test{
  int m_x;
  int m_y = 40;

  Test(int x) : m_x(x) {}
};

Test t1{1}; //在C++11中是不允许的, 因为Test的构造函数Test(int x)中未初始化m_y

Test t2{1}; //在C++14中是合法的. m_y会使用默认值40
</pre></div></div><div id=outline-container-headline-71 class=outline-5><h5 id=headline-71>二进制字面量</h5><div id=outline-text-headline-71 class=outline-text-5><p>C++14的数字允许使用二进制形式指定.使用前缀0b或0B.</p></div></div><div id=outline-container-headline-72 class=outline-5><h5 id=headline-72>数字分位符</h5><div id=outline-text-headline-72 class=outline-text-5><p>C++14引入单引号 ' 作为数字分位符号, 使得数值型的字母量更好的可读性.</p><pre class=example>
auto integer_literal = 100&#39;0000;
auto floating_point_literal = 1.797&#39;693&#39;134&#39;862&#39;315&#39;7E+308;
auto binary_literal = 0b0100&#39;1100&#39;0110;
auto silly_example = 1&#39;0&#39;0&#39;000&#39;00;
</pre></div></div><div id=outline-container-headline-73 class=outline-5><h5 id=headline-73>deprecated属性</h5><div id=outline-text-headline-73 class=outline-text-5><p>deprecated属性允许标记不推荐使用的实体，该实体仍然能合法使用，
但会让用户注意到使用它是不受欢迎的，并且可能会导致在编译期间输出警告消息。
deprecated可以有一个可选的字符串文字作为参数，以解释弃用的原因和/或建议替代者。</p><pre class=example>
[[deprecated]] void f();

[[deprecated(&#34;g() is unsafe, use h() instead&#34;)]]
void g();

void test(){
  f(); //warnning: f()已被弃用
  g(); //warnning: g() is unsafe, use h() instead
}
</pre></div></div></div></div><div id=outline-container-headline-74 class=outline-4><h4 id=headline-74>stl变更</h4><div id=outline-text-headline-74 class=outline-text-4><div id=outline-container-headline-75 class=outline-5><h5 id=headline-75>共享的互斥体和锁</h5><div id=outline-text-headline-75 class=outline-text-5><p>C++14增加了一类共享的互斥体和相应的共享锁
起初选择的名字是std::shared_mutex，但由于后来增加了与std::timed_mutex相似的特性，std::shared_timed_mutex成为了更适合的名字</p></div></div><div id=outline-container-headline-76 class=outline-5><h5 id=headline-76>元函数的别名</h5></div><div id=outline-container-headline-77 class=outline-5><h5 id=headline-77>关联容器中的异构查找</h5><div id=outline-text-headline-77 class=outline-text-5><p>C++标准库定义了四个关联容器类。
set和multiset允许用户根据一个值在容器中查找对应的的同类型的值。
map和multimap容器允许用户指定键（key）和值（value）的类型，根据键进行查找并返回对应的值。
然而，查找只能接受指定类型的参数，在map和multimap中是键的类型，而在set和multiset容器中就是值本身的类型。</p><p>C++14允许通过其他类型进行查找，只需要这个类型和实际的键类型之间可以进行比较操作。[
这允许std::set&lt;std::string>使用const char*，或任何可以通过operator&lt; 与std::string比较的类型作为查找的参数。</p><p>为保证向后兼容性，这种异构查找只在提供给关联容器的比较器允许的情况下有效。
标准库的泛型比较器，如std::less&lt;>与std::greater&lt;>允许异构查找</p></div></div><div id=outline-container-headline-78 class=outline-5><h5 id=headline-78>stl自定义字面量</h5><div id=outline-text-headline-78 class=outline-text-5><p>C++11增加了自定义字面量的语言特性. C++14的stl中利用了这个特性
C++14 stl定义了如下字面量后缀</p><ol><li>s 创建各种std::basic_string类型</li><li>h, min, s, ms, us, ns 创建相应的std::chrono::duration时间间隔</li><li>if, i, il 创建std::complex&lt;float>, std::complex&lt;double>, std::complex&lt;long double>复数类型</li></ol><p>这些字面量可以用于编译时的constexpr</p><pre class=example>
//两个s互补干扰, 表示std::basic_string的s只能对字符串字面量操作, 而表示秒的只针对数字.
auto str = &#34;hello world&#34;s;
auto dur = 60s;
auto z   = 99i;
</pre></div></div><div id=outline-container-headline-79 class=outline-5><h5 id=headline-79>通过类型寻址多元组</h5><div id=outline-text-headline-79 class=outline-text-5><p>C++11引入的std::tuple类型允许不同类型的值的聚合体用编译期整型常数索引。
C++14还允许使用类型代替常数索引，从多元组中获取对象。
若多元组含有多于一个这个类型的对象，将会产生一个编译错误</p><pre class=example>
tuple&lt;string, string, int&gt; t(&#34;foo&#34;, &#34;bar&#34;, 7);
int i = get&lt;2&gt;(t);    //i = 7; C++11
int j = get&lt;int&gt;(t);  //j = 7; C++14新增
string s = get&lt;string&gt;(t); //编译错误, 歧义
</pre></div></div><div id=outline-container-headline-80 class=outline-5><h5 id=headline-80>较小的标准库特性</h5><div id=outline-text-headline-80 class=outline-text-5><ol><li>std::make_unique可以像std::make_shared一样使用, 用于产生std::unique_str对象</li><li>std::is_finale用于识别一个class类型是否禁止被继承</li><li>std::integral_constant增加了一个返回常量值的operator()</li><li>全局std::begin/std::end函数之外, 增加了std::cbegin/std::cend函数, 用于返回常量迭代器 constant iterators</li></ol></div></div></div></div></div></div><div id=outline-container-headline-81 class=outline-3><h3 id=headline-81>2015 文件系统</h3></div><div id=outline-container-headline-82 class=outline-3><h3 id=headline-82>2015 用于并行计算的扩展</h3></div><div id=outline-container-headline-83 class=outline-3><h3 id=headline-83>2015 事务性内存操作</h3></div><div id=outline-container-headline-84 class=outline-3><h3 id=headline-84>2015 概念库, 用于优化编译期信息</h3></div><div id=outline-container-headline-85 class=outline-3><h3 id=headline-85>2016 用于并行计算的扩展</h3></div><div id=outline-container-headline-86 class=outline-3><h3 id=headline-86>2017 标准库扩展</h3></div><div id=outline-container-headline-87 class=outline-3><h3 id=headline-87>2017 提供范围机制</h3></div><div id=outline-container-headline-88 class=outline-3><h3 id=headline-88>2017 协程库扩展</h3></div><div id=outline-container-headline-89 class=outline-3><h3 id=headline-89>2017 C++17 第五个C++标准</h3><div id=outline-text-headline-89 class=outline-text-3><p>C++17旨在作为大型扩展. <a href=https://zh.wikipedia.org/wiki/C%2B%2B17>参考资料</a></p><div id=outline-container-headline-90 class=outline-4><h4 id=headline-90>?? 新功能 ??</h4><div id=outline-text-headline-90 class=outline-text-4><div id=outline-container-headline-91 class=outline-5><h5 id=headline-91>static_assert无需提供出错信息</h5></div><div id=outline-container-headline-92 class=outline-5><h5 id=headline-92>具有模板形式的模板参数允许使用typename (之前只能使用class)</h5></div><div id=outline-container-headline-93 class=outline-5><h5 id=headline-93>std::uncaught_excepitions取代std::uncaught_exception</h5></div><div id=outline-container-headline-94 class=outline-5><h5 id=headline-94>变长参数模板的Folding运算</h5></div><div id=outline-container-headline-95 class=outline-5><h5 id=headline-95>容器访问操作表示方法的统一化</h5></div><div id=outline-container-headline-96 class=outline-5><h5 id=headline-96>连续迭代器</h5></div><div id=outline-container-headline-97 class=outline-5><h5 id=headline-97>新增特殊数学函数</h5></div></div></div><div id=outline-container-headline-98 class=outline-4><h4 id=headline-98>语言特性</h4><div id=outline-text-headline-98 class=outline-text-4><div id=outline-container-headline-99 class=outline-5><h5 id=headline-99>u8字面量</h5><div id=outline-text-headline-99 class=outline-text-5><pre class=example>
//C++11的时候, u8可以修饰字符串
//C++17新增了u8可以修饰单个字符
char x = u8&#39;x&#39;;
</pre></div></div><div id=outline-container-headline-100 class=outline-5><h5 id=headline-100>使noexcept成为系统的一部分</h5><div id=outline-text-headline-100 class=outline-text-5><p>?? 需要再仔细的查看 ??
noexcept在C++11中首次加入, 作用是抛出异常, 取代throw ?? 为什么取代throw ??</p><p>C++17中使其成为了系统的一部分 ??什么意思??</p></div></div><div id=outline-container-headline-101 class=outline-5><h5 id=headline-101>{}列表初始化的自动推导规则</h5><div id=outline-text-headline-101 class=outline-text-5><p>具体详见C++11中的说明 <a href=*初始化列表>初始化列表</a></p><pre class=example>
//C++11中会被推导为 std::initializer_list&lt;int&gt;
//C++17中推导为 int
auto x {3};
</pre></div></div><div id=outline-container-headline-102 class=outline-5><h5 id=headline-102>lambda函数按值捕获this指针</h5><div id=outline-text-headline-102 class=outline-text-5><p>C++17之前, lambda只能按引用捕获this指针
C++17允许使用*this捕获对象的副本</p></div></div><div id=outline-container-headline-103 class=outline-5><h5 id=headline-103>class 构造函数</h5><div id=outline-text-headline-103 class=outline-text-5><p>?? 完全没有概念 ??</p><ol><li>编译时 if constexpr</li><li>构造函数lambda</li></ol></div></div><div id=outline-container-headline-104 class=outline-5><h5 id=headline-104>内联变量 inline</h5><div id=outline-text-headline-104 class=outline-text-5><p>过去inline用于函数声明, 现在也可以用于变量声明, 表示函数或定义可定义多次(内容必须完全相同)
这允许在头文件中定义一个内联变量</p></div></div><div id=outline-container-headline-105 class=outline-5><h5 id=headline-105>结构化绑定</h5><div id=outline-text-headline-105 class=outline-text-5><p>变量定义初始化时, 允许形如auto [x,y,z] = expr;
其中expr的 元组类似的对象包括 std::tuple, std::pair, std::array等聚合结构</p><pre class=example>
//例子1
using Coordinate = std::pair&lt;int, int&gt;;
Coordinate origin() { return Coordinate{1,2}; }
const auto [x, y] = origin(); //x=1; y=2

//例子2
std::unordered_map&lt;std::string, int&gt; mapping{
  {&#34;a&#34;, 1},
  {&#34;b&#34;, 2},
  {&#34;c&#34;, 3},
};
for (const auto&amp; [key, value] : mapping:){
   //do something
}
</pre></div></div><div id=outline-container-headline-106 class=outline-5><h5 id=headline-106>if/switch选择语句可以带初始化</h5><div id=outline-text-headline-106 class=outline-text-5><pre class=example>
//例子1
//之前需要放到语句块中限制锁的范围
{
  std::lock_guard&lt;std::mutex&gt; lk(mx);
  if (v.empty()) v.push_back(val);
}
//现在可以直接放到if中
if (std::lock_guard&lt;std::mutex&gt; lk(mx); v.empty()) {
  v.push_back(val);
}


//例子2
//更好的限制了变量的作用域
Foo gadget(args);
switch (auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
}
//vs.现在
switch (Foo gadget(args); auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
}
</pre></div></div><div id=outline-container-headline-107 class=outline-5><h5 id=headline-107>嵌套的namespace</h5><div id=outline-text-headline-107 class=outline-text-5><pre class=example>
//C++17以前
namespace A{
  namespace B{
    namespace C{
      int i;
    }
  }
}

//C++17简化了
namespace A::B::C{
  int i;
}
</pre></div></div><div id=outline-container-headline-108 class=outline-5><h5 id=headline-108>fallthrough, nodiscard, maybe_unused特性</h5><div id=outline-text-headline-108 class=outline-text-5><p>C++17中新增</p></div></div></div></div><div id=outline-container-headline-109 class=outline-4><h4 id=headline-109>stl</h4><div id=outline-text-headline-109 class=outline-text-4><div id=outline-container-headline-110 class=outline-5><h5 id=headline-110>std::variant</h5></div><div id=outline-container-headline-111 class=outline-5><h5 id=headline-111>std::optional</h5></div><div id=outline-container-headline-112 class=outline-5><h5 id=headline-112>std::any</h5></div><div id=outline-container-headline-113 class=outline-5><h5 id=headline-113>std::string_view</h5></div><div id=outline-container-headline-114 class=outline-5><h5 id=headline-114>std::filesystem</h5></div><div id=outline-container-headline-115 class=outline-5><h5 id=headline-115>std::invoke</h5></div><div id=outline-container-headline-116 class=outline-5><h5 id=headline-116>std::apply</h5></div><div id=outline-container-headline-117 class=outline-5><h5 id=headline-117>std::byte</h5></div><div id=outline-container-headline-118 class=outline-5><h5 id=headline-118>maps && sets更优效率的移动节点</h5></div><div id=outline-container-headline-119 class=outline-5><h5 id=headline-119>并行算法</h5><div id=outline-text-headline-119 class=outline-text-5><p>许多stl算法, 如copy, find和sort支持并行执行策略</p></div></div></div></div></div></div><div id=outline-container-headline-120 class=outline-3><h3 id=headline-120>2018 网络库</h3></div><div id=outline-container-headline-121 class=outline-3><h3 id=headline-121>2018 并行扩展</h3></div><div id=outline-container-headline-122 class=outline-3><h3 id=headline-122>2018 模块</h3></div><div id=outline-container-headline-123 class=outline-3><h3 id=headline-123>2020 C++20 第五个C++标准</h3><div id=outline-text-headline-123 class=outline-text-3><p>C++20是一项非常大的改动. <a href="https://zhuanlan.zhihu.com/p/137646370?utm_id=0">参考资料</a></p><div id=outline-container-headline-124 class=outline-4><h4 id=headline-124>语言特性</h4><div id=outline-text-headline-124 class=outline-text-4><div id=outline-container-headline-125 class=outline-5><h5 id=headline-125>新增关键字</h5><div id=outline-text-headline-125 class=outline-text-5><ol><li>concept</li><li>requires</li><li>constinit</li><li>consteval</li><li>co_await</li><li>co_return</li><li>co_yield</li><li>char8_t</li></ol></div></div><div id=outline-container-headline-126 class=outline-5><h5 id=headline-126>新增标识符</h5><div id=outline-text-headline-126 class=outline-text-5><ol><li>import</li><li>module</li></ol></div></div><div id=outline-container-headline-127 class=outline-5><h5 id=headline-127>modules 模块</h5><div id=outline-text-headline-127 class=outline-text-5><p>优点:</p><ol><li>没有头文件</li><li>声明实现仍然可以分离, 但非必要</li><li>可以显示指定哪些导出(类, 函数等)</li><li>不需要头文件重复引入宏 include</li><li>模块之间名称可以相同 不会冲突</li><li>模块只处理一次, 编译更快 (头文件每次引入都需要处理)</li><li>预处理宏只在模块内有效</li><li>模块引入顺序无关紧要 (头文件引入顺序不同,可能发生不同结果)</li></ol><pre class=example>
//创建模块
//export导出模块; 模块的名字是cppcon
export module cppcon;
namespace CppCon{
  auto GetWelcomeHelper() { return &#34;Hello World&#34;; }
  export auto GetWelcome() { return GetWelcomehelper(); }
}

//引用模块
import cppcon;
int main(){
  std::cout &lt;&lt; CppCon::GetWelcome();
}
</pre></div></div><div id=outline-container-headline-128 class=outline-5><h5 id=headline-128>import头文件</h5><div id=outline-text-headline-128 class=outline-text-5><pre class=example>
//隐式的将 iostream 转换为模块
//加速构建, 因为iosteam只会处理一次
//和预编译PCH具有相似的效果 ?? PCH是什么 ??
import &lt;iostream&gt;
</pre></div></div><div id=outline-container-headline-129 class=outline-5><h5 id=headline-129>Ranges</h5><div id=outline-text-headline-129 class=outline-text-5><p>Range代表一串元素或者一串元素中的一段
意义:</p><ol><li>简化语法, 方便使用</li><li>防止begin/end不配对</li><li>使变换/过滤等串联操作成为可能</li></ol><pre class=example>
vector&lt;int&gt; data{11, 22, 33};
sort(begin(data), end(data));
sort(data); //使用Ranges
</pre><pre class=example>
//View: 延迟计算, 不持有, 不改写
//Actions: 即时处理, 改写
//Algorithms: 所有接受begin/end对的算法都可以使用
//View和Ations使用管道符 | 串联

//例子1 串联view
vector&lt;int&gt; data{1,2,3,4,5,6,7,8,9,10};
auto result = data |
              views::remove_if([] (int i) { return i % 2 == 1;}) |
              views::transform([])(int i) { return to_string(i);});
//result = {&#34;2&#34;,&#34;4&#34;,&#34;6&#34;,&#34;8&#34;,&#34;10&#34;};
//注意 以上操作被延迟, 只有便利result的时候才触发


//例子2 串联actions
//排序然后去重
//操作会原地对data进行更改, 然后返回
vector&lt;int&gt; data{4, 3, 4, 1, 8, 0, 8};
vector&lt;int&gt; result = data| actions::sort | actions::unique;


//例子3 过滤和变换
//所有的计算延迟到accumulate累加遍历的时候发生
int total = accumulate( view::ints(1) |  //产生一个无限对整型数列
                        view::transform([] (int i) { return i * i;}) | //平方
                        view::take(10), //取前10个元素
                        0); //累加
</pre></div></div><div id=outline-container-headline-130 class=outline-5><h5 id=headline-130>协程</h5><div id=outline-text-headline-130 class=outline-text-5><p>意义:</p><ol><li>异步I/O</li><li>延迟计算</li><li>事件驱动的程序</li><li>generator</li></ol><pre class=example>
//co_wait    挂起协程, 等待其他计算完成
//co_return  从协程返回 (协程禁用return)
//co_yield   弹出一个值, 挂起协程, 下一次调用继续协程的运行
//for co_await 循环体
</pre></div></div><div id=outline-container-headline-131 class=outline-5><h5 id=headline-131>Concepts</h5><div id=outline-text-headline-131 class=outline-text-5><p>?? 模板相关 ??</p></div></div><div id=outline-container-headline-132 class=outline-5><h5 id=headline-132>lambda</h5><div id=outline-text-headline-132 class=outline-text-5><ol><li>需要显示捕获this变量
C++20之前 [=] 隐式捕获this
C++20开始 需要显示捕获this [=, this]</li><li>模板形式的lambda表达式</li><li>lambda表达式捕获 支持打包展开</li></ol></div></div><div id=outline-container-headline-133 class=outline-5><h5 id=headline-133>constexpr 更新</h5></div><div id=outline-container-headline-134 class=outline-5><h5 id=headline-134>原子智能指针 Atomic</h5><div id=outline-text-headline-134 class=outline-text-5><p>智能指针对于数据读写并非线程安全.
C++20之前, 多线程中使用智能指针, 需要使用mutex控制访问.
C++20新增 atomic&lt;shared_ptr&lt;T>>, atomic&lt;weak_ptr&lt;T>></p></div></div><div id=outline-container-headline-135 class=outline-5><h5 id=headline-135>class 指定初始化</h5><div id=outline-text-headline-135 class=outline-text-5><pre class=example>
struct Data{
  int m_x = 0;
  std::string m_s;
};

Data d{.m_s = &#34;Hellow&#34;};
</pre></div></div><div id=outline-container-headline-136 class=outline-5><h5 id=headline-136>&lt;=> 运算符</h5><div id=outline-text-headline-136 class=outline-text-5><p>三路比较运算符</p><pre class=example>
//类似C的strcmp函数返回-1, 0, 1
//但实际&lt;=&gt;返回的并非int类型, 而是&lt;compare&gt;头中的对象
(a &lt;=&gt; b ) &lt; 0 //如果a&lt;b为true
(a &lt;=&gt; b ) == 0 //如果a==b为true
(a &lt;=&gt; b ) &gt; 0 //如果a&gt;b为true
</pre></div></div><div id=outline-container-headline-137 class=outline-5><h5 id=headline-137>范围for循环语句 支持初始化语句</h5><div id=outline-text-headline-137 class=outline-text-5><p>C++17 if, switch语句支持了初始化语句
C++20 新增for循环语句的支持</p><pre class=example>
for (auto data = GetData(); auto&amp; value : data){
  //do something
}
</pre></div></div><div id=outline-container-headline-138 class=outline-5><h5 id=headline-138>特性测试宏</h5><div id=outline-text-headline-138 class=outline-text-5><p>__has_cpp_attribute(fallthrough)
__cpp_binary_literals
__cpp_chart_t
__cpp_coroutines</p></div></div><div id=outline-container-headline-139 class=outline-5><h5 id=headline-139>consteval</h5><div id=outline-text-headline-139 class=outline-text-5><p>constexpr函数可能编译期执行, 也可以在运行期执行;
consteval只能在编译期执行</p></div></div><div id=outline-container-headline-140 class=outline-5><h5 id=headline-140>constinit</h5><div id=outline-text-headline-140 class=outline-text-5><p>强制指定以常量方式初始化</p><pre class=example>
const char* GetStringDyn() {
  return &#34;dynamic init&#34;;
}
constexpr const char* GetString(bool constInit) {
  return constInit ?
    &#34;constant init&#34; :
    GetStringDyn();
}
constinit const char* a = GetString(true); // ✔
constinit const char* b = GetString(false); // ❌
</pre></div></div><div id=outline-container-headline-141 class=outline-5><h5 id=headline-141>用using引用enum类型</h5><div id=outline-text-headline-141 class=outline-text-5><pre class=example>
enum class CardTypeSuit {
  Clubs,
  Diamonds,
  Hearts,
  Spades
};
//C++20之前
std::string_view GetString(const CardTypeSuit cardTypeSuit) {
switch (cardTypeSuit) {
case CardTypeSuit::Clubs:
  return &#34;Clubs&#34;;
case CardTypeSuit::Diamonds:
  return &#34;Diamonds&#34;;
case CardTypeSuit::Hearts:
   return &#34;Hearts&#34;;
case CardTypeSuit::Spades:
   return &#34;Spades&#34;;
  }
}
//C++20
std::string_view GetString(const CardTypeSuit cardTypeSuit) {
switch (cardTypeSuit) {
   using enum CardTypeSuit; // 这里
   case Clubs: return &#34;Clubs&#34;;
   case Diamonds: return &#34;Diamonds&#34;;
   case Hearts: return &#34;Hearts&#34;;
   case Spades: return &#34;Spades&#34;;
  }
}
</pre></div></div></div></div><div id=outline-container-headline-142 class=outline-4><h4 id=headline-142>stl</h4><div id=outline-text-headline-142 class=outline-text-4><div id=outline-container-headline-143 class=outline-5><h5 id=headline-143>choron 增加日历和时区的支持</h5></div><div id=outline-container-headline-144 class=outline-5><h5 id=headline-144>std::span</h5><div id=outline-text-headline-144 class=outline-text-5><p>某段连续数据的视图
不持有数据, 不分配和销毁数据
copy非常快
不支持数据跨步
可通过运行期确定长度, 也可编译期确定长度</p></div></div><div id=outline-container-headline-145 class=outline-5><h5 id=headline-145>特性测试宏</h5><div id=outline-text-headline-145 class=outline-text-5><p>__cpp_lib_conceps
__cpp_lib_ranges
__cpp_lib_scoped_lock</p></div></div><div id=outline-container-headline-146 class=outline-5><h5 id=headline-146>&lt;version></h5><div id=outline-text-headline-146 class=outline-text-5><p>包含c++标准库版本, 发布日期, 版权证书, 特性宏等</p></div></div><div id=outline-container-headline-147 class=outline-5><h5 id=headline-147>std::format</h5><div id=outline-text-headline-147 class=outline-text-5><p>?? C++ 也有format了 …. ??</p></div></div></div></div></div></div></div></div><div id=outline-container-headline-148 class=outline-2><h2 id=headline-148>设计原则</h2><div id=outline-text-headline-148 class=outline-text-2><ol><li>C++设计成直接的和广泛的支援多种程式设计风格（过程化程式设计、数据抽象、物件导向程式设计、泛型程式设计）。</li><li>C++设计成给程式设计者更多的选择，即使可能导致程式设计者选择错误。</li><li>C++设计成尽可能与C相容，借此提供一个从C到C++的平滑过渡。</li><li>C++避免平台限定或没有普遍用途的特性。</li><li>C++不使用会带来额外开销的特性。</li><li>C++设计成无需复杂的程式设计环境。</li></ol></div></div><div id=outline-container-headline-149 class=outline-2><h2 id=headline-149>待学习</h2><div id=outline-text-headline-149 class=outline-text-2><ol><li>stl
C++中很重要的功能, 必须要尽快了解常用的</li><li>新的概念
C++20中增加了很多新概念</li><li>新的语言特性
只需要学习常用的特性, 有些特性是为了配合模板而来的, 暂时不需要学习</li><li>其他常用的库
比如网络库Asio, 格式库protobuf</li><li>模板
模板的作用 更多的是用在stl的编写上, 日常开发使用的比较少, 可以暂时先不学习</li></ol></div></div></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-04-12</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/tool/calibre/ class=prev rel=prev title="calibre 图书管理软件"><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>calibre 图书管理软件</a>
<a href=/posts/tool/hugo/ class=next rel=next title=hugo搭建blog>hugo搭建blog<i class="fas fa-angle-right fa-fw" aria-hidden=true></i></a></div></div></article></div></main></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:20,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>