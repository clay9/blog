<!doctype html><html lang=zh-CN><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><title>emacs - 飘</title><meta name=Description content="This is my cool site"><meta property="og:title" content="emacs">
<meta property="og:description" content="Legalese This is a short example of a complete Texinfo file, version 1.0. Copyright © 2016 Free Software Foundation, Inc. 简述 emacs是什么 emacs最原始,最纯粹的功能: text editor 也可以作为优秀的 prog editor 一款不错的文本gtd软件"><meta property="og:type" content="article"><meta property="og:url" content="https://www.wcq.life/posts/emacs/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-09T22:54:00+00:00"><meta property="article:modified_time" content="2023-12-15T14:39:38+00:00"><meta property="og:site_name" content="My cool site"><meta name=twitter:card content="summary"><meta name=twitter:title content="emacs"><meta name=twitter:description content="Legalese This is a short example of a complete Texinfo file, version 1.0. Copyright © 2016 Free Software Foundation, Inc. 简述 emacs是什么 emacs最原始,最纯粹的功能: text editor 也可以作为优秀的 prog editor 一款不错的文本gtd软件"><meta name=application-name content="My cool site"><meta name=apple-mobile-web-app-title content="My cool site"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://www.wcq.life/posts/emacs/><link rel=prev href=https://www.wcq.life/posts/rup/><link rel=stylesheet href=/css/style.min.css><link rel=preload href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.1.1/css/all.min.css></noscript><link rel=preload href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css as=style onload='this.onload=null,this.rel="stylesheet"'><noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@4.1.1/animate.min.css></noscript><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"emacs","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/www.wcq.life\/posts\/emacs\/"},"genre":"posts","keywords":"gnu","wordcount":10912,"url":"https:\/\/www.wcq.life\/posts\/emacs\/","datePublished":"2023-11-09T22:54:00+00:00","dateModified":"2023-12-15T14:39:38+00:00","publisher":{"@type":"Organization","name":""},"author":{"@type":"Person","name":"wcq"},"description":""}</script></head><body data-header-desktop=fixed data-header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"light"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"light"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/ title=飘>飘</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/posts/>所有文章 </a><a class=menu-item href=/categories/>分类 </a><a class=menu-item href=/tags/>标签 </a><a class=menu-item href=/about>关于 </a><span class="menu-item delimiter"></span><span class="menu-item search" id=search-desktop>
<input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i>
</span></span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/ title=飘>飘</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw" aria-hidden=true></i>
</a><a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw" aria-hidden=true></i>
</a><span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin" aria-hidden=true></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/posts/ title>所有文章</a><a class=menu-item href=/categories/ title>分类</a><a class=menu-item href=/tags/ title>标签</a><a class=menu-item href=/about title>关于</a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw" aria-hidden=true></i></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animate__animated animate__flipInX">emacs</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=/ title=Author rel=author class=author><i class="fas fa-user-circle fa-fw" aria-hidden=true></i>wcq</a></span>&nbsp;<span class=post-category>收录于 <a href=/categories/editor/><i class="far fa-folder fa-fw" aria-hidden=true></i>editor</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw" aria-hidden=true></i>&nbsp;<time datetime=2023-11-09>2023-11-09</time>&nbsp;<i class="fas fa-pencil-alt fa-fw" aria-hidden=true></i>&nbsp;约 10912 字&nbsp;
<i class="far fa-clock fa-fw" aria-hidden=true></i>&nbsp;预计阅读 22 分钟&nbsp;</div></div><div class="details toc" id=toc-static data-kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right" aria-hidden=true></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><ul><li><a href=#legalese>Legalese</a></li><li><a href=#简述>简述</a><ul><li><a href=#emacs是什么>emacs是什么</a></li><li><a href=#日常使用功能>日常使用功能</a></li></ul></li><li><a href=#emacs-程序>emacs-程序</a></li><li><a href=#text-editor>text editor</a><ul><li><a href=#show>show</a></li><li><a href=#move-and-kill>move-and-kill</a></li><li><a href=#hide-show>hide-show</a></li></ul></li><li><a href=#completion>completion</a></li><li><a href=#prog-editor>prog editor</a></li><li><a href=#org与gtd>org与GTD</a><ul><li><a href=#org-mode>org mode</a></li><li><a href=#gtd>GTD</a></li><li><a href=#org-mode怎么实现gtd>org mode怎么实现GTD</a></li></ul></li><li><a href=#键位设置>键位设置</a><ul><li><a href=#设计思路>设计思路</a></li><li><a href=#快捷键>快捷键</a></li></ul></li><li><a href=#待整理-tools>TODO 待整理 &ndash; tools</a><ul><li><a href=#eshell>eshell</a></li><li><a href=#elisp>elisp</a></li><li><a href=#tramp>tramp</a></li><li><a href=#graph>graph</a></li><li><a href=#mail>mail</a></li><li><a href=#gdb-and-and-gud>gdb && gud</a></li><li><a href=#ai-code-assistants>AI Code Assistants</a></li></ul></li></ul></li></ul></nav></div></div><div class=content id=content><h2 id=legalese>Legalese</h2><p>This is a short example of a complete Texinfo file, version 1.0. Copyright © 2016 Free Software Foundation, Inc.</p><h2 id=简述>简述</h2><h3 id=emacs是什么>emacs是什么</h3><ol><li>emacs最原始,最纯粹的功能: text editor</li><li>也可以作为优秀的 prog editor</li><li>一款不错的文本gtd软件</li><li>简单好用的tramp, shell, graph等软件</li></ol><p>综上, emacs其实更像一个大杂烩, 整合了大多数功能, 使其可以高效的完成任务. 同时, 因为良好的定制性, emacs可以增强个人使用体验, 但也增加了很多学习成本</p><h3 id=日常使用功能>日常使用功能</h3><table><thead><tr><th>具体事务</th><th>所用emacs功能</th></tr></thead><tbody><tr><td>文本编辑</td><td></td></tr><tr><td>代码编写, c++, elisp, shell, docker&mldr;</td><td></td></tr><tr><td>gtd</td><td>org-agenda-mode</td></tr><tr><td>blog</td><td>org-mode && hugo</td></tr><tr><td>其他杂项</td><td></td></tr></tbody></table><h2 id=emacs-程序>emacs-程序</h2><p>emacs作为程序最基本的配置. 比如frame, window, mode-line的显示与控制等.</p><h2 id=text-editor>text editor</h2><p>文本编辑器是emacs最原始, 最纯粹, 最重要的功能. 大部分配置都是在处理该项, 使其更符合个人习惯. 配置繁琐, 但不复杂</p><h3 id=show>show</h3><p>text editor最基本的配置, 文本在buffer中显示的样子. 比如行号, break-line, column indicator等</p><h3 id=move-and-kill>move-and-kill</h3><p>即是text editor, 也是emacs最基础的操作. delete, kill, yank, select. 这是emacs中最基础的操作</p><h3 id=hide-show>hide-show</h3><p>hide, show 方便控制sexp的显示隐藏</p><h2 id=completion>completion</h2><p>text editor的配置使我们可以高效的编辑文本. 而completion则可以使emacs更聪明的理解我们的动作.</p><p>emacs有非常多的completion前端和后端, 也有前后端大杂烩. 没必要都了解, 选一个常用的即可.</p><p>completion流程: complete根据我们动作提供候选者 -> 前端显示候选者 -> 我们选择合适的候选 流程本身非常简单, 涉及到的package也很少, 比较复杂的是候选者的提供, 而这个不需要我们自己去做. 现在的方案 ([2023-11-01 Wed]): consult提供候选, vertico && corfu作为前端显示, marginalia补充候选者信息, orderless提供选择规则. embark提供对候选者的操作.</p><p>几个package提供了功能的最小合集, 且与emacs兼容性良好. 因此不再建议使用helm等大杂烩包 其他一些package也是在提供候选, 比如yasnippet, eglot, copilot等. 只是因为针对的场景不同, 所以暂时不再这里介绍</p><h2 id=prog-editor>prog editor</h2><p>emacs可以配置为优秀的IDE. 而且因为定制性强, 配置的IDE更能符合个人的工作流程. 合格的IDE需要有以下功能: 编辑, 编译, 调试, <del>发布</del></p><p>我常遇到的工作场景是这样的: 工程项目在本地mac, 项目运行编译环境在mac的docker容器中. <del>1. 通过lsp server连接编译环境与mac emacs. 这样在mac emacs上编辑, 也会有运行环境的信息, 方便排错与completion</del> <del>2. 需要编译的时候, 直接remote compile, 并在mac emacs接收编译错误</del> <del>3. 调试使用gdb的远程调试. (TODO: 待处理. 最近很少使用到调试功能了)</del> 使用tramp到远端, 可以直接调用远端的环境, 比如compile, lsp(eglot, clangd), gdb(这个未测试).</p><p>emacs内置了lsp client: eglot. 而且eglot与错误处理flymake搭配良好. eglot可以把lsp server中的错误信息给到flymake, completion信息给到corfu(实际是给到emacs completion通用接口), symbol信息给到xerf</p><p>emacs本身有对local compile的支持, 可以使用ppcompile来增加到对remote compile的处理</p><p>实际上, 对于我的工作场景, emacs有不止一种处理手段, 比如可以直接tramp到docker project来处理. 因此选择适合的就行.</p><h2 id=org与gtd>org与GTD</h2><h3 id=org-mode>org mode</h3><p>org-mode一直被称为神器</p><p>主要有2大功能, 一是自身强大的文本模式, 另一个则是org-agenda</p><p>推荐阅读: <a href=http://doc.norang.ca/org-mode.html target=_blank rel="noopener noreffer">org心得体会</a></p><h4 id=配置>配置</h4><p>org作为文本模式配置较少, 更多的配置是为了org-agenda.</p><p>org文本模式下, <a href=https://github.com/clay9/emacs.d/blob/master/lisp/init-org-mode.el target=_blank rel="noopener noreffer">可以配置一下简单的外观</a>. 比如org-bullets. org-bullets更改了heading的图标, 更改了折叠的block样式为⤵. 显示更为美观</p><p>org-agenda的配置可以参考<a href=https://github.com/clay9/emacs.d/blob/master/lisp/init-org-agenda-mode.el target=_blank rel="noopener noreffer">init-org-agenda.el</a>和<a href=https://github.com/clay9/emacs.d/blob/master/lisp/fun/init-org-agenda-fun.el target=_blank rel="noopener noreffer">一系列自定义函数</a></p><h4 id=使用>使用</h4><ul><li><p>基本语法</p><ul><li><p>语法: time-stamp选择</p><p>添加time-stamp时, 不要在calendar中移动,效率太低 使用以下2种方式即可:</p><ol><li>使用简约的时间格式 17-1-1 => 2017-01-01</li><li>使用时间间隔 now = [2016-12-28 Wed] +1d => 2016-12-29</li></ol><p>具体见(dir) - Org mode - Dates and times - Creating timestamps - The date/time promt</p></li></ul><ul><li><p>语法: 时间repeate</p><p>org-mode repeate格式</p><ul><li><p>.+ ++区别</p></li><li><p>&ldquo;+&rdquo; backlog 可以积压的item</p></li><li><p>&ldquo;.+&rdquo; specific date, no backlog 在特定日期完成的item ep: call mother 每周六给mother打电话, 不可积压(或者说现在的操作不会影响之前)</p></li><li><p>&ldquo;++&rdquo; specific interval, no backlog 在特定间隔完成的item ep: change batteries 每隔1月更换电池, 不可积压</p></li></ul></li></ul><ul><li><p>语法: table计算</p><p>@ 表示行； $表示列 &lt; 表示第一; > 表示最后；</p><p>例子: @&lt; 第一行 $> 最后一列 @&lt;&lt; 第二行(更建议使用 @2)</p><p>对table使用C-c} 可以查看行列值</p></li></ul></li></ul><h4 id=9efc12><del>导出 与 org-info</del></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>org-info已弃用, 不再推荐, 建议使用gnu texinfo或者ox-hugo
</span></span></code></pre></div><p>org-mode有强大的导出功能, 具体可以参考官方文档.</p><p>这里只是介绍一下org-info.js</p><p>org-info.js 可以输出info-style xhtml, 可以作为org-mode导出html中的一种css样式补充 <a href=https://orgmode.org/worg/code/org-info-js/ target=_blank rel="noopener noreffer">官方文档</a></p><p>可以在info(m), over-view(m), ppt(x)三种模式间切换. (说实话, ppt模式, 真的没啥效果:)</p><p>拥有众多的属性值, 方便导出配置</p><ul><li>path org-info.js脚本所在路径, 可以是绝对路径或相对路径, 但必须是目录 如果没有设置, 则默认从orgmode.org中读取 publish , export均生效</li><li>home 整个org-file的根节点, 对应界面上的"HOME"按钮<ol><li>export 时候, 设置有效</li><li>publish的时候, 设置无效</li></ol></li><li>up 整个org-file的上层节点,对应界面上的"UP"按钮 TODONOW 暂时不知道作用, 不设置正常使用, 界面上没有"UP"按钮</li><li>view html显示样式</li><li>toc 整个org-file是否显示content publish时候 设置无效</li><li>ltoc sub-heading是否显示content publish时候 设置无效</li><li>mouse 鼠标样式</li><li>buttons</li></ul><p>拥有简单的快捷键, 方便在文档node间移动. n, p, m, x, i, ?</p><p>org-info为org-mode自带, 无须额外安装. 使用的时候, 只需指定属性然后导出即可</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>#+INFOJS_OPT: home:http://wcq.life
</span></span><span class=line><span class=cl>#+INFOJS_OPT: view:info toc:t ltoc:t mouse:underline buttons:nil
</span></span></code></pre></div><p>org-file中的连接会被自动转换为html中的连接</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl># org-file:
</span></span><span class=line><span class=cl>file:test.org
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>在html中被转为
</span></span><span class=line><span class=cl>link:test.html
</span></span></code></pre></div><h4 id=42a572><del>MobileOrg</del></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>已弃用, 不再推荐, 建议使用iphone自带软件
</span></span></code></pre></div><p>方案流程</p><ol><li>PC端配置MobileOrg 具体见.emacs</li><li>寻找WebDAV server 现在使用的是坚果云</li><li>curl同步PC端到webDAV server 这一块非常纠结 起初使用的ssh的scp,发现scp貌似不支持https? 后来使用了curl, 结果发现curl不支持目录的上传&mldr;.. 导致.emacs中mobileorg的配置十分难看, 有机会应该改掉这块! 方法有2:<ol><li>换一种工具取代curl &ndash; 更倾向于这一种方式</li><li>使用regular expression &ndash; 貌似curl支持的不好</li></ol></li></ol><p>总览图</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>+-----------+ push          +--------------+
</span></span><span class=line><span class=cl>| PC端      |--------------&gt;| WwbDAV server|
</span></span><span class=line><span class=cl>|           |&lt;--------------|              |
</span></span><span class=line><span class=cl>+-----------+ pull          +--------------+
</span></span><span class=line><span class=cl>                                |      ^
</span></span><span class=line><span class=cl>                                |      |
</span></span><span class=line><span class=cl>                                |      |
</span></span><span class=line><span class=cl>                                v      |
</span></span><span class=line><span class=cl>                            +--------------+
</span></span><span class=line><span class=cl>                            | Mobile       |
</span></span><span class=line><span class=cl>                            |              |
</span></span><span class=line><span class=cl>                            +--------------+
</span></span></code></pre></div><h3 id=gtd>GTD</h3><h4 id=为什么要用gtd>为什么要用GTD</h4><p>每天或每周需要处理的事情非常之多, 小到晚上要洗衣服, 大到明天项目交付. 这些事情如果都存储在脑中, 轻则 焦虑不堪, 重则脑子爆炸. 而且脑中一旦塞满了这类事情, 非常不利于思考. 大脑应该是拿来思考的, 而不是用来存 储的. 假设一种情形, 大脑只用来思考, 而存储则放在大脑之外, 那么我们就不必因当下之外的事情而焦虑, 能够更 专一的处理当下的问题. 同时, 如果外在存储能够提醒我们何时该思考何问题, 那么我们也不会因错过了某事而悔恨 ,比如女友生日. 而这也是GTD的目的所在, 大脑只用来思考, 存储在脑外.</p><h4 id=gtd是什么>GTD是什么</h4><ul><li><p>人生5楼</p><p>了解GTD之前, 必须了解人生5楼.</p><table><thead><tr><th>楼数</th><th>功能</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>5楼</td><td>人生规划</td><td></td><td></td></tr><tr><td>4楼</td><td>3年目标</td><td></td><td></td></tr><tr><td>3楼</td><td>1年目标</td><td></td><td></td></tr><tr><td>2楼</td><td>职责范围</td><td></td><td></td></tr><tr><td>1楼</td><td>项目</td><td></td><td>GTD管理</td></tr><tr><td>地面</td><td>行动清单</td><td>归属1楼</td><td>GTD管理</td></tr></tbody></table><p>把人生(或部分人生)比喻成一座大厦, 1楼是我们当下要做的事情, 2楼是我们的职责范围, 3楼是我们1年后的样 子, 4楼是我们3年后的样子, 5楼是我们人生(10年, 20年或一辈子)的规划.</p><p>我们的人生是高层决定了低层. 比如, 如果想成为计算机专家(5楼), 那么3年后要先成为工程师(4楼), 1年后 要先成为程序员(3楼). 为了要成为程序员, 也许我们需要去报班学习(2楼职责为学习),或者成为程序员助理(2楼职 责为搬砖). 而1楼则是我们当下要确确实实需要处理的事情, 比如看书, 工作, 与同事交流等, 所有一切能对我们有 提升的事情.</p><p>大厦是由低到高建造的. 千里之行, 始于足下. 1楼的行为直接决定了能否达到后面的楼层.</p><p>大厦最难的地方不在于实现5楼的规划, 而在于制定5楼的规划. 不过这也正是人生的魅力所在吧.</p></li></ul><ul><li><p>GTD是什么</p><p>GTD全名Getting things done, 它只是一种思想, 所能管理的是大厦的1楼. 它的核心目的: 事物存储在脑外, 大脑用来思考.</p><p>GTD的工作流程(算法)甚至文件(结构)都是可以自定义的. 适合的才是最好的.</p><p>吐槽: 中文译本《Getting things done》满篇废话.</p></li></ul><h4 id=gtd怎么实现>GTD怎么实现</h4><p>GTD的实现方式非常之多, 有很多软件工具. 最喜欢的还是org-mode(emacs 插件).</p><h3 id=org-mode怎么实现gtd>org mode怎么实现GTD</h3><h4 id=需求分析>需求分析</h4><p>所有的设计都是基于需求的, 应该先有需求, 再去设计. 当前的需求:</p><ol><li>有哪些task<ul><li><p><i class="far fa-check-square fa-fw" aria-hidden=true></i> 他们归属于哪个PROJECT</p></li><li><p><i class="far fa-check-square fa-fw" aria-hidden=true></i> 他们的四象限: 紧急&&重要</p></li><li><p><i class="far fa-check-square fa-fw" aria-hidden=true></i> 工作量预估</p></li><li><p><i class="far fa-square fa-fw" aria-hidden=true></i> 关联性 A task可能与B, C相关联</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>TODO 该任务并未完成
</span></span></code></pre></div></li></ul></li><li>当前正在处理的任务 尽可能的关注当前, 忽略其他</li><li>当某个task进行时, 快速capture我的想法, 并且自动refile</li><li>看到自己花费的时间<ul><li><i class="far fa-check-square fa-fw" aria-hidden=true></i> 一天,一周都做了什么</li><li><i class="far fa-check-square fa-fw" aria-hidden=true></i> 某个PROJECT总共花费的时间</li></ul></li></ol><h4 id=思路的设计>思路的设计</h4><p>5楼 到 地面视角</p><table><thead><tr><th>楼数</th><th>功能</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>5楼</td><td>人生规划</td><td></td><td></td></tr><tr><td>4楼</td><td>3年目标</td><td></td><td></td></tr><tr><td>3楼</td><td>1年目标</td><td></td><td></td></tr><tr><td>2楼</td><td>职责范围</td><td></td><td></td></tr><tr><td>1楼</td><td>项目</td><td></td><td>GTD管理</td></tr><tr><td>地面</td><td>行动清单</td><td>隶属1楼</td><td>GTD管理</td></tr></tbody></table><p>备注 : GTD管理的其实是 1楼 && 地面的清单</p><h4 id=流程的设计>流程的设计</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>-------------------------+------------------------
</span></span><span class=line><span class=cl>                         |
</span></span><span class=line><span class=cl>                         | capture (easy)
</span></span><span class=line><span class=cl>                         |
</span></span><span class=line><span class=cl>                         |
</span></span><span class=line><span class=cl>                         v
</span></span><span class=line><span class=cl>     archive        +---------+
</span></span><span class=line><span class=cl>+-------------------|  inbox  |
</span></span><span class=line><span class=cl>|                   +----+----+
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>|                        | refile (auto)
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>|                        |
</span></span><span class=line><span class=cl>|       |----------------+--------------------|
</span></span><span class=line><span class=cl>|       |                |                    |
</span></span><span class=line><span class=cl>|       |                v                    v
</span></span><span class=line><span class=cl>|       v           +---------+          +---------+
</span></span><span class=line><span class=cl>|  +---------+      | my/emacs|          | work/qy |
</span></span><span class=line><span class=cl>|  |  task   |      |  * emacs|          |  * ker  |
</span></span><span class=line><span class=cl>|  +----+----+      |  * org  |          |  * frame|
</span></span><span class=line><span class=cl>|       |           |  * ccIDE|          |  * sub  |
</span></span><span class=line><span class=cl>|       |           +---------+          +---------+
</span></span><span class=line><span class=cl>|       |
</span></span><span class=line><span class=cl>|       | archive (auto)
</span></span><span class=line><span class=cl>|       |
</span></span><span class=line><span class=cl>|       v
</span></span><span class=line><span class=cl>|  +---------+
</span></span><span class=line><span class=cl>+-&gt;| archive |
</span></span><span class=line><span class=cl>   +----+----+
</span></span></code></pre></div><h4 id=文件的设计>文件的设计</h4><p>区分目录是为了更好的给PROJECT做分类处理, 使后续的统计查看更方便. 比如org-agenda `R统计时间</p><p>gtd_common中保存的是一些通用的, 可能暂时不好归类的PROJECT以及一系列TODO任务.</p><p>而gtd_emacs与gtd_qygame则是已经明确分类的PROJECT. 比如gtd_emacs/emacs.org明确的是与emacs有关的任务. 但即使都是emacs相关, 也可分为是emacs自身, org, 还是cc-IDE. 所以emacs.org中实际包含了上面三个PROJECT: emacs, org, ccIDE</p><table><thead><tr><th>目录</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>gtd_common</td><td>通用gtd流程文件</td><td>inbox.org</td></tr><tr><td></td><td></td><td>task.org</td></tr><tr><td></td><td></td><td>archive.org</td></tr><tr><td>gtd_emacs</td><td>emacs project files</td><td></td></tr><tr><td>gtd_qygame</td><td>qygame project files</td><td></td></tr></tbody></table><table><thead><tr><th>文件名</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>inbox.org</td><td>收集箱</td><td>不区分时间, 不区分场景</td></tr><tr><td></td><td></td><td>灵光一闪即可扔进去保存</td></tr><tr><td>task.org</td><td>任务清单</td><td>1. priority标签</td></tr><tr><td></td><td>task</td><td>2. 四象限约束</td></tr><tr><td></td><td>项目清单</td><td>1. 凡是steps>1的都属于项目</td></tr><tr><td></td><td>project</td><td></td></tr><tr><td>archive.org</td><td>参考资料</td><td>1. 有参考价值的东西</td></tr><tr><td></td><td></td><td>2. 垃圾箱</td></tr></tbody></table><p>备注:</p><ol><li>task 与 project的唯一区别 task只有one step, project的steps > 1</li><li>文件都是通过流程来操作的, 不应该手动去干预</li><li>没增加一个工程, 应该增加一个对应的gtd_xx目录</li></ol><h4 id=todo的设计>TODO的设计</h4><table><thead><tr><th>名称</th><th>功能</th><th>备注</th></tr></thead><tbody><tr><td>TODO</td><td>等待自己处理</td><td></td></tr><tr><td>WAITTING</td><td>等待他人完成</td><td></td></tr><tr><td>DONE</td><td>完成</td><td></td></tr><tr><td>CANCEL</td><td>取消</td><td></td></tr></tbody></table><p>备注:</p><ol><li>针对的对象是下一步行动清单</li><li>project中的下一步行动即是最上层的行动; task中的下一步行动是依据四象限法则来确定的.</li><li>TODO与WAITTING的含义, 表示该行动正在或即将处理</li></ol><h4 id=tags的设计>TAGS的设计</h4><p>四象限使用proirity来区分; TAGS为之后快速查找使用</p><h4 id=property的设计>PROPERTY的设计</h4><p>当前主要使用的字段</p><ol><li>P_UUID PROEJCT item的标志, 主要影响auto refile</li><li><del>HIDE_WHEN_STUCK</del> <del>PROJECT item的属性, 控制了是否在agenda中显示</del> <del>有些PROJECT是长久开启的, 不会关闭. 比如emacs</del> <del>当这类PROJECT没有task时, 就变成了STUCK项目. 但我们并不希望将这类PROJECT在agenda中显示.</del> <del>所以有了HIDE_WHEN_STUCK.</del><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>+------------+----------------+
</span></span><span class=line><span class=cl>|  not stuck |  stuck project |
</span></span><span class=line><span class=cl>|            |                |
</span></span><span class=line><span class=cl>|            |   +---+        |
</span></span><span class=line><span class=cl>|            |   |   |        |
</span></span><span class=line><span class=cl>|            |   |   +--------+--------&gt; stuck but also hide
</span></span><span class=line><span class=cl>|            |   +---+        |          HIDE_WHEN_STUCK
</span></span><span class=line><span class=cl>|            |                |
</span></span><span class=line><span class=cl>|            |                |
</span></span><span class=line><span class=cl>+------------+----------------+
</span></span></code></pre></div>暂时不再使用HIDE_WHEN_STUCK, 因为需要hide的projects只有emacs.org projects. 因此在org-agenda-custom-commands中单独设置org-agenda-files即可.</li></ol><h4 id=effort的设计>Effort的设计</h4><p>effort是自己对某个task工作量的预估, 与clock-sum-time比对, 可以很好的进行分析. 为了方便的effort, 这里只在两处设计了提示:</p><ol><li>capture的时候, 可以输入effort. 当然为了快速capture, 这里允许输入0跳过</li><li>clock-in的时候, 如果item effort还是0, 则会要求进入工作预估</li></ol><h4 id=clock的设计>clock的设计</h4><p>org的clock已经非常好用了. 这里只是做了一点点修改:</p><ol><li>快捷键快速clock-in, clock-out</li><li>如果当前没有clock, 会在agenda界面做个提示</li></ol><h4 id=capture设计>capture设计</h4><p>经常是在工作的时候, 突然有了某个想法. 这个想法也许值得记录, 但不要打断当前的思路. 所以需要capture capture应该是快速的, 但又要明确的(归属要明确, 最好effort要明确)</p><p>为了快速capture, 所以不应该考虑这个想法应该放到哪个file. 统一放到inbox即可. 为了后面的auto refile, 这个想法或item 应该携带足够的信息, 可以完成auto refile. 这里的办法是给item一个tag. 比如 capture了一个item, 再给其增加对应的tag</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>* org应该快速capture :org:
</span></span></code></pre></div><p>这样就表明了这是一个与org PROJECT有关的task</p><h4 id=refile的设计>refile的设计</h4><p>refile应该是自动完成的, 不应该手动 为了自动完成, item已经给了相关信息(tag) 在gtd_my或gtd_work的PROJECT中, 也应该携带足够的信息去与该tag匹配. 只有匹配成功了, 就可以auto-refile 这里的办法是给PROJECT item一个Property (P_UUID)来实现 比如</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>* PROJECT org                                                       :org:
</span></span><span class=line><span class=cl>  :PROPERTIES:
</span></span><span class=line><span class=cl>  :P_UUID:   org
</span></span><span class=line><span class=cl>  :END:
</span></span></code></pre></div><p>当capute-item的tag 与 PROJECT-item的P_UUID相匹配的时候, 会自动refile</p><h4 id=archive的设计>archive的设计</h4><p>对于gtd_my, gtd_work中的task, 没必要archive 对于gtd_common中的task, 应该自动archive</p><h4 id=agent的设计>Agent的设计</h4><p>agent的目的有2个:</p><ol><li>查看各种代办事项 今天的, 未来的, TODO的, inbox中的, 五年规划</li><li>统计信息 一是以time为视角的统计, 比如今天或这周做了哪些TODO或PROJECT 二是以PROJECT为视角的统计. 比如统计emacs PROJECT花费的时间</li></ol><p>查看代办事项, 主要是org-agenda-view, org-next-view, org-inbox-view, org-life-view 查看 查看统计信息, 主要是org-project-view, org-archive-view 以及在特定PROJECT file中的org-colmun-view查看具体</p><p>org-next-view 显示todo|waiting items && tuck project</p><p>org-project-view中没必要包含gtd_common中的item org-archive-view中包含gtd_common中的TODO, PROJECT items</p><p>快捷键主要是为了方便.比如</p><ul><li>空格滚动各种view</li><li>tab在另一个窗口显示item narrow</li><li>enter则进入item编辑</li><li>常用的功能都会放到C-j中处理 等等</li></ul><h4 id=使用流程>使用流程</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>|
</span></span><span class=line><span class=cl>| capture with                                         add timestamp &amp;&amp;              add DONE &amp;&amp;
</span></span><span class=line><span class=cl>| template       +---------+ auto refile   +---------+   auto refile     +---------+ auto archive  +---------+
</span></span><span class=line><span class=cl>+---------------&gt;|  inbxo  |--------------&gt;|next step|------------------&gt;|  agenda |--------------&gt;| archive |
</span></span><span class=line><span class=cl>|  C-c c         +---+-----+               +---------+  C-j s,d          +---------+  C-j t        +---------+
</span></span><span class=line><span class=cl>|                    |                                                                                  ^
</span></span><span class=line><span class=cl>|                    |                       add DONE &amp;&amp; auto refile                                    |
</span></span><span class=line><span class=cl>|                    +----------------------------------------------------------------------------------+
</span></span><span class=line><span class=cl>|                                                  C-j t
</span></span></code></pre></div><ol><li><p>C-c c -> inbox</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>info, todo, waiting, project 都会放到inbox
</span></span></code></pre></div></li><li><p>当打开org-agenda(主动调用"r")或者在org-agenda中按&rsquo;r&rsquo; 会自动把inbox中的文件refile到指定位置</p></li><li><p>在org-agenda界面操控 C-j 以及常用的快捷键 t, space, tab, enter等</p></li><li><p>org-agenda界面的&rsquo;r&rsquo;动作, 不仅可以把inbox中的文件reflie, 也可以把task.org中完成的任务archive</p></li><li><p>其实还有最后一步, 即把archive中的内容输出到blog中</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>blog具体见 hugo的文档
</span></span><span class=line><span class=cl>不建议删除已完成或cancel的task. 后期统计可以使用
</span></span></code></pre></div></li></ol><h2 id=键位设置>键位设置</h2><h3 id=设计思路>设计思路</h3><p>原则</p><ol><li>尽量保留默认常用快捷键</li><li>不同mode, 尽量使用相似的快捷键</li></ol><p>思路</p><ol><li>通用快捷键(比如search等与mode无关的)或者是所有mode都会使用的统一放到C-s中</li><li>mode自身的快捷键, 放到C-j中</li><li>项目相关的快捷键, 放到C-d中</li></ol><h3 id=快捷键>快捷键</h3><p>具体可以参考<a href=https://github.com/clay9/emacs.d/blob/master/lisp/init-local-shortkey.el:compilation-mode-map target=_blank rel="noopener noreffer">局部快捷键</a> 与 <a href=https://github.com/clay9/emacs.d/blob/master/lisp/init-global-shortkey.el target=_blank rel="noopener noreffer">全局快捷键</a></p><table><thead><tr><th>key</th><th>C</th><th>M</th><th>C-x</th><th>C-c</th></tr></thead><tbody><tr><td>a</td><td>行首</td><td>段首</td><td>buffer首</td><td><code>mode</code> org-agent</td></tr><tr><td>b</td><td>后退</td><td>后退</td><td>列表</td><td></td></tr><tr><td>c</td><td><code>修饰</code> 通用修饰</td><td></td><td></td><td>capure</td></tr><tr><td>d</td><td>删除</td><td>删除</td><td>目录</td><td></td></tr><tr><td>e</td><td>行尾</td><td>段尾</td><td>buffer尾</td><td></td></tr><tr><td>f</td><td>前进</td><td>前进</td><td>打开</td><td></td></tr><tr><td>g</td><td>取消</td><td></td><td></td><td></td></tr><tr><td>h</td><td><code>修饰</code> 帮助文档</td><td></td><td></td><td></td></tr><tr><td>i</td><td>别名 {TAB}</td><td></td><td></td><td></td></tr><tr><td>j</td><td><code>修饰</code> mode使用</td><td></td><td></td><td></td></tr><tr><td>k</td><td>kill</td><td></td><td>删除</td><td></td></tr><tr><td>l</td><td>移动buffer</td><td></td><td></td><td></td></tr><tr><td>m</td><td>别名 {ENTER}</td><td></td><td></td><td></td></tr><tr><td>n</td><td>下一行</td><td></td><td></td><td></td></tr><tr><td>o</td><td><code>mode</code> smartparens</td><td></td><td>切换</td><td></td></tr><tr><td>p</td><td>上一行</td><td></td><td></td><td></td></tr><tr><td>q</td><td><code>未使用</code></td><td></td><td></td><td></td></tr><tr><td>r</td><td><code>未使用</code></td><td></td><td></td><td></td></tr><tr><td>s</td><td>查找</td><td></td><td>保存</td><td></td></tr><tr><td>t</td><td><code>未使用</code></td><td></td><td></td><td></td></tr><tr><td>u</td><td><code>修饰</code> 命令重复</td><td></td><td></td><td></td></tr><tr><td>v</td><td>翻页</td><td>翻页</td><td></td><td></td></tr><tr><td>w</td><td>剪切</td><td>复制</td><td></td><td>refile</td></tr><tr><td>x</td><td><code>修饰</code> buffer</td><td>命令</td><td></td><td></td></tr><tr><td>y</td><td>粘贴</td><td></td><td></td><td>archive</td></tr><tr><td>z</td><td><code>未使用</code></td><td></td><td></td><td></td></tr><tr><td>DEL</td><td></td><td>删除</td><td></td><td></td></tr></tbody></table><h2 id=待整理-tools>TODO 待整理 &ndash; tools</h2><h3 id=eshell>eshell</h3><h4 id=why>why</h4><p>emacs内置的shell.</p><ul><li>与elisp无缝结合</li><li>语法特性方面比bash shell更有意思<div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl># 可以与tramp无缝结合
</span></span><span class=line><span class=cl>cd /method:user@host#port:path
</span></span></code></pre></div></li></ul><h4 id=how>how</h4><ul><li><p>eshell script</p><p>官方不建议在eshell中写shell脚本, eshell脚本也是以.sh结尾</p><ul><li><p>变量赋值</p><p>eshell 脚本中使用elisp语法给变量赋值</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(setq remote_temp &#34;/ssh:clay@192.168.0.97:~/temp&#34;)
</span></span></code></pre></div></li></ul><ul><li><p>变量使用 $</p><p>基本与shell相同, 具体可以详见官方说明</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>eshell/rm -r $remote_temp
</span></span></code></pre></div></li></ul></li></ul><h4 id=manual>manual</h4><ol><li><a href=https://linuxtoy.org/archives/emacs-eshell.html target=_blank rel="noopener noreffer">官方文档</a></li></ol><h3 id=elisp>elisp</h3><h4 id=how>how</h4><ul><li><p>日常记录</p><p>lisp没有重载一说, 直接覆盖; 因此为了方便出现了 advise 函数</p></li></ul><ul><li><p>elisp 与 bash</p><ul><li><p>bash调用elisp</p><ol><li>elisp代码写入el文件(eshell script)</li><li>bash调用emacs执行el文件<div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl># 实际还是emacs 执行的elisp代码
</span></span><span class=line><span class=cl>emacs -u clay --script /Users/clay/.emacs.d/lisp/fun/init-hexo-fun.el
</span></span></code></pre></div></li></ol></li></ul><ul><li><p>elisp 调用bashe</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(setq my-command
</span></span><span class=line><span class=cl>(concat &#34;IFS=: read -ra dirs &lt;&lt;&lt;\&#34;$PATH\&#34;\n&#34;
</span></span><span class=line><span class=cl>        &#34;for dir in ${dirs[@]}; do\n&#34;
</span></span><span class=line><span class=cl>        &#34; echo got dir \&#34;$dir\&#34;\n&#34;
</span></span><span class=line><span class=cl>        &#34;done\n&#34;))
</span></span><span class=line><span class=cl>(shell-command (format &#34;bash -c %s&#34; (shell-quote-argument my-command)))
</span></span></code></pre></div></li></ul></li></ul><h4 id=manual>manual</h4><ol><li><a href=http://smacs.github.io/elisp/02-elisp-basic.html target=_blank rel="noopener noreffer">水木社区Emacs版</a></li><li><a href=https://www.csdn.net/article/2012-11-22/2812113-The-Nature-Of-Lisp target=_blank rel="noopener noreffer">lisp的本质</a></li></ol><h3 id=tramp>tramp</h3><h4 id=what>what</h4><p>全程 transparent remote access multiple protocol</p><p>tramp是用来编辑远端文件的模块, 支持多种协议 ssh, ftp, smb, adb等, 常用method</p><ul><li><p>ssh</p></li><li><p>plink</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>putty的ssh client(与linux的ssh client作用一样)
</span></span></code></pre></div></li><li><p>su | sudo</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl># 这种并不连接到远程主机, 而是允许使用另一个用户身份打开本地文件
</span></span><span class=line><span class=cl>/su:root:path/
</span></span></code></pre></div></li></ul><h4 id=how>how</h4><ul><li><p>basic</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>/method:user@host#port:path/to/file
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># example 1
</span></span><span class=line><span class=cl>/ssh:clay@192.1.1.1#22:~
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># example 2 windows下可以使用putty作为ssh的client
</span></span><span class=line><span class=cl>/plink:clay@192.1.1.1:~
</span></span></code></pre></div></li></ul><ul><li><p>set default method</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>(setq tramp-default-method &#34;plink&#34;)
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl>; 设置之后的例子
</span></span><span class=line><span class=cl>; 可以设置linux和windows下默认的method，之后就无需考虑操作系统
</span></span><span class=line><span class=cl>/-:clay@192.1.1.1:~
</span></span></code></pre></div></li></ul><ul><li><p>multiple hop</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl># 在本机上,    通过clay用户登录到host1
</span></span><span class=line><span class=cl># 再在host1上, 通过admin登录到host2
</span></span><span class=line><span class=cl>/ssh:clay@host1|ssh:admin@host2:/path
</span></span></code></pre></div></li></ul><ul><li><p>su | sudo</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl># 使用sudo打开远程文件
</span></span><span class=line><span class=cl>/-:clay@192.1.1.1|sudo::/path
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 使用sudo打开本地文件
</span></span><span class=line><span class=cl># su::默认的是 su:root@localhost. 配置在tramp-default-method-alist
</span></span><span class=line><span class=cl>/su::local-path
</span></span><span class=line><span class=cl>/su:user@localhost:/local-path
</span></span><span class=line><span class=cl>/sudo:root@localhost:/local-path
</span></span></code></pre></div></li></ul><ul><li><p>use with bookmarks</p><p>tramp使用的时候 需要使用到method user host path的组合，一般较长</p><p>我们更希望使用较短的shortcut去远程打开某个file</p><p>这里推荐的方法是bookmark. 理由:</p><ol><li>bookmark emacs内置, 而且非常方便</li><li>bookmark 的配置信息 可以方便git管理</li></ol><p>使用方法:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl># 1.远程连接
</span></span><span class=line><span class=cl>C-x f /ssh:clay@192.1.1.1:~
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 2.添加到bookmark
</span></span><span class=line><span class=cl>C-x C-f BOOK-NAME RET
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 3.查看bookmark
</span></span><span class=line><span class=cl>C-x C-f
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 4.管理bookmark配置文件
</span></span><span class=line><span class=cl>~/.emacs.d/bookmarks
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl># 5.管理auth信息文件
</span></span><span class=line><span class=cl>~/.emacs.d/authinfo
</span></span></code></pre></div></li></ul><h4 id=notice>notice</h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>TODO 这条notice待验证
</span></span></code></pre></div><p>Tramp 打开的远端文件和本地的文件没什么区别，会被记录在 backup、autosave、recentf等中.</p><p>在今后重启 Emacs 时，如果这时无法连接远端机器，Emacs 可能会卡住， 这是因为 tramp 会对之前打开的文件进行检查</p><p>解决方案: 让backup等机制绕过tramp即可</p><h3 id=graph>graph</h3><h4 id=why>why</h4><p>图形表达更直观, 形象.</p><h4 id=what>what</h4><p>artist-mode和graphviz-mode都可以完成绘图的功能.</p><p>但artist-mode提供的功能过于基础, 使用的时候, 最好进行进一步封装.</p><p><a href=https://github.com/clay9/emacs.d/blob/master/lisp/init-artist-mode.el target=_blank rel="noopener noreffer">可参考笔者自用的线和矩形</a>, 提升artist-mode的使用体验</p><table><thead><tr><th>mode</th><th>简述</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>artist-mode</td><td>ASCII绘图</td><td>1.ASCII代码表示图形</td><td>1.功能少</td></tr><tr><td></td><td></td><td>2.短小精悍</td><td>2.需要手动绘制图形</td></tr><tr><td>graphviz-mode</td><td>dot绘图</td><td>1.只关注逻辑设计,布局自动生成</td><td>1.生成的为图片文件, 而非可嵌入的ASCII代码</td></tr><tr><td></td><td></td><td></td><td>2.需要学习dot语言</td></tr></tbody></table><h4 id=how>how</h4><ul><li><p>install</p><ol><li><p>emacs install graphviz-dot-mode</p></li><li><p>system install graphviz</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>brew install graphviz  #mac
</span></span></code></pre></div></li></ol></li></ul><ul><li><p>use</p><ol><li>create .dot | .org file</li><li>write &ldquo;The DOT Language&rdquo;</li><li>M-x graphviz-dot-preview</li></ol></li></ul><ul><li><p>dot language</p><p>DOT中使用图(digraph/graph), 节点(node)和边(edge)来描述关系和流程图.</p><ul><li><p>graph</p><ul><li><p>有向图 digraph</p></li><li><p>无向图 graph</p></li><li><p>子图 subgraph</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>可以进行和“父图”类似的设置，唯一注意的是子图必须以cluster做为名称的前缀
</span></span></code></pre></div></li></ul><p>在图的开头使用graph []对图进行设置，如：graph [bgcolor=&ldquo;gray&rdquo;]将图背景色设置为灰色。 属性设置语句也可以不包含在graph []中而直接使用。</p><table><thead><tr><th>属性名称</th><th>默认值</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>color</td><td>black</td><td>颜色</td><td>支持如red和#FF00000两种形式</td></tr><tr><td>fontcolor</td><td>black</td><td>文本颜色</td><td></td></tr><tr><td>fontsiez</td><td>14</td><td>字体大小</td><td></td></tr><tr><td>label</td><td></td><td>显示的标签</td><td>对于节点, 默认为节点名称</td></tr><tr><td>style</td><td></td><td>样式</td><td></td></tr><tr><td>bgcolor</td><td></td><td>背景颜色</td><td></td></tr><tr><td>nodesep</td><td>.25</td><td>节点间隔(英寸)</td><td></td></tr><tr><td>rank</td><td></td><td>节点顺序</td><td>same, min, source, max, sink</td></tr><tr><td>rankdir</td><td>TB</td><td>排序方向</td><td>TB(top->bottom)</td></tr><tr><td>size</td><td></td><td>图的大小</td><td></td></tr><tr><td>labelloc</td><td></td><td>调整图或子图的 标签的上下位置</td><td></td></tr><tr><td>labeljust</td><td></td><td>调整图或子图的 标签的左右位置</td><td></td></tr></tbody></table></li></ul><ul><li><p>node</p><p>DOT中，节点可以不用声明直接使用，但如果需要设置节点的属性，则需声明节点并在声明处设 置属性然后再使用。每个节点首次出现的名称做为该节点的唯一标识</p><p>node []用于设置节点默认属性（对设置位置之后的点有效），在节点后面用[]设置单独一个点的属性。</p><table><thead><tr><th>属性名称</th><th>默认值</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>color</td><td>black</td><td>颜色</td><td>支持如red和#FF00000两种形式</td></tr><tr><td>fontcolor</td><td>black</td><td>文本颜色</td><td></td></tr><tr><td>fontsiez</td><td>14</td><td>字体大小</td><td></td></tr><tr><td>label</td><td></td><td>显示的标签</td><td>对于节点, 默认为节点名称</td></tr><tr><td>style</td><td></td><td>样式</td><td></td></tr><tr><td>shape</td><td>ellipse</td><td>节点形状</td><td></td></tr><tr><td>fillcolor</td><td>lightgrey/black</td><td>节点填充颜色</td><td></td></tr><tr><td>fixedsize</td><td>false</td><td>标签是否影响节点大小</td><td></td></tr></tbody></table></li></ul><ul><li><p>edge</p><p>DOT中有有向边（使用->表示）和无向边（使用&ndash;表示）两种，有向边用于有向图，无向边用于无向图，不可混用。</p><p>和节点类似的，用edge []设置边默认属性，在边之后用[]设置单独一条边的属性。 对于有向边，还可以设置边的起点/终点的位置（用n、e、s、w或它们的组合表示位置）。</p><table><thead><tr><th>属性名称</th><th>默认值</th><th>含义</th><th>备注</th></tr></thead><tbody><tr><td>color</td><td>black</td><td>颜色</td><td>支持如red和#FF00000两种形式</td></tr><tr><td>fontcolor</td><td>black</td><td>文本颜色</td><td></td></tr><tr><td>fontsiez</td><td>14</td><td>字体大小</td><td></td></tr><tr><td>label</td><td></td><td>显示的标签</td><td>对于节点, 默认为节点名称</td></tr><tr><td>style</td><td></td><td>样式</td><td></td></tr><tr><td>arrowhead</td><td>normal</td><td>箭头头部形状</td><td></td></tr><tr><td>arrowtail</td><td>normal</td><td>箭头尾部形状</td><td></td></tr><tr><td>constraint</td><td>ture</td><td>是否根据边来影响节点的排序</td><td></td></tr><tr><td>decorate</td><td></td><td>设置之后会用一条线来连接edge和label</td><td></td></tr><tr><td>dir</td><td>forward</td><td>边的设置方向</td><td>forward,bcak,both,none</td></tr><tr><td>headlabel</td><td></td><td>边的头部显示的标签</td><td></td></tr><tr><td>taillabel</td><td></td><td>边的尾部显示的标签</td><td></td></tr></tbody></table></li></ul></li></ul><h3 id=mail>mail</h3><p>emacs 流行的email client 有mu4e, notmuch, gnus等 因为对email不是刚需, 只是轻度使用, 所以这里选了内置对gnus. 理由如下:</p><ol><li>emacs 内置</li><li>顺便尝试 newsgroup</li><li>轻度使用email</li></ol><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>反而发现gnus非常难配置, 因为可定制的选项太多了, 所以不是很友好
</span></span></code></pre></div><p>gnus的缺点:</p><ol><li>配置复杂, 花了24h才看完官方文档. 发现实际用到的也就5% ?</li><li>gnus是单线程, 所以如果网络不好, 非常容易把emacs卡住, 比如访问gmail的时候&mldr;</li></ol><h4 id=基本概念>基本概念</h4><p>gnus概念划分比较友好, server, group, summary, article 各司其职, 又互相联系, 比较方便, 具体可以参考官方文档</p><h4 id=操作流程>操作流程</h4><ol><li>设置server</li><li>subscribe group</li><li>enter group. show summary</li><li>read article</li></ol><h4 id=group-level>group level</h4><p>group在gnus中是比较重要的概念. 而group level 可以更好的理解group</p><p>官方描述中: subscribe : 1 - guns-level-subscribed (5) unsubscribe: gnus-level-unsubscribed (7) zommbie: 8 killed: 9</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>level越高越不重要
</span></span></code></pre></div><p>可以发现killed group有最高的level, 而unsubscribe level 和 subscribe level实际在gnus中处理差异不大. 所以如果不想看到某个组, 直接kill. 因为Gnus 不会向server询问zoomibe && killed group的数据</p><p>gnus-group-list-group 显示 unread subscribe gnus-group-list-all-group 显示 subscribe && unsubscribe</p><h4 id=mail>mail</h4><p>mail 在gnus中是一种特殊的group. 特殊在哪&mldr;TODO 待补充</p><p>mail的设置非常简单, 因为我的需求只是阅读邮件, 所以使用了nnimap作为backend. 实际上gnus支持的mail back非常的多, 功能也非常强大</p><ul><li><p>gmail 或者 国外的mail</p><p>不建议使用国外mail, 网络不好会卡住emacs 如果一定要用, 推荐使用代理. 代理可以在emacs中配置, 也可以在代理软件中配置. 比如gmail: imap.gmail.com:993 smtp.gmail.com:587</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>下面的为个人猜测, 未验证
</span></span></code></pre></div><p>如果设置了代理, 还是无法连接, 有可能是短时间连接次数过多, 被gamil服务器暂时拦截了 等一段时间再试即可</p></li></ul><h3 id=gdb-and-and-gud>gdb && gud</h3><p>emacs使用gud来绘制gdb的调试信息. gud可以认为是gdb的ui client.</p><p>具体可以参考<a href=https://github.com/clay9/emacs.d/blob/master/lisp/init-gdb.el target=_blank rel="noopener noreffer">github的init-gdb.el</a>和<a href=https://github.com/clay9/emacs.d/blob/master/lisp/fun/init-gdb-fun.el target=_blank rel="noopener noreffer">一些自定义gud函数</a></p><h4 id=gdb使用>gdb使用</h4><table><thead><tr><th>指令</th><th>简写</th><th>描述</th></tr></thead><tbody><tr><td>attach</td><td></td><td>附加到已经运行的程序</td></tr><tr><td>run</td><td>r</td><td>运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步命令</td></tr><tr><td>continue</td><td>c</td><td>继续执行，到下一个断点停止（或运行结束）</td></tr><tr><td>next</td><td>n</td><td>单步跟踪程序，当遇到函数调用时，也不进入此函数体</td></tr><tr><td>step</td><td>s</td><td>单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的</td></tr><tr><td>until</td><td>u</td><td>当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环</td></tr><tr><td>until+行号</td><td></td><td>运行至某行，不仅仅用来跳出循环</td></tr><tr><td>finish</td><td></td><td>运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息</td></tr><tr><td>quit</td><td>q</td><td>退出gdb</td></tr><tr><td>up</td><td></td><td>上个stack</td></tr><tr><td>down</td><td></td><td>下个stack</td></tr><tr><td>watch</td><td></td><td>变量监控</td></tr><tr><td>breakpoint</td><td>b</td><td>file :line_num 文件:行号</td></tr><tr><td></td><td></td><td>&lt;fun_name> 函数名字</td></tr></tbody></table><p>run相当于重新启动程序, 但是由于某些原因(找不到库? 怀疑是变量不同), 容易导致程序启动失败 continue 相当于继续执行, 一般在接attach和gdb Server之后使用, 使程序继续执行</p><h4 id=gud使用>gud使用</h4><table><thead><tr><th>buffer名字</th><th>简述</th><th>备注</th></tr></thead><tbody><tr><td>gud</td><td>gdb命令输入窗口</td><td></td></tr><tr><td>source</td><td>调试时自动显示源码</td><td>不要edit, 否则导致source自动关联失效</td></tr><tr><td>breakpoint</td><td>断点</td><td>不会命中的断点显示为pending</td></tr><tr><td>threads</td><td>线程</td><td></td></tr><tr><td>stack</td><td>堆栈</td><td></td></tr><tr><td>local</td><td>local变量</td><td></td></tr><tr><td>register</td><td>寄存器</td><td></td></tr><tr><td>assembler</td><td>显示汇编</td><td></td></tr><tr><td>memory</td><td>内存查看</td><td></td></tr></tbody></table><p>为了显示方便, breakpoint与threads buffer同在一个frame; local与register buffer同在一个frame; 可以按"TAB"快速切换</p><ul><li><p>例子</p><ol><li>emacs: M-x gdb RET</li><li>gud: attch &lt;program pid></li><li>设置breakpoint<ul><li>gud: b</li><li>source: gud-break; gud-tbreak</li><li>breakpoint: D 删除断点</li></ul></li><li>设置watch<ul><li>gud: watch</li><li>souce: gud-watch</li></ul></li></ol></li></ul><ul><li><p>问题</p><ol><li>gud中在continue之后, 程序运行; 此时输入, gud并没有反应; 但是在程序运行到断点的时候, 之前的输入全部变成了命令. 简单来说, gud没有舍弃之前的无效输入, 而是等待机会, 使之生效</li><li>gdb continue之后 如何退出<ol><li>gdb进程中可以使用C-c, 退出attach所关联的进程</li><li>emacs-gdb中如何退出 ?? TODONOW</li></ol></li></ol></li></ul><h3 id=ai-code-assistants>AI Code Assistants</h3><p>之前的IDE大多是基于语法的分析, AI代码助手提供了基于自然语义的分析. 效果非常的惊艳, 能更好的帮助编写文档与程序</p><p>当下流行的(2023-6)主要有: Github Copilot, Tabnine, Replit Ghostwriter, Amazon CodeWhisperer 和 Codeium 具体可以参考 <a href=https://codeium.com/blog/code-assistant-comparison-copilot-tabnine-ghostwriter-codeium target=_blank rel="noopener noreffer">测评文章</a></p><p>基于以下原因, 暂时使用了github copilot:</p><ol><li>配置方便, emacs使用体验良好</li></ol><h4 id=github-copilot>github copilot</h4><ul><li><p>使用</p><p>github copilot 没有emacs的官方插件, 使用的是第三方package <a href=https://github.com/zerolfx/copilot.el target=_blank rel="noopener noreffer">copilot</a>. 安装与配置均比较简单, 可以参考copilot官方文档</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-text data-lang=text><span class=line><span class=cl>其中需要开通github copilot, 建议在某宝购买github学生包, 便宜又方便, 但是容易被封, 千万不要使用自己的github账号
</span></span></code></pre></div><div class=highlight><pre tabindex=0 class=chroma><code class=language-lisp data-lang=lisp><span class=line><span class=cl><span class=c1>;;国内可能无法访问github copilot, 可以配置一下代理</span>
</span></span><span class=line><span class=cl><span class=p>(</span><span class=k>setq</span> <span class=nv>copilot-network-proxy</span> <span class=o>&#39;</span><span class=p>(</span><span class=ss>:host</span> <span class=s>&#34;127.0.0.1&#34;</span> <span class=ss>:port</span> <span class=s>&#34;10887&#34;</span><span class=p>))</span>
</span></span></code></pre></div></li></ul><ul><li><p>快捷键配置</p><p>copilot 与company-mode的一些快捷键容易冲突, 可以参考<a href=https://github.com/clay9/emacs.d/blob/master/lisp/init-local-shortkey.el target=_blank rel="noopener noreffer">init-local-shortkey.el</a></p></li></ul><ul><li><p>使用体验</p><ol><li>github copilot自身还好, 但是github学生包账号非常容易被封, 略微影响使用体验</li></ol></li></ul></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-12-15</span></div></div><div class=post-info-line><div class=post-info-md></div><div class=post-info-share><span></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw" aria-hidden=true></i>&nbsp;<a href=/tags/gnu/>gnu</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/>主页</a></span></section></div><div class=post-nav><a href=/posts/rup/ class=prev rel=prev title=rup架构图><i class="fas fa-angle-left fa-fw" aria-hidden=true></i>rup架构图</a></div></div></article></div></main></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw" aria-hidden=true></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw" aria-hidden=true></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.38.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.9/lunr.min.js></script><script type=text/javascript src=/lib/lunr/lunr.stemmer.support.min.js></script><script type=text/javascript src=/lib/lunr/lunr.zh.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.3.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:50},comment:{},search:{highlightTag:"em",lunrIndexURL:"/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/lib/lunr/lunr.segmentit.js",maxResultLength:20,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/js/theme.min.js></script></body></html>