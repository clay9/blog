<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>简介 on 飘</title><link>https://www.wcq.life/</link><description>Recent content in 简介 on 飘</description><generator>Hugo</generator><language>en</language><lastBuildDate>Fri, 31 May 2024 06:36:43 +0000</lastBuildDate><atom:link href="https://www.wcq.life/index.xml" rel="self" type="application/rss+xml"/><item><title>linux</title><link>https://www.wcq.life/docs/os/linux/</link><pubDate>Fri, 31 May 2024 10:36:00 +0000</pubDate><guid>https://www.wcq.life/docs/os/linux/</guid><description>&lt;p>linux常用命令&amp;amp;&amp;amp;工具 &lt;br/>&lt;/p></description></item><item><title>org</title><link>https://www.wcq.life/docs/emacs/org/org/</link><pubDate>Thu, 30 May 2024 20:33:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/org/org/</guid><description>org-mode一直被称为神器 主要有2大功能, 一是自身强大的文本模式(依赖 org-mode), 另一个则是 org-agenda 推荐阅读: org心得体会 配置 # org作为文本模式配置较少, 更多的是配置org-agenda为GTD管理工具. org文本模式下, 配置简单外观 以及 Babel-languages org-agenda的配置可参考init-org-agenda.el和一系列自定义函数 使用 # font format # key format normal = monospace ~ key-binding + strike-through _ underline 基本语法 # 语法: time-stamp选择 # 添加time-stamp时, 不要在calendar中移动,效率太低 使用以下2种方式即可: 使用简约的时间格式 17-1-1 =&amp;gt; 2017-01-01 使用时间间隔 now = [2016-12-28 Wed] +1d =&amp;gt; 2016-12-29 具体见(dir) - Org mode - Dates and times - Creating timestamps - The date/time promt 语法: 时间repeate # org-mode repeate格式 .</description></item><item><title>emacs</title><link>https://www.wcq.life/docs/emacs/emacs/</link><pubDate>Thu, 30 May 2024 20:11:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/emacs/</guid><description>简述 # emacs是什么 # emacs最原始,最纯粹的功能: text editor 也可以作为优秀的 program editor 优秀的文本 gtd 软件 良好的扩展性, 很多优秀插件, 比如org,magit,tramp,eshell等 综上, emacs其实更像一个大杂烩, 整合了大多数功能, 使其可以高效的完成任务. 同时, 因为良好的定制性, emacs可以增强个人使用体验, 但也增加了很多学习成本 日常使用功能 # 文本编辑 因为emacs跑在wsl中, 日常很少用来文本编辑了 代码编写 公司使用vs工程, 日常很少使用emacs编码了 gtd blog 现在使用emacs, 大部分是在使用 org-mode 写blog, 使用 org-agenda 作GTD管理 emacs-程序 # emacs作为程序最基本的配置. themes ui界面显示 frame window font file recentf files buffers sessions text editor # 文本编辑器是emacs最原始, 最纯粹, 最重要的功能. 大部分配置都是在处理该项, 使其更符合个人习惯. 配置繁琐, 但不复杂 show # text editor最基本的配置, 文本在buffer中显示的样子. 比如行号, break-line, column indicator等 move-and-kill # 即是text editor, 也是emacs最基础的操作.</description></item><item><title>数据结构与算法分析</title><link>https://www.wcq.life/docs/prog_base/algorithm/</link><pubDate>Sat, 10 Feb 2024 21:40:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_base/algorithm/</guid><description>概述|总结 # 什么是 # 数据结构分为 物理结构 即在内存中的结构. 有顺序存储(内存连续) 和 链式存储(内存可不连续) 逻辑结构 一对一的线性, 一对多的树, 多对多的图 逻辑结构 # 一对一 # stack (LIFO) 堆栈, 后进先出 queue (FIFO) 队列, 先进先出 一对多 # tree 树 binary tree 二叉树 search binary tree 搜索二叉树 blance binary tree 平衡二叉树 complet binary tree 完全二叉树 name 特征 备注 tree binary tree 1.任意节点 叶度 &amp;lt;=2 search bianry tree 1.binary tree 2.任意节点 left-child, root, right-child有序 blanced binary tree 1.search binary tree 2.</description></item><item><title>docker</title><link>https://www.wcq.life/docs/tool/docker/</link><pubDate>Thu, 18 Jan 2024 19:15:00 +0000</pubDate><guid>https://www.wcq.life/docs/tool/docker/</guid><description>&lt;p>docker容器 &lt;br/>&lt;/p></description></item><item><title>socket base</title><link>https://www.wcq.life/docs/os/socket/socket/</link><pubDate>Thu, 18 Jan 2024 19:13:00 +0000</pubDate><guid>https://www.wcq.life/docs/os/socket/socket/</guid><description>&lt;p>socket相关网络编程 &lt;br/>&lt;/p></description></item><item><title>git</title><link>https://www.wcq.life/docs/prog_vc/git/</link><pubDate>Thu, 18 Jan 2024 19:11:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_vc/git/</guid><description>&lt;p>git简易指导, 个人使用心得 &lt;br/>&lt;/p></description></item><item><title>global</title><link>https://www.wcq.life/docs/prog_lsp/global/</link><pubDate>Thu, 18 Jan 2024 19:10:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_lsp/global/</guid><description>&lt;p>在project中生成TAGS文件, 方便索引 &lt;br/>&lt;/p>
&lt;pre>&lt;code class="language-text">建议使用lsp代替, global响应虽然快速, 但是不如lsp实时定位方便
&lt;/code>&lt;/pre></description></item><item><title>c++历史</title><link>https://www.wcq.life/docs/prog_language/c++/c++/</link><pubDate>Thu, 18 Jan 2024 19:06:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_language/c++/c++/</guid><description>&lt;p>通过C++历史, 更好的了解C++特性 &lt;br/>&lt;/p></description></item><item><title>gdb</title><link>https://www.wcq.life/docs/prog_debug/gdb/</link><pubDate>Thu, 18 Jan 2024 19:05:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_debug/gdb/</guid><description>process view # memory # info process mapping thread # PCB | TCB # 调试命令 # bt (backtrace) 查看函数栈 bt full 查看更加详细的信息 f (frame) 查看栈信息 f 0 表示查看栈顶; f n查看第n+1层 down 查看下一栈 up 查看上一栈 i (info) i program 查看当前进程运行信息 i threads 查看当前线程运行信息 i f 查看当前栈所在层的具体信息 i args 当前函数的参数名及其值 i locals 当前函数中所有局部变量及其值 i catch 异常处理信息 i b 查看断点 i proc mappings 查看程序的内存分布 i reg 查看寄存器 l (list) 查看源码 p (print) 查看变量的值 调试方法 # 以调试core文件为例 gdb .</description></item><item><title>autotools</title><link>https://www.wcq.life/docs/prog_compile/autotools/</link><pubDate>Thu, 18 Jan 2024 19:02:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_compile/autotools/</guid><description>&lt;p>初学autotools &lt;br/>&lt;/p></description></item><item><title>eshell</title><link>https://www.wcq.life/docs/emacs/lisp/eshell/</link><pubDate>Thu, 18 Jan 2024 18:19:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/lisp/eshell/</guid><description>emacs自带的shell解释器, 正在尝试使用, 期望可以取代其他shell解析器(比如bash, zsh) 官方文档 优势: emacs自带, 不同os环境统一 语法支持tramp cd /method:user@host#22:/patheshell &amp;amp;&amp;amp; elisp # defun为 eshell/xxx的函数, 可以在eshell中直接调用xxx eshell script # 官方不建议在eshell中写shell脚本, eshell脚本也是以.sh结尾 变量赋值 # eshell 脚本中使用elisp语法给变量赋值 (setq remote_temp &amp;quot;/ssh:clay@192.168.0.97:~/temp&amp;quot;)变量使用 $ # 基本与shell相同, 具体可以详见官方说明 eshell/rm -r $remote_temp</description></item><item><title>gtd</title><link>https://www.wcq.life/docs/emacs/org/gtd/</link><pubDate>Thu, 30 May 2024 20:41:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/org/gtd/</guid><description>为什么要用GTD # 每天或每周需要处理的事情非常之多, 小到晚上要洗衣服, 大到明天项目交付. 这些事情如果都存储在脑中, 轻则焦虑不堪, 重则脑子爆炸. 而且脑中一旦塞满了这类事情, 非常不利于思考. 大脑应该是拿来思考的, 而不是用来存储的. 假设一种情形, 大脑只用来思考, 而存储则放在大脑之外, 那么我们就不必因当下之外的事情而焦虑, 能够更专一的处理当下的问题. 同时, 如果外在存储能够提醒我们何时该思考何问题, 那么我们也不会因错过了某事而悔恨, 比如女友生日. 而这也是GTD的目的所在, 大脑只用来思考, 存储在脑外. GTD是什么 # 人生5楼 # 了解GTD之前, 必须了解 人生5楼. 楼数 功能 说明 备注 5楼 人生规划 4楼 3年目标 3楼 1年目标 2楼 职责范围 1楼 项目 GTD管理 地面 行动清单 归属1楼 GTD管理 把人生(或部分人生)比喻成一座大厦, 1楼是我们当下要做的事情, 2楼是我们的职责范围, 3楼是我们1年后的样子, 4楼是我们3年后的样子, 5楼是我们人生(10年, 20年或一辈子)的规划. 我们的人生是高层决定了低层 比如, 如果想成为计算机专家(5楼), 那么3年后要先成为工程师(4楼), 1年后要先成为程序员(3楼), 为了要成为程序员, 也许我们需要去报班学习(2楼 职责为学习),或者成为程序员助理(2楼 职责为搬砖), 而1楼则是我们当下要确确实实需要处理的事情, 比如看书, 工作, 交流等, 所有一切能对我们有提升的事情.</description></item><item><title>k8s</title><link>https://www.wcq.life/docs/tool/k8s/</link><pubDate>Thu, 18 Jan 2024 19:18:00 +0000</pubDate><guid>https://www.wcq.life/docs/tool/k8s/</guid><description>&lt;p>kubernetes, 简称k8s &lt;br/>&lt;/p></description></item><item><title>asio</title><link>https://www.wcq.life/docs/os/socket/asio/</link><pubDate>Thu, 18 Jan 2024 19:14:00 +0000</pubDate><guid>https://www.wcq.life/docs/os/socket/asio/</guid><description> 参考文档 # https://mmoaay.gitbooks.io/boost-asio-cpp-network-programming-chinese/content/ http://blog.jqian.net/post/boost-asio.html https://www.limerence2017.com/2023/06/07/asio20/</description></item><item><title>C &amp;&amp; C++ 常见库</title><link>https://www.wcq.life/docs/prog_language/c++/stl/</link><pubDate>Thu, 18 Jan 2024 19:07:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_language/c++/stl/</guid><description>&lt;p>C++ 常见库 &lt;br/>&lt;/p></description></item><item><title>valgrind</title><link>https://www.wcq.life/docs/prog_debug/valgrind/</link><pubDate>Thu, 18 Jan 2024 19:05:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_debug/valgrind/</guid><description>&lt;p>程序检测工具 &lt;br/>&lt;/p></description></item><item><title>mac</title><link>https://www.wcq.life/docs/os/mac/</link><pubDate>Thu, 18 Jan 2024 18:57:00 +0000</pubDate><guid>https://www.wcq.life/docs/os/mac/</guid><description>&lt;p>mac 记录 &lt;br/>&lt;/p></description></item><item><title>elisp</title><link>https://www.wcq.life/docs/prog_language/elisp/</link><pubDate>Thu, 18 Jan 2024 18:34:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_language/elisp/</guid><description>参考文档 水木社区Emacs版 lisp的本质 基础语法 # 函数重载 # elisp没有重载的概念, 直接覆盖原定义即可. 相关函数: advice-add 根据key来决定old_fun 与 new_fun的关系 key desc filter-return 先执行old. new对old的结果再处理 before 先执行new, 过滤一下数据, 再把结果给old arround 先执行new, 并在new中主动调用old(也可以不调用) 使用defune 覆盖原函数定义 如果只是重载, 应该使用这种方法. advice-add的本意不是用来override elisp &amp;amp;&amp;amp; shell # bash调用elisp # elisp代码写入el文件(eshell script) bash调用emacs执行el文件 # 实际还是emacs 执行的elisp代码emacs -u clay --script /Users/clay/.emacs.d/lisp/fun/init-hexo-fun.elelisp 调用bashe # (setq my-command(concat &amp;quot;IFS=: read -ra dirs &amp;lt;&amp;lt;&amp;lt;\&amp;quot;$PATH\&amp;quot;\n&amp;quot;&amp;quot;for dir in ${dirs[@]}; do\n&amp;quot;&amp;quot; echo got dir \&amp;quot;$dir\&amp;quot;\n&amp;quot;&amp;quot;done\n&amp;quot;))(shell-command (format &amp;quot;bash -c %s&amp;quot; (shell-quote-argument my-command)))</description></item><item><title>org &amp;&amp; gtd</title><link>https://www.wcq.life/docs/emacs/org/org_gtd/</link><pubDate>Thu, 30 May 2024 20:51:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/org/org_gtd/</guid><description>需求分析 # 所有的设计都是基于需求的, 应该先有需求, 再去设计. 当前的需求: 有哪些task 他们归属于哪个PROJECT 他们的四象限: 紧急&amp;amp;&amp;amp;重要 工作量预估 关联性 A task可能与B, C相关联 TODO 该任务并未完成 当前正在处理的任务 尽可能的关注当前, 忽略其他 当某个task进行时, 快速capture我的想法, 并且自动refile 看到自己花费的时间 一天,一周都做了什么 某个PROJECT总共花费的时间 流程的设计 # -------------------------+------------------------|| capture (easy)||varchive +---------++-------------------| inbox || +----+----+| || | refile (auto)| || || |----------------+--------------------|| | | || | v v| v +---------+ +---------+| +---------+ | my/emacs| | work/qy || | task | | * emacs| | * ker || +----+----+ | * org | | * frame|| | | * ccIDE| | * sub || | +---------+ +---------+| || | archive (auto)| || v| +---------++-&amp;gt;| archive |+----+----+文件的设计 # 区分目录是为了更好的给PROJECT做分类处理, 使后续的统计查看更方便.</description></item><item><title>monitor</title><link>https://www.wcq.life/docs/tool/monitor/</link><pubDate>Thu, 18 Jan 2024 19:18:00 +0000</pubDate><guid>https://www.wcq.life/docs/tool/monitor/</guid><description>&lt;p>cadvisor, influxdb, grafana 组成的监控系统 &lt;br/>&lt;/p></description></item><item><title>shell</title><link>https://www.wcq.life/docs/prog_language/shell/</link><pubDate>Thu, 18 Jan 2024 19:09:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_language/shell/</guid><description>&lt;p>shell 记录 &lt;br/>&lt;/p></description></item><item><title>tramp</title><link>https://www.wcq.life/docs/emacs/lisp/tramp/</link><pubDate>Thu, 18 Jan 2024 18:36:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/lisp/tramp/</guid><description>全称 transparent remote access multiple protocol tramp是用来编辑远端文件的模块, 支持多种协议 ssh, ftp, smb, adb等, 常用method ssh su | sudo # 这种并不连接到远程主机, 而是允许使用另一个用户身份打开本地文件/su:root:path/用法 # basic # /method:user@host#port:/path/to/file# example 1/ssh:clay@192.1.1.1#22:~# example 2 windows下可以使用putty作为ssh的client/plink:clay@192.1.1.1:~set default method # (setq tramp-default-method &amp;quot;plink&amp;quot;); 设置之后的例子; 可以设置linux和windows下默认的method，之后就无需考虑操作系统/-:clay@192.1.1.1:~multiple hop # # 在本机上, 通过clay用户登录到host1# 再在host1上, 通过admin登录到host2/ssh:clay@host1|ssh:admin@host2:/pathsu | sudo # # 使用sudo打开远程文件/-:clay@192.1.1.1|sudo::/path# 使用sudo打开本地文件# su::默认的是 su:root@localhost. 配置在tramp-default-method-alist/su::local-path/su:user@localhost:/local-path/sudo:root@localhost:/local-pathuse with bookmarks # tramp使用的时候 需要使用到method user host path的组合，一般较长 我们更希望使用较短的shortcut去远程打开某个file 这里推荐的方法是bookmark.</description></item><item><title>artist &amp;&amp; plantuml</title><link>https://www.wcq.life/docs/emacs/lisp/graph/</link><pubDate>Thu, 18 Jan 2024 18:38:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/lisp/graph/</guid><description> what # artist-mode和graphviz-mode都可以完成绘图的功能. 但artist-mode提供的功能过于基础, 使用的时候, 最好进行进一步封装. 可参考笔者自用的线和矩形, 提升artist-mode的使用体验 mode 简述 优点 缺点 artist-mode ASCII绘图 1.ASCII代码表示图形 1.功能少 2.短小精悍 2.需要手动绘制图形 graphviz-mode dot绘图 1.只关注逻辑设计,布局自动生成 1.生成的为图片文件, 而非可嵌入的ASCII代码 2.需要学习dot语言</description></item><item><title>hugo</title><link>https://www.wcq.life/docs/tool/hugo/</link><pubDate>Tue, 30 Jan 2024 10:24:00 +0000</pubDate><guid>https://www.wcq.life/docs/tool/hugo/</guid><description>&lt;p>使用hugo + github搭建blog &lt;br/>&lt;/p></description></item><item><title>make</title><link>https://www.wcq.life/docs/prog_compile/make/</link><pubDate>Thu, 18 Jan 2024 19:02:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_compile/make/</guid><description>&lt;p>make记录 &lt;br/>&lt;/p></description></item><item><title>mail</title><link>https://www.wcq.life/docs/emacs/lisp/mail/</link><pubDate>Thu, 18 Jan 2024 18:40:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/lisp/mail/</guid><description>不建议使用, 没啥意义 简述 # emacs 流行的email client 有mu4e, notmuch, gnus等 因为对email不是刚需, 只是轻度使用, 所以这里选了内置对gnus. 理由如下: emacs 内置 顺便尝试 newsgroup 轻度使用email 反而发现gnus非常难配置, 因为可定制的选项太多了, 所以不是很友好gnus的缺点: 配置复杂, 花了24h才看完官方文档. 发现实际用到的也就5% ? gnus是单线程, 所以如果网络不好, 非常容易把emacs卡住, 比如访问gmail 基本概念 # gnus概念划分比较友好, server, group, summary, article 各司其职, 又互相联系, 比较方便, 具体可以参考官方文档 操作流程 # 设置server subscribe group enter group. show summary read article group level # group在gnus中是比较重要的概念. 而group level 可以更好的理解group 官方描述中: subscribe : 1 - guns-level-subscribed (5) unsubscribe: gnus-level-unsubscribed (7) zommbie: 8 killed: 9 level越高越不重要可以发现killed group有最高的level, 而unsubscribe level 和 subscribe level实际在gnus中处理差异不大.</description></item><item><title>cmake</title><link>https://www.wcq.life/docs/prog_compile/cmake/</link><pubDate>Thu, 18 Jan 2024 19:03:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_compile/cmake/</guid><description>&lt;p>cmake &lt;br/>&lt;/p></description></item><item><title>gdb &amp;&amp; gud</title><link>https://www.wcq.life/docs/emacs/lisp/gdb/</link><pubDate>Thu, 18 Jan 2024 18:43:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/lisp/gdb/</guid><description>简述 # emacs使用gud来绘制gdb的调试信息. gud可以认为是gdb的ui client. 具体可以参考github的init-gdb.el和一些自定义gud函数 gdb使用 # 指令 简写 描述 attach 附加到已经运行的程序 run r 运行程序，当遇到断点后，程序会在断点处停止运行，等待用户输入下一步命令 continue c 继续执行，到下一个断点停止（或运行结束） next n 单步跟踪程序，当遇到函数调用时，也不进入此函数体 step s 单步调试如果有函数调用，则进入函数；与命令n不同，n是不进入调用的函数的 until u 当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环 until+行号 运行至某行，不仅仅用来跳出循环 finish 运行程序，直到当前函数完成返回，并打印函数返回时的堆栈地址和返回值及参数值等信息 quit q 退出gdb up 上个stack down 下个stack watch 变量监控 breakpoint b file :line_num 文件:行号 &amp;lt;fun_name&amp;gt; 函数名字 run相当于重新启动程序, 但是由于某些原因(找不到库? 怀疑是变量不同), 容易导致程序启动失败 continue 相当于继续执行, 一般在接attach和gdb Server之后使用, 使程序继续执行 gud使用 # buffer名字 简述 备注 gud gdb命令输入窗口 source 调试时自动显示源码 不要edit, 否则导致source自动关联失效 breakpoint 断点 不会命中的断点显示为pending threads 线程 stack 堆栈 local local变量 register 寄存器 assembler 显示汇编 memory 内存查看 为了显示方便, breakpoint与threads buffer同在一个frame; local与register buffer同在一个frame; 可以按&amp;quot;TAB&amp;quot;快速切换 例子 # emacs: M-x gdb RET gud: attch &amp;lt;program pid&amp;gt; 设置breakpoint gud: b source: gud-break; gud-tbreak breakpoint: D 删除断点 设置watch gud: watch souce: gud-watch 问题 # gud中在continue之后, 程序运行; 此时输入, gud并没有反应; 但是在程序运行到断点的时候, 之前的输入全部变成了命令.</description></item><item><title>AI</title><link>https://www.wcq.life/docs/emacs/lisp/ai/</link><pubDate>Thu, 18 Jan 2024 18:44:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/lisp/ai/</guid><description> 简述 # 之前的IDE大多是基于语法的分析, AI代码助手提供了基于自然语义的分析. 效果非常的惊艳, 能更好的帮助编写文档与程序 当下流行的(2023-6)主要有: Github Copilot, Tabnine, Replit Ghostwriter, Amazon CodeWhisperer 和 Codeium 具体可以参考 测评文章 基于以下原因, 暂时使用了github copilot: 配置方便, emacs使用体验良好 github copilot # 使用 # github copilot 没有emacs的官方插件, 使用的是第三方package copilot. 安装与配置均比较简单, 可以参考copilot官方文档 其中需要开通github copilot, 建议在某宝购买github学生包, 便宜又方便, 但是容易被封, 千万不要使用自己的github账号;;国内可能无法访问github copilot, 可以配置一下代理(setq copilot-network-proxy '(:host &amp;quot;127.0.0.1&amp;quot; :port &amp;quot;10887&amp;quot;))快捷键配置 # copilot 与company-mode的一些快捷键容易冲突, 可以参考init-local-shortkey.el 使用体验 # github copilot自身还好, 但是github学生包账号非常容易被封, 略微影响使用体验</description></item><item><title>memory 01</title><link>https://www.wcq.life/docs/os/os/memory_01/</link><pubDate>Thu, 30 May 2024 17:36:00 +0000</pubDate><guid>https://www.wcq.life/docs/os/os/memory_01/</guid><description>&lt;p>os中内存段页发展 &lt;br/>&lt;/p></description></item><item><title>org exprot &amp;&amp; ox-hugo</title><link>https://www.wcq.life/docs/emacs/org/org_export/</link><pubDate>Wed, 29 May 2024 15:11:00 +0000</pubDate><guid>https://www.wcq.life/docs/emacs/org/org_export/</guid><description>&lt;p>org自带强大的export功能. &lt;br/>
但更多的是使用ox-hugo导出hugo样式的md, 再使用hugo生成html. &lt;br/>&lt;/p></description></item><item><title>gcc</title><link>https://www.wcq.life/docs/prog_compile/gcc/</link><pubDate>Thu, 18 Jan 2024 19:03:00 +0000</pubDate><guid>https://www.wcq.life/docs/prog_compile/gcc/</guid><description>&lt;p>gcc &lt;br/>&lt;/p></description></item><item><title>静态库 &amp;&amp; 动态库</title><link>https://www.wcq.life/docs/os/dll/</link><pubDate>Thu, 18 Jan 2024 18:55:00 +0000</pubDate><guid>https://www.wcq.life/docs/os/dll/</guid><description>linux下静态库 &amp;amp;&amp;amp; 动态库 差异区别 # 编译连接静态库时, 会copy一份静态库镜像到目标文件; 编译连接动态库时, 不会copy 程序运行时, 无须再去访问原静态库; 程序运行时, 要能访问到动态库文件 静态库 .a 动态库 .so (shared object) 生成方式 # 静态库 A.由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表 B.ar命令将很多.o转换成.a，生成文静态库 动态库 A.gcc 加特定参数 编译 fPIC生成动态的.o文件; shared把动态.o文件打包为动态库 gcc -fPIC file1.c -c //这一步生成file1.o gcc -shared file1.o -o libtest.so //把.o文件打包为动态库(.o文件必须是 fPIC生成) 常见问题 # 运行时候找不到动态库, 处理方式 （1) 最直接最简单的方法就是把so拉到/usr/lib或/lib中去，但这好像有点污染环境吧？ （2）export LD_LIBRARY_PATH=$(pwd) （3）可以在/etc/ld.so.conf文件里加入我们生成的库的目录，然后/sbin/ldconfig 加载动态库 函数原型：void *dlopen(const char *libname,int flag); 参数中的libname一般是库的全路径，这样dlopen会直接装载该文件； 如果只是指定了库名称，在dlopen在查找库的过程中会按照如下路径进行搜索： a.根据环境变量LD_LIBRARY_PATH查找 b.根据/etc/ld.so.cache查找 c.查找依次在/lib和/usr/lib目录查找。 flag参数表示处理未定义函数的方式，可以使用RTLD_LAZY或RTLD_NOW。 RTLD_LAZY表示暂时不去处理未定义函数，先把库装载到内存，等用到没定义的函数再说； RTLD_NOW表示马上检查是否存在未定义的函数，若存在，则dlopen以失败告终。 动态库再认知 # 结论 # 动态库允许延迟定义, 但是在连接为可执行文件时, 所有动态库的声明必须有定义 测试 # A 依赖libbase.</description></item><item><title>redis</title><link>https://www.wcq.life/docs/tool/redis/</link><pubDate>Thu, 18 Jan 2024 19:19:00 +0000</pubDate><guid>https://www.wcq.life/docs/tool/redis/</guid><description>&lt;p>redis学习记录 &lt;br/>&lt;/p></description></item><item><title>数据库</title><link>https://www.wcq.life/docs/tool/sql/</link><pubDate>Thu, 18 Jan 2024 19:19:00 +0000</pubDate><guid>https://www.wcq.life/docs/tool/sql/</guid><description>&lt;p>数据库开发 &lt;br/>&lt;/p></description></item><item><title>乱七八糟的协议合集</title><link>https://www.wcq.life/docs/tool/protocol/</link><pubDate>Thu, 18 Jan 2024 19:19:00 +0000</pubDate><guid>https://www.wcq.life/docs/tool/protocol/</guid><description>&lt;p>协议太多, 不好分类, 真是乱七八糟 &lt;br/>&lt;/p></description></item><item><title>rup架构图</title><link>https://www.wcq.life/posts/rup/</link><pubDate>Tue, 13 Jun 2023 00:56:00 +0000</pubDate><guid>https://www.wcq.life/posts/rup/</guid><description>&lt;p>RUP4+1架构图 &lt;br/>&lt;/p></description></item><item><title/><link>https://www.wcq.life/posts/readme/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://www.wcq.life/posts/readme/</guid><description> 目录说明 # path desc org blog org源码 static hugo静态文件 config.toml hugo配置文件 流程 # push触发github action 下载 clay9/emacs.git 执行init-for-script.el, export org to md 执行hugo的编译, export md to html 执行hugo的发布</description></item></channel></rss>