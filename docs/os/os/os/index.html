<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="os学习整理 "><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://clay9.github.io/blog/docs/os/os/os/"><meta property="og:site_name" content="飘"><meta property="og:title" content="os"><meta property="og:description" content="os学习整理"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2024-05-31T18:18:00+00:00"><meta property="article:modified_time" content="2025-09-09T20:38:40+00:00"><title>os | 飘</title><link rel=icon href=/blog/favicon.png><link rel=manifest href=/blog/manifest.json><link rel=canonical href=https://clay9.github.io/blog/docs/os/os/os/><link rel=stylesheet href=/blog/book.min.27cffe658670f57112663ed746a421db277c2dd6549965c27f9ad0103cccd990.css integrity="sha256-J8/+ZYZw9XESZj7XRqQh2yd8LdZUmWXCf5rQEDzM2ZA=" crossorigin=anonymous><script defer src=/blog/fuse.min.js></script><script defer src=/blog/en.search.min.73e27280d3bf2e1edef453a06549351c2891f2e9d786dd66805d8e4d819f27a8.js integrity="sha256-c+JygNO/Lh7e9FOgZUk1HCiR8unXht1mgF2OTYGfJ6g=" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-docs book-layout-"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/blog/><span>飘</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-991bd30d46a386cace03b4f84b11c8f5 class=toggle checked>
<label for=section-991bd30d46a386cace03b4f84b11c8f5 class=flex><a role=button class=flex-auto>os</a></label><ul><li><a href=/blog/docs/os/mac/>mac</a></li><li><a href=/blog/docs/os/linux/>linux</a></li><li><input type=checkbox id=section-f866724d2acb7e76aaac59a04f639ef7 class=toggle checked>
<label for=section-f866724d2acb7e76aaac59a04f639ef7 class=flex><a role=button class=flex-auto>os</a></label><ul><li><a href=/blog/docs/os/os/os/ class=active>os</a></li><li><a href=/blog/docs/os/os/memory_01/>memory 01</a></li></ul></li><li><a href=/blog/docs/os/dll/>静态库 && 动态库</a></li><li><input type=checkbox id=section-ab3af5bd51cb4c263c32a78225fa580c class=toggle>
<label for=section-ab3af5bd51cb4c263c32a78225fa580c class=flex><a role=button class=flex-auto>socket</a></label><ul><li><a href=/blog/docs/os/socket/socket/>socket base</a></li><li><a href=/blog/docs/os/socket/asio/>asio</a></li></ul></li><li><a href=/blog/docs/os/test/>test</a></li></ul></li><li><input type=checkbox id=section-3fa40444857bc94b52ee0d09f552885c class=toggle>
<label for=section-3fa40444857bc94b52ee0d09f552885c class=flex><a role=button class=flex-auto>emacs</a></label><ul><li><a href=/blog/docs/emacs/emacs/>emacs</a></li><li><input type=checkbox id=section-bc70934d4e2c8d9a7868939ae442d96c class=toggle>
<label for=section-bc70934d4e2c8d9a7868939ae442d96c class=flex><a role=button class=flex-auto>org && gtd</a></label><ul><li><a href=/blog/docs/emacs/org/org/>org</a></li><li><a href=/blog/docs/emacs/org/gtd/>gtd</a></li><li><a href=/blog/docs/emacs/org/org_gtd/>org && gtd</a></li><li><a href=/blog/docs/emacs/org/org_export/>org exprot && ox-hugo</a></li></ul></li><li><input type=checkbox id=section-d284c356736fd9574da0dde99d385b68 class=toggle>
<label for=section-d284c356736fd9574da0dde99d385b68 class=flex><a role=button class=flex-auto>常用扩展</a></label><ul><li><a href=/blog/docs/emacs/lisp/eshell/>eshell</a></li><li><a href=/blog/docs/emacs/lisp/tramp/>tramp</a></li><li><a href=/blog/docs/emacs/lisp/graph/>artist && plantuml</a></li><li><a href=/blog/docs/emacs/lisp/mail/>mail</a></li><li><a href=/blog/docs/emacs/lisp/gdb/>gdb && gud</a></li><li><a href=/blog/docs/emacs/lisp/ai/>AI</a></li></ul></li></ul></li><li><input type=checkbox id=section-acf0594e7a1234c2d7cae5f23b06f240 class=toggle>
<label for=section-acf0594e7a1234c2d7cae5f23b06f240 class=flex><a role=button class=flex-auto>prog language</a></label><ul><li><input type=checkbox id=section-2468564b5fcc8dbb0ecf9a3acd8aaecd class=toggle>
<label for=section-2468564b5fcc8dbb0ecf9a3acd8aaecd class=flex><a role=button class=flex-auto>c++</a></label><ul><li><a href=/blog/docs/prog_language/c++/c++/>c++历史</a></li><li><a href=/blog/docs/prog_language/c++/stl/>C && C++ 常见库</a></li></ul></li><li><a href=/blog/docs/prog_language/elisp/>elisp</a></li><li><a href=/blog/docs/prog_language/shell/>shell</a></li></ul></li><li><input type=checkbox id=section-546918d455c17ba2747a13b59a082aee class=toggle>
<label for=section-546918d455c17ba2747a13b59a082aee class=flex><a role=button class=flex-auto>prog lsp</a></label><ul><li><a href=/blog/docs/prog_lsp/global/>global</a></li></ul></li><li><input type=checkbox id=section-afc89fa4b07162f1d84ad00ac7dc9100 class=toggle>
<label for=section-afc89fa4b07162f1d84ad00ac7dc9100 class=flex><a role=button class=flex-auto>prog compile</a></label><ul><li><a href=/blog/docs/prog_compile/autotools/>autotools</a></li><li><a href=/blog/docs/prog_compile/make/>make</a></li><li><a href=/blog/docs/prog_compile/cmake/>cmake</a></li><li><a href=/blog/docs/prog_compile/gcc/>gcc</a></li></ul></li><li><input type=checkbox id=section-11c3ec22a7b18dd97ab270ab2478f4f6 class=toggle>
<label for=section-11c3ec22a7b18dd97ab270ab2478f4f6 class=flex><a role=button class=flex-auto>prog debug</a></label><ul><li><a href=/blog/docs/prog_debug/gdb/>gdb</a></li><li><a href=/blog/docs/prog_debug/valgrind/>valgrind</a></li></ul></li><li><input type=checkbox id=section-e28331ccf58c3495c420d802b774d229 class=toggle>
<label for=section-e28331ccf58c3495c420d802b774d229 class=flex><a role=button class=flex-auto>prog vc</a></label><ul><li><a href=/blog/docs/prog_vc/git/>git</a></li></ul></li><li><input type=checkbox id=section-5a14b397bf7b143e435d509e6ce0a2f4 class=toggle>
<label for=section-5a14b397bf7b143e435d509e6ce0a2f4 class=flex><a role=button class=flex-auto>prog base</a></label><ul><li><a href=/blog/docs/prog_base/base/>图灵机 && lambda演算</a></li><li><a href=/blog/docs/prog_base/programming_paradigm/>编程范式</a></li><li><a href=/blog/docs/prog_base/principles/>设计原则</a></li><li><a href=/blog/docs/prog_base/design_pattern/>设计模式</a></li><li><a href=/blog/docs/prog_base/algorithm/>数据结构与算法分析</a></li></ul></li><li><input type=checkbox id=section-a21c7c1e5253f7258b54a084bca47bcd class=toggle>
<label for=section-a21c7c1e5253f7258b54a084bca47bcd class=flex><a role=button class=flex-auto>tools</a></label><ul><li><a href=/blog/docs/tool/docker/>docker</a></li><li><a href=/blog/docs/tool/k8s/>k8s</a></li><li><a href=/blog/docs/tool/monitor/>cadvisor, prometheus, grafana</a></li><li><a href=/blog/docs/tool/hugo/>hugo</a></li><li><a href=/blog/docs/tool/redis/>redis</a></li><li><a href=/blog/docs/tool/sql/>数据库</a></li><li><a href=/blog/docs/tool/protocol/>乱七八糟的协议合集</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/blog/svg/menu.svg class=book-icon alt=Menu></label><h3>os</h3><label for=toc-control><img src=/blog/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#启动过程>启动过程</a></li><li><a href=#线程创建-与-切换>线程创建 与 切换</a></li><li><a href=#信号量>信号量</a></li><li><a href=#临界区--原子操作>临界区(原子操作)</a></li><li><a href=#内存-段>内存 段</a><ul><li><a href=#多级页表-与-快表>多级页表 与 快表</a></li></ul></li><li><a href=#register-寄存器>register 寄存器</a><ul><li><a href=#通用寄存器--数据寄存器>通用寄存器 (数据寄存器)</a></li><li><a href=#段寄存器>段寄存器</a></li><li><a href=#索引寄存器>索引寄存器</a></li><li><a href=#状态和控制寄存器>状态和控制寄存器</a></li></ul></li><li><a href=#待整理-todonow>待整理 TODONOW</a></li><li><a href=#q-and-a>Q & A</a></li></ul></nav></aside></header><article class="markdown book-article"><p>os学习整理<br></p><h2 id=启动过程>启动过程
<a class=anchor href=#%e5%90%af%e5%8a%a8%e8%bf%87%e7%a8%8b>#</a></h2><ol><li>开机时, CS=0xFFFF, IP=0x0000<br></li><li>寻址0xFFFF0 (ROM BIOS映射区)<br>BIOS: basic input/output system<br></li><li>检查RAM, 键盘, 显示器等硬件(尤其主板)<br></li><li>将磁盘0磁道0扇区(512 bit)读入0x7c00位置<br>这里就是引导扇区<br></li><li>设置CS=0x7c0, IP=0x0000<br></li></ol><h2 id=线程创建-与-切换>线程创建 与 切换
<a class=anchor href=#%e7%ba%bf%e7%a8%8b%e5%88%9b%e5%bb%ba-%e4%b8%8e-%e5%88%87%e6%8d%a2>#</a></h2><ol><li><p>用户级线程的创建 与 切换<br>创建:<br></p><ol><li>创建了新的TCB<br></li><li>初始化了栈<br></li></ol><p>切换:<br></p><ol><li>通过调用yeild来实现.<br>yeild中只需要切换TCB即可<br></li></ol></li><li><p>内核级线程的创建 与 切换<br>用户级线程 与 内核级线程 切换:<br>int: 用户 => 内核<br>iret: 内核 => 用户<br></p><p>内核级线程的切换:<br>类比yeild即可<br></p><p>内核级线程的创建:<br></p><ol><li>创建TCB<br></li><li>初始化栈<br></li></ol><p>注:<br>int的时候, 硬件往内核的TCB中压入了一下信息<br>SS:SP(栈信息), EFLAGS(??), IP,CS(PC信息), 1000(内核自身的栈调用?)<br></p></li></ol><h2 id=信号量>信号量
<a class=anchor href=#%e4%bf%a1%e5%8f%b7%e9%87%8f>#</a></h2><ol><li><p>信号量<br></p><pre><code class=language-text>信号量就是资源
</code></pre><p>信号量sem 表示的是可用资源的个数<br>负数 : 表示资源已被用完<br>正数 : 表示有可用的资源<br>这里只对资源不可用检测, 不会资源上限检测<br></p><p>//结构体<br>struct Semaphore<br>{<br>int count;<br>PCB* queue;<br>}<br></p><p>//函数<br>P(sem): 消耗资源; P在苏兰语中是test的意思<br>V(sem): 产生资源; V在苏兰语中是add的意思<br></p><p>// <del>信号量 被舍弃的原因</del> 在C++20中增加了std::semaphore(与系统的semaphore不同, 只能在同进程的线程间同步)<br></p><ol><li>信号量语义不明.<br>既可以用来表示互斥, 又可以用来表示同步<br>互斥可以使用mutex代替;<br>同步可以使用condition代替.<br></li><li>加锁, 解锁不在一个线程, 容易导致错误<br>信号量的加解锁可以不在统一个线程(进程), 容易导致错误, 且不容易发现;<br>mutex规定了必须在同一个线程加解锁, 容易发现错误<br></li></ol></li><li><p>生产者, 消费者中 使用2个信号量来处理<br>第一个信号量 表示一共有多少个位置可用(缓冲区可用位置)<br></p><pre><code class=language-text>producer消耗(--)该资源, consumer产生(++)该资源
</code></pre><p>第二个信号量 表示当前缓冲区的个数<br></p><pre><code class=language-text>producer产生该资源, consumer消耗该资源
</code></pre></li></ol><h2 id=临界区--原子操作>临界区(原子操作)
<a class=anchor href=#%e4%b8%b4%e7%95%8c%e5%8c%ba--%e5%8e%9f%e5%ad%90%e6%93%8d%e4%bd%9c>#</a></h2><ol><li><p>临界区 (原子操作)<br>原则:<br></p><ol><li>互斥进入<br></li><li>有空让进<br></li><li>有限等待<br></li></ol><p>如何生成临界区:<br></p><ol><li><p>软件方法<br>a. Peterson算法(2个线程)<br>b. filter算法(多个线程)<br></p></li><li><p>硬件方法<br>a. 关中断, 处理完之后, 再开中断 (不适用现在的硬件了, 现在基本都是多cpu)<br></p><pre><code class=language-text>关中断之后, 就不会切换进程了. 所以就是临界区了.
但是多cpu无效. 因为中断与cpu绑定
</code></pre><p>b. 原子指令 (mutex)<br></p><pre><code class=language-text>不会被打断的指令即原子指令. 由硬件设计的
</code></pre></li></ol></li></ol><h2 id=内存-段>内存 段
<a class=anchor href=#%e5%86%85%e5%ad%98-%e6%ae%b5>#</a></h2><p>找到一块空闲的内存, 把程序放入内存, 然后由cpu取指执行<br>逻辑地址 => 物理地址的 重定位<br></p><pre><code class=language-text>可以在 编译, 载入, 运行 时重定位
</code></pre><p>运行时重定位 => 地址翻译<br>为了能够运行时重定位, 需要进程可以在内存中换入,换出<br></p><p>//段 : 实际对应的虚拟内存<br>为了更好的管理内存, 对进程进行了分段, 不同类型的代码(数据)放入不同的段(寄存器)<br>比如代码放入cs, 数据放入ds, 栈放入ss, 函数库(lib,dll)放入其他的寄存器(??)<br>每个段(寄存器)都有不同的特性(属性), 比如代码段不应该修改, 堆栈是可增长的, 函数库按需加载或不加载<br>PCB中存放 段的信息即进程段表LDT(存放在寄存器LDTR中 R:register)<br>而且LDT 和 GDT非常类似. GDT是OS的段表, LDT是进程的段表<br></p><pre><code class=language-text>分段更像是从人(程序员)的角度 去管理的内存
</code></pre><p>//页 : 实际对应的物理内存<br>os初始化的时候, mem_map中的初始化<br></p><pre><code class=language-text>分页是从内存(机器)的角度 去管理的内存
</code></pre><p>//段 与 页<br>把段分割成页. 比如代码段需要2.3页, 那么就给它3页.<br>在内存中找未使用的3页<br></p><p>这3页分配到的内存可能是不连续的.<br>所以段需要知道 对应的 内存地址<br>使用页表(在寄存器cr3中)来表示.<br>所以每个段都有自己的页表<br>段分割成的页就是虚拟地址, 虚拟地址和页框(物理页)通过MMU硬件转换<br></p><table><thead><tr><th>段->页</th><th>页框(物理页)</th><th>保护</th></tr></thead><tbody><tr><td>0</td><td>5</td><td>R</td></tr><tr><td>1</td><td>7</td><td>R/W</td></tr><tr><td>2</td><td>6</td><td>R</td></tr></tbody></table><p>#offset# &ndash; #page#<br>0-12 &ndash; 12-15<br>jmp [0x2240]<br>就是0x2240 右移12bit, 即0x2; 说明jmp 到第2页.<br>再从页表中找到第二页对应的页框(物理页), 找到页框6<br>对应的物理地址就是 页框6 + offset, 即0x6240<br></p><p>0x2240 -> 0x6240的获取是由硬件(MMU)计算的<br></p><p>//总结1<br>程序由多个段组成, 每个段切割成多个页放到物理内存中的页中.<br>以后根据页表查找内存地址<br></p><p>//总结2<br>process -> segment -> page(virtual) -> page(物理)<br></p><ol><li>先建立段表 LDT (放到寄存器)<br></li><li>每个段建立 页表(v->物理)<br>virtual page就是虚拟内存<br>页表放到内存中的<br></li></ol><h3 id=多级页表-与-快表>多级页表 与 快表
<a class=anchor href=#%e5%a4%9a%e7%ba%a7%e9%a1%b5%e8%a1%a8-%e4%b8%8e-%e5%bf%ab%e8%a1%a8>#</a></h3><p>为了提高内存空间利用率, 单张页应该小. 导致进程的页表非常大 (4G内存/4K页大小 = 1M)<br>页大小为4K, 地址是32位的. 就会有2^20个页面.<br>如果2^20页面都放入内存中, 就需要4M内存. 单个进程就需要这么大了, 100个进程, 就需要400M了<br>实际上, 2^20中的大部分项都不会用到. 所以可以把页表改小<br>所以引入多级页表和快表, 用来减少页表大小<br></p><table><thead><tr><th>页号</th><th>物理页</th><th>保护</th><th></th><th>页号</th><th>物理页</th><th>保护</th></tr></thead><tbody><tr><td>0</td><td>5</td><td>R</td><td></td><td>0</td><td>5</td><td>R</td></tr><tr><td>1</td><td>1</td><td>R/W</td><td># 修改为=> #</td><td>1</td><td>1</td><td>R/W</td></tr><tr><td>2</td><td></td><td></td><td></td><td>3</td><td>4</td><td>R</td></tr><tr><td>3</td><td>4</td><td>R</td><td></td><td></td><td></td><td></td></tr></tbody></table><pre><code class=language-text>新的页表, 不再连续, 但是已经排好序了. 可以使用二分法查找 log(2^20)=20
因为页表在内存中, 导致每次操作内存, 都会额外查找20次. 导致机器性能下降10-20%
所以这种页表 虽然节省了内存空间, 但是性能降低太多了
</code></pre><p>//多级页表<br></p><p>10bits &ndash; 10bits &ndash; 12bits<br>多级页表空间上高效了, 但是效率降低了;<br>增加了一层访问, 要先看章再看节.<br>所以多访问了一次内存(章).<br></p><p>//快表 (TLB)<br>TLB是一组相连快速存储, 是寄存器.<br>可以非常快速的找到最近逻辑页使用的物理页号<br></p><p>//快表 与 多级页表<br>如果 快表命中, 则直接使用快表, 非常快<br>否则, 使用多级页表<br></p><p>//总结<br>虚拟内存->物理 (硬件MMU处理)<br>为了减少页表的内存size, 使用多级页表<br>为了加快访问, 使用快表(TLB)<br></p><p>TLB能显著加快访问速度, 因为只需要在内存中读取一次,<br>而多级页表在32bits中需要读取2次(先读章,再读节)<br></p><h2 id=register-寄存器>register 寄存器
<a class=anchor href=#register-%e5%af%84%e5%ad%98%e5%99%a8>#</a></h2><p>常用register<br></p><h3 id=通用寄存器--数据寄存器>通用寄存器 (数据寄存器)
<a class=anchor href=#%e9%80%9a%e7%94%a8%e5%af%84%e5%ad%98%e5%99%a8--%e6%95%b0%e6%8d%ae%e5%af%84%e5%ad%98%e5%99%a8>#</a></h3><p>ax, bx, cx, dx (rax, rbx, rcx, rdx)<br>一般用来存放数据, 也就数据寄存器<br></p><p>AX(Accumulator Register) ：累加寄存器，它主要用于输入/输出和大规模的指令运算。<br>BX(Base Register)：基址寄存器，用来存储基础访问地址<br>CX(Count Register)：计数寄存器，CX 寄存器在迭代的操作中会循环计数<br>DX(data Register)：数据寄存器，它也用于输入/输出操作。它还与 AX 寄存器以及 DX 一起使用，用于涉及大数值的乘法和除法运算。<br></p><h3 id=段寄存器>段寄存器
<a class=anchor href=#%e6%ae%b5%e5%af%84%e5%ad%98%e5%99%a8>#</a></h3><p>CS(Code Segment) ：代码寄存器，程序代码的基础位置<br>DS(Data Segment)：数据寄存器，变量的基本位置<br>SS(Stack Segment)：栈寄存器，栈的基础位置<br>ES(Extra Segment)：其他寄存器，内存中变量的其他基本位置。<br></p><p><a href=https://zhuanlan.zhihu.com/p/324210723>https://zhuanlan.zhihu.com/p/324210723</a><br></p><h3 id=索引寄存器>索引寄存器
<a class=anchor href=#%e7%b4%a2%e5%bc%95%e5%af%84%e5%ad%98%e5%99%a8>#</a></h3><p>BP(Base Pointer)：基础指针，它是栈寄存器上的偏移量，用来定位栈上变量<br>SP(Stack Pointer): 栈指针，它是栈寄存器上的偏移量，用来定位栈顶<br>SI(Source Index): 变址寄存器，用来拷贝源字符串<br>DI(Destination Index): 目标变址寄存器，用来复制到目标字符串<br></p><h3 id=状态和控制寄存器>状态和控制寄存器
<a class=anchor href=#%e7%8a%b6%e6%80%81%e5%92%8c%e6%8e%a7%e5%88%b6%e5%af%84%e5%ad%98%e5%99%a8>#</a></h3><p>IP(Instruction Pointer)：指令指针寄存器，它是从 Code Segment 代码寄存器处的偏移来存储执行的下一条指令<br>FLAG: Flag 寄存器用于存储当前进程的状态<br></p><h2 id=待整理-todonow>待整理 TODONOW
<a class=anchor href=#%e5%be%85%e6%95%b4%e7%90%86-todonow>#</a></h2><ol><li><p>图灵机 => 通用图灵机<br>图灵机的控制器是单一的, 比如只能计算加法的加法控制器<br>通用图灵机是指 控制器通用了<br></p></li><li><p>PC, IP, CS<br>CS, IP是两个寄存器. 通过两个寄存器的值运算得到指令的地址, 也就是PC的值<br></p><p>CS: code segment 代码段寄存器<br>IP: instruction pointer 指令指针寄存器<br>PC: program count 程序计数器<br></p><p>16位机: CS&lt;&lt;4 + IP 只有20bit. 能访问的内存很小<br>32位机(即保护模式): PC = 根据CS在gdt中查表 + IP<br>gdt: global describe table(硬件设置的)<br></p></li><li><p>POSIX 指定了标准的系统调用(system_call)<br>POSIX: Portable Operating System Interface of Unix<br></p></li><li><p>系统调用 != 函数调用<br></p><ol><li>系统调用 不能像 普通函数调用那样直接jump<br></li><li>防止直接jump的手段 是通过硬件设计完成的<br>内核态, 用户态<br>不允许从用户段jump到内核段<br></li><li>普通函数 想访问 系统调用(内核函数), 只能通过中断(int 0x80)<br>int 0x80 会把CPL设置为0, 允许用户段访问内核段<br></li></ol></li><li><p>多进程<br>共用cpu, 所以有了PCB<br>共用内存, 所以有了 虚拟内存(内存映射)<br></p></li><li><p>cpu调度算法<br></p><pre><code class=language-text>使用单变量counter可以完美实现, 参考linux 0.11
</code></pre><ol><li>FIFO (公平原则)<br></li><li>短作业优先<br></li><li>轮转调度 Robin<br></li><li>优先级<br></li></ol></li><li><p>锁很慢, 慢在哪<br>//锁机制<br>尝试使用硬件指令获得锁(现在一般是 compare and swap),<br>如果获得失败, 则使用内核提供的锁调用.<br></p><p>//慢的原因<br></p><ol><li>跨cpu调度 (> 2000ns)<br></li><li>cpu自身调度 (900ns)<br></li><li>上下文切换 (150ns)<br></li><li>cache不命中 (消耗时间??)<br></li><li>TLB不命中 (这是什么?? 消耗时间??)<br></li></ol><p>//优化<br></p><pre><code class=language-text>本质是减少锁冲突
</code></pre><ol><li>颗粒度. 加锁的范围要小<br>不要在锁的过程中做阻塞操作<br></li><li>使用读写锁. 读操作之间不互斥<br></li><li>自旋锁<br>如果锁的时间 &lt; 调度时间, 那么可以自旋<br>自旋: 循环调用硬件指令获得锁 compare and swap, 一般100次左右<br></li></ol></li></ol><h2 id=q-and-a>Q & A
<a class=anchor href=#q-and-a>#</a></h2><ol><li><p><input disabled type=checkbox> 如果高级语言C, C++都是在系统调用(system_call),<br>那么std::cout 和 printf 为什么会有差异<br>效率的差异主要体现在哪??<br></p></li><li><p><input disabled type=checkbox> schedule()=>switch_to() 中为什么需要用汇编来精准控制?<br>教程中说是需要精准控制寄存器.<br>那么在计算机中, 寄存器的状态是怎样的<br></p></li><li><p><input disabled type=checkbox> 多进程通信中的 同步问题<br>产生同步问题的根因: 多进程交互执行<br>原子操作, 锁 等都可以解决同步问题<br></p></li><li><p><input disabled type=checkbox> 函数调用栈 && 寄存器信息 保存在TCB中,<br>那么PCB中会保存什么信息?<br></p></li><li><p><input checked disabled type=checkbox> 函数栈, TCB, esp之间的关系<br>函数栈: 函数调用栈<br>TCB: 除了关联(has?)函数栈, 还有PC信息<br>esp: 寄存器?? 这是什么的寄存器? 或者说 寄存器的作用<br></p><p>A:<br>寄存器类型:<br>ax,bx,cx,dx, cs,ds,ss, ip, sp<br></p><p>sp是16 bit; 后来有了32bit的, 就改名esp; 再后来又有了64bit的, 起名rsp<br></p></li><li><p><input disabled type=checkbox> 为什么没有觉得操作系统很复杂??<br>当前进度: 多进程视图中的 进程切换<br>后续:<br></p><ol><li>多进程通信(同步)<br></li><li>mem, file 等其他视图<br></li></ol></li><li><p><input disabled type=checkbox> 中断本质是什么<br></p></li><li><p><input disabled type=checkbox> 指令流水是什么?<br></p></li><li><p><input disabled type=checkbox> L12 <span class=org-target id=org-target--------></span> 再学习<br></p><ol><li>先自己画图<br></li><li>再自己写一遍代码<br></li><li>与课程中的对照<br></li></ol></li><li><p><input checked disabled type=checkbox> 信号量课程, 添加了sem之后, 还是需要从唤醒队列中拿取.<br>既然这样, 直接从唤醒队列中拿取就可以了, 为什么还需要sem<br>sem表示了资源的个数, 只有资源被消耗完之后, 才会变为-1,-2.<br></p></li><li><p><input checked disabled type=checkbox> 信号量课程, 如何保证sem的准确(锁? 原子操作)<br>参考 临界区<br></p></li><li><p><input disabled type=checkbox> cpu流水指令, cache缓存<br></p></li><li><p><input disabled type=checkbox> CAS compare and swap 实现逻辑<br></p></li><li><p><input disabled type=checkbox> 使用银行家算法 来判断是否会 死锁<br>是否可使用向量来判断?<br></p></li><li><p><input disabled type=checkbox> 进程页表中的逻辑地址为什么不会全部使用??<br>比如 有页表0,1,2,3. 但是可能只有0,1,3使用了, 但是2未使用<br></p><p>why ??<br>已知:<br></p><ol><li>进程 => (代码, 数据, 栈等)段 => 每个段都有自己的页表<br></li></ol><p>如果是这样, 为什么还会空着页号呢???<br>会不会之前申请了某块内存a(产生了页3), 继续申请(产生页4), 释放内存a, 所以页3空了??<br></p></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><div class="flex flex-wrap justify-between"><span><a href=/blog/docs/os/linux/ class="flex align-center book-icon"><img src=/blog/svg/backward.svg class=book-icon alt=Previous title=linux>
<span>linux</span>
</a></span><span><a href=/blog/docs/os/os/memory_01/ class="flex align-center book-icon"><span>memory 01</span>
<img src=/blog/svg/forward.svg class=book-icon alt=Next title="memory 01"></a></span></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#启动过程>启动过程</a></li><li><a href=#线程创建-与-切换>线程创建 与 切换</a></li><li><a href=#信号量>信号量</a></li><li><a href=#临界区--原子操作>临界区(原子操作)</a></li><li><a href=#内存-段>内存 段</a><ul><li><a href=#多级页表-与-快表>多级页表 与 快表</a></li></ul></li><li><a href=#register-寄存器>register 寄存器</a><ul><li><a href=#通用寄存器--数据寄存器>通用寄存器 (数据寄存器)</a></li><li><a href=#段寄存器>段寄存器</a></li><li><a href=#索引寄存器>索引寄存器</a></li><li><a href=#状态和控制寄存器>状态和控制寄存器</a></li></ul></li><li><a href=#待整理-todonow>待整理 TODONOW</a></li><li><a href=#q-and-a>Q & A</a></li></ul></nav></div></aside></main></body></html>