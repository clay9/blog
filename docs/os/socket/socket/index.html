<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="socket相关网络编程 "><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://clay9.github.io/blog/docs/os/socket/socket/"><meta property="og:site_name" content="飘"><meta property="og:title" content="socket base"><meta property="og:description" content="socket相关网络编程"><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2024-01-18T19:13:00+00:00"><meta property="article:modified_time" content="2025-11-18T10:16:03+00:00"><title>socket base | 飘</title><link rel=icon href=/blog/favicon.png><link rel=manifest href=/blog/manifest.json><link rel=canonical href=https://clay9.github.io/blog/docs/os/socket/socket/><link rel=stylesheet href=/blog/book.min.e456d10aed65d3bbdca94d70c236a8aa850b8de9fd31e4073ed44adec0702035.css integrity="sha256-5FbRCu1l07vcqU1wwjaoqoULjen9MeQHPtRK3sBwIDU=" crossorigin=anonymous><script defer src=/blog/fuse.min.js></script><script defer src=/blog/en.search.min.f56863818da70b29aa095af4ae434d177adf85f2223c7658d902a0f9ef3b0127.js integrity="sha256-9WhjgY2nCymqCVr0rkNNF3rfhfIiPHZY2QKg+e87ASc=" crossorigin=anonymous></script></head><body dir=ltr class="book-kind-page book-type-docs"><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/blog/><span>飘</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-991bd30d46a386cace03b4f84b11c8f5 class=toggle checked>
<label for=section-991bd30d46a386cace03b4f84b11c8f5 class=flex><a role=button>os</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/os/mac/>mac</a></li><li><a href=/blog/docs/os/linux/>linux</a></li><li><input type=checkbox id=section-f866724d2acb7e76aaac59a04f639ef7 class=toggle>
<label for=section-f866724d2acb7e76aaac59a04f639ef7 class=flex><a href=/blog/docs/os/os/>os</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/os/os/os/>os</a></li><li><a href=/blog/docs/os/os/memory_01/>memory 01</a></li><li><a href=/blog/docs/os/os/dll/>library</a></li></ul></li><li><input type=checkbox id=section-ab3af5bd51cb4c263c32a78225fa580c class=toggle checked>
<label for=section-ab3af5bd51cb4c263c32a78225fa580c class=flex><a role=button>socket</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/os/socket/socket/ class=active>socket base</a></li><li><a href=/blog/docs/os/socket/asio/>asio</a></li></ul></li></ul></li><li><input type=checkbox id=section-3fa40444857bc94b52ee0d09f552885c class=toggle>
<label for=section-3fa40444857bc94b52ee0d09f552885c class=flex><a role=button>emacs</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/emacs/emacs/>emacs</a></li><li><input type=checkbox id=section-bc70934d4e2c8d9a7868939ae442d96c class=toggle>
<label for=section-bc70934d4e2c8d9a7868939ae442d96c class=flex><a role=button>org</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/emacs/org/org/>org</a></li><li><a href=/blog/docs/emacs/org/org_agenda_for_gtd/>org agenda for GTD</a></li><li><a href=/blog/docs/emacs/org/org_for_hugo/>org for hugo</a></li><li><a href=/blog/docs/emacs/org/org_for_hugo_demo/>org for hugo demo</a></li></ul></li><li><input type=checkbox id=section-d284c356736fd9574da0dde99d385b68 class=toggle>
<label for=section-d284c356736fd9574da0dde99d385b68 class=flex><a role=button>常用扩展</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/emacs/lisp/eshell/>eshell</a></li><li><a href=/blog/docs/emacs/lisp/tramp/>tramp</a></li><li><a href=/blog/docs/emacs/lisp/graph/>画图</a></li><li><a href=/blog/docs/emacs/lisp/mail/>mail</a></li><li><a href=/blog/docs/emacs/lisp/gdb/>gdb && gud</a></li><li><a href=/blog/docs/emacs/lisp/ai/>AI</a></li></ul></li></ul></li><li><input type=checkbox id=section-acf0594e7a1234c2d7cae5f23b06f240 class=toggle>
<label for=section-acf0594e7a1234c2d7cae5f23b06f240 class=flex><a role=button>prog language</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><input type=checkbox id=section-2468564b5fcc8dbb0ecf9a3acd8aaecd class=toggle>
<label for=section-2468564b5fcc8dbb0ecf9a3acd8aaecd class=flex><a role=button>c++</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/prog_language/c++/c++/>c++历史</a></li><li><a href=/blog/docs/prog_language/c++/stl/>C && C++ 常见库</a></li></ul></li><li><a href=/blog/docs/prog_language/elisp/>elisp</a></li><li><a href=/blog/docs/prog_language/shell/>shell</a></li></ul></li><li><input type=checkbox id=section-546918d455c17ba2747a13b59a082aee class=toggle>
<label for=section-546918d455c17ba2747a13b59a082aee class=flex><a role=button>prog lsp</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/prog_lsp/global/>global</a></li></ul></li><li><input type=checkbox id=section-afc89fa4b07162f1d84ad00ac7dc9100 class=toggle>
<label for=section-afc89fa4b07162f1d84ad00ac7dc9100 class=flex><a role=button>prog compile</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/prog_compile/autotools/>autotools</a></li><li><a href=/blog/docs/prog_compile/make/>make</a></li><li><a href=/blog/docs/prog_compile/cmake/>cmake</a></li><li><a href=/blog/docs/prog_compile/gcc/>gcc</a></li></ul></li><li><input type=checkbox id=section-11c3ec22a7b18dd97ab270ab2478f4f6 class=toggle>
<label for=section-11c3ec22a7b18dd97ab270ab2478f4f6 class=flex><a role=button>prog debug</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/prog_debug/gdb/>gdb</a></li><li><a href=/blog/docs/prog_debug/valgrind/>valgrind</a></li></ul></li><li><input type=checkbox id=section-e28331ccf58c3495c420d802b774d229 class=toggle>
<label for=section-e28331ccf58c3495c420d802b774d229 class=flex><a role=button>prog vc</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/prog_vc/git/>git</a></li></ul></li><li><input type=checkbox id=section-5a14b397bf7b143e435d509e6ce0a2f4 class=toggle>
<label for=section-5a14b397bf7b143e435d509e6ce0a2f4 class=flex><a role=button>prog base</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/prog_base/01_turing/>图灵机</a></li><li><a href=/blog/docs/prog_base/02_lambda/>λ验算</a></li><li><a href=/blog/docs/prog_base/05_programming_paradigm/>编程范式</a></li><li><a href=/blog/docs/prog_base/06_principles/>设计原则</a></li><li><a href=/blog/docs/prog_base/07_design_pattern/>设计模式</a></li><li><a href=/blog/docs/prog_base/99_algorithm/>数据结构与算法分析</a></li><li><a href=/blog/docs/prog_base/91_algorithm/>算法分析</a></li><li><a href=/blog/docs/prog_base/95_solution_strategy/>解题思路</a></li></ul></li><li><input type=checkbox id=section-a21c7c1e5253f7258b54a084bca47bcd class=toggle>
<label for=section-a21c7c1e5253f7258b54a084bca47bcd class=flex><a role=button>tools</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/tool/docker/>docker</a></li><li><a href=/blog/docs/tool/k8s/>k8s</a></li><li><a href=/blog/docs/tool/monitor/>cadvisor, prometheus, grafana</a></li><li><a href=/blog/docs/tool/hugo/>hugo</a></li><li><a href=/blog/docs/tool/redis/>redis</a></li><li><a href=/blog/docs/tool/sql/>数据库</a></li><li><a href=/blog/docs/tool/protocol/>乱七八糟的协议合集</a></li></ul></li><li><input type=checkbox id=section-00470258e11beb8778cf3c8f3c62a5f8 class=toggle>
<label for=section-00470258e11beb8778cf3c8f3c62a5f8 class=flex><a role=button>philosophy</a>
<img src=/blog/icons/chevron-right.svg class=book-icon></label><ul><li><a href=/blog/docs/philosophy/gtd/>gtd</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/blog/icons/menu.svg class=book-icon alt=Menu></label><h3>socket base</h3><label for=toc-control><img src=/blog/icons/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#基本概念>基本概念</a><ul><li><a href=#socket>socket</a></li><li><a href=#socket问题>socket问题</a></li><li><a href=#i-o模型>I/O模型</a></li><li><a href=#epoll使用>epoll使用</a></li></ul></li><li><a href=#socket属性>socket属性</a><ul><li><a href=#keep-live机制>keep live机制</a></li></ul></li><li><a href=#编程实例>编程实例</a><ul><li><a href=#原始socket模型-recv中处理分包粘包>原始socket模型, recv()中处理分包粘包</a></li></ul></li><li><a href=#ipv4>ipv4</a></li></ul></nav></aside></header><article class="markdown book-article"><p>socket相关网络编程<br></p><h2 id=基本概念>基本概念<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5>#</a></h2><h3 id=socket>socket<a class=anchor href=#socket>#</a></h3><p>socket是 [应用层] 与 [传输层, 网络层] 之间的一个抽象层<br>它的出现是为了简化网络进程通信<br></p><h4 id=linux头文件>linux头文件<a class=anchor href=#linux%e5%a4%b4%e6%96%87%e4%bb%b6>#</a></h4><ol><li>usr/include/x86_64-linux-gnu/sys/socket.h<br>结构体<br>sockaddr<br>函数<br>socket() connect() send() recv() shutdown()<br>socket() bind() lisent() accept() recv() send() shutdown()<br>g++的默认目录中已经包含了sys/的上层目录<br></li><li>usr/include/netinet/in.h<br>结构体<br>AF_INET 中的 sockaddr_in<br>AF_INET6 中的 sockaddr_in6<br>AF_UNIx 中的 sockaddr_un<br></li><li>user/include/arpa/inet.h<br>函数<br>htons()<br>inet_addr()<br></li><li>unistd.h<br>函数<br>close()<br></li></ol><h4 id=socket函数>socket函数<a class=anchor href=#socket%e5%87%bd%e6%95%b0>#</a></h4><ol><li><p>socket(domain, socket_type, protol)<br>domain<br>socket_type<br>protol<br>socket()本质是创建了一个进程文件表, 返回的值为指向进程文件表的指针的索引.<br></p></li><li><p>bind(fd, sockaddr*, len)<br>fd: socket()中的文件表指针的索引<br>sockaddr: 地址, 端口<br>len: sockaddr的长度<br>&lt;1> 比较有意思的是sockaddr根据family的不同, 可以与不同的结构体互转<br>比如<br>AF_INET sockaddr_in<br>AF_INET6 sockaddr_in6<br>AF_UNIX sockaddr_un<br>这几种结构体都与sockaddr可互转(字节对齐blabla)<br>bind()本质是在补充socket()创建的文件表. socket()时候该文件表很多值都是空的, bind()来补充<br>因为client 在connect的时候, 系统会自动分配端口,以及绑定本机ip, 所以client的socket一般不必要<br>使用bind()<br></p></li><li><p>connet(fd, sockaddr*, len)<br>连接到其他scokaddr<br></p></li><li><p>listen(fd, iMaxNum)<br></p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>iMaxNum是队列中的最大数, 并不是指可连接的socket数目</span></span></code></pre></div><p>一般只在server开启listen(), 监听指定的端口信息<br></p></li><li><p>accept()<br>accept()会造成阻塞.<br>它会将listen()中的sockaddr进行处理<br>处理流程是 accept()会创建一个新的fd_connet, 此fd_connet公用server socket() fd的端口和地址<br>但是fd_connect仅仅是用来传输数据的<br></p></li><li><p>recv(fd, msg) send(fd, msg)<br>至accetp()时候, 一切操作就和在本地上操作一样,<br>所以这里的recv() 和 send()操作与本机上的文件操作是一样的<br></p></li><li><p>close(fd) shutdown(fd, type)<br>linux一切皆是file原则, fd可以关闭<br></p></li></ol><h4 id=ip-port-相关函数>[ip, port]相关函数<a class=anchor href=#ip-port-%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0>#</a></h4><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>点分十进制ip 是以字符串形式存储的
</span></span><span style=display:flex><span>网络字节序 即 32位的二进制</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//in_addr
</span></span><span style=display:flex><span>struct in_addr
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>　　in_addr_t s_addr;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//in_addr_t
</span></span><span style=display:flex><span>typedef unsigned long  in_addr_t</span></span></code></pre></div><ol><li><p>函数原型: in_addr_t inet_addr(const char* strptr);<br>若字符串有效, 则将点分十进制IP字符串转换为网络字节序地址，否则为INADDR_NONE<br></p></li><li><p>函数原型：int inet_aton(const char *IP, struct in_addr *addr);<br>将点分十进制IP地址转换为网络字节序存储在addr中，并且返回该网络字节序表示的无符号整数<br></p></li><li><p>函数原型：char *inet_ntoa(struct in_addr in);<br>将网络字节序的IP地址（也就是结构体in_addr类型变量）转化为点分十进制的IP地址（字符串)<br></p></li></ol><h4 id=socket-fd本质>socket fd本质<a class=anchor href=#socket-fd%e6%9c%ac%e8%b4%a8>#</a></h4><p>socket本质是维护了fd进程文件表, 如下:<br></p><table><thead><tr><th>名称</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>fd</td><td>文件描述符, 表的索引</td><td></td></tr><tr><td>host</td><td>1. 域名(DNS /etc/hosts) 2. ip地址</td><td>兼容Ipv4 Ipv6是难点</td></tr><tr><td>服务</td><td>1. 服务名称(/etc/services) 2. 端口</td><td></td></tr><tr><td>协议</td><td>1. 传输层(/etc/protol) 2. 网络层</td><td>链路层用到的比较少</td></tr><tr><td>网络</td><td>1. 网络名称?(DNS /etc/networks) 2. ip地址</td><td>谁会使用到这些信息??</td></tr></tbody></table><p>期间用到的函数主要有<br></p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>尽量使用ipv4, ipv6通用的函数</span></span></code></pre></div><ol><li>流程函数<br>socket() bind() listen() connect() accept()等<br></li><li>字节处理函数<br>处理大小字节序 htons() htonl() ntohs() ntohl()<br>处理域名与十分数字 getaddrinfo() getnameinfo()<br></li><li>处理sockaddr结构体的函数<br>getsockname() 返回local fd<br>getpeername() 返回remote fd<br></li></ol><h3 id=socket问题>socket问题<a class=anchor href=#socket%e9%97%ae%e9%a2%98>#</a></h3><ol><li><p>阻塞<br></p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>影响并发, 多路复用</span></span></code></pre></div><p>解决方案:<br></p><ol><li>使用非阻塞模型, 比如select, poll, epoll(linux下特有), IOCP(windows下特有)<br></li><li>多线程 &ndash; 不推荐使用<br></li><li>多进程 &ndash; 不推荐使用<br></li></ol></li><li><p>粘包<br>解决方案:<br></p><ol><li>限制发送大小<br></li><li>每个消息增加长度标识<br></li></ol></li></ol><h3 id=i-o模型>I/O模型<a class=anchor href=#i-o%e6%a8%a1%e5%9e%8b>#</a></h3><p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1565671711&amp;ver=1787&amp;signature=-mLkqQr803XDHb4f3aj9Lf1dJl8uVOV9fCCMMTzs0zSuOYH-qof7nsYCdgho1XLdPQYQP6QL5-WHtI6g-MD9xIsJcuxzdH*idpCZqtzl85r9D4C3XRRuOcCXqLKDzi-i&amp;new=1">强烈建议阅读</a><br>(链接过期, 直接搜狗搜索epoll, &ldquo;epoll本质"即是)<br></p><ol><li>阻塞式<br></li><li>非阻塞<br></li><li>select<br></li><li>poll<br></li><li>epoll (linux特有)<br></li><li>IOCP (windows特有)<br></li></ol><h3 id=epoll使用>epoll使用<a class=anchor href=#epoll%e4%bd%bf%e7%94%a8>#</a></h3><h4 id=epoll本身为我们处理了什么>epoll本身为我们处理了什么<a class=anchor href=#epoll%e6%9c%ac%e8%ba%ab%e4%b8%ba%e6%88%91%e4%bb%ac%e5%a4%84%e7%90%86%e4%ba%86%e4%bb%80%e4%b9%88>#</a></h4><ol><li>之前socket::recv()时, 导致我们的进程阻塞<br></li><li>现在socket::recv()时, 使epoll阻塞; epoll中断时, 告之进程<br></li></ol><h4 id=有了epoll我们还需要处理什么>有了epoll我们还需要处理什么<a class=anchor href=#%e6%9c%89%e4%ba%86epoll%e6%88%91%e4%bb%ac%e8%bf%98%e9%9c%80%e8%a6%81%e5%a4%84%e7%90%86%e4%bb%80%e4%b9%88>#</a></h4><ol><li>创建epoll对象<br></li><li>添加检视的fd对象 &ndash; op, epoll_event<br></li><li>检测是否有中断, 然后处理<br></li></ol><h2 id=socket属性>socket属性<a class=anchor href=#socket%e5%b1%9e%e6%80%a7>#</a></h2><h3 id=keep-live机制>keep live机制<a class=anchor href=#keep-live%e6%9c%ba%e5%88%b6>#</a></h3><p>当socket服务端开启keep live之后,<br>服务器检测到 <span class=underline>一定时间内</span> socket不活动的时候,<br>就会每隔 <span class=underline>固定时间</span> 向该sockt发送 <span class=underline>固定次数</span> 的查询.<br>如果一直没有回应, 服务端则关闭该socket<br></p><p>对应的字段为:<br></p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>tcp_keepalive_time（开启keepalive的闲置时长）
</span></span><span style=display:flex><span>tcp_keepalive_intvl（keepalive探测包的发送间隔）
</span></span><span style=display:flex><span>tcp_keepalive_probes （如果对方不予应答，探测包的发送次数）</span></span></code></pre></div><h2 id=编程实例>编程实例<a class=anchor href=#%e7%bc%96%e7%a8%8b%e5%ae%9e%e4%be%8b>#</a></h2><h3 id=原始socket模型-recv中处理分包粘包>原始socket模型, recv()中处理分包粘包<a class=anchor href=#%e5%8e%9f%e5%a7%8bsocket%e6%a8%a1%e5%9e%8b-recv%e4%b8%ad%e5%a4%84%e7%90%86%e5%88%86%e5%8c%85%e7%b2%98%e5%8c%85>#</a></h3><p>原始socket模型, 考虑到tcp分包<br></p><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#09f;font-style:italic>//网络读取 -- 系统检测到网络I/O事件时, 调用该函数
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>LRESULT CTCPSocketService<span style=color:#555>::</span>OnSocketNotifyRead(WPARAM wParam, LPARAM lParam)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>         <span style=color:#09f;font-style:italic>//读取数据
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>         <span style=color:#09f;font-style:italic>//使用中间量m+cbRecvbuf来当做缓冲区
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>         <span style=color:#09f;font-style:italic>//使用中间量m_wRecvsize来记录当前缓冲区中已读数据大小
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>         <span style=color:#078;font-weight:700>int</span> iRetCode <span style=color:#555>=</span> recv(m_hSocket, (<span style=color:#078;font-weight:700>char</span> <span style=color:#555>*</span>)m_cbRecvBuf <span style=color:#555>+</span> m_wRecvSize, <span style=color:#069;font-weight:700>sizeof</span>(m_cbRecvBuf) <span style=color:#555>-</span> m_wRecvSize, <span style=color:#f60>0</span>);
</span></span><span style=display:flex><span>         <span style=color:#09f;font-style:italic>//读取失败, 则返回SOCKET_ERROR
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>         <span style=color:#069;font-weight:700>if</span> (iRetCode <span style=color:#555>==</span> SOCKET_ERROR)
</span></span><span style=display:flex><span>         {
</span></span><span style=display:flex><span>             ZeroMemory(m_cbRecvBuf, <span style=color:#069;font-weight:700>sizeof</span>(m_cbRecvBuf));
</span></span><span style=display:flex><span>             m_wRecvSize <span style=color:#555>=</span> <span style=color:#f60>0</span>;
</span></span><span style=display:flex><span>             <span style=color:#069;font-weight:700>return</span> <span style=color:#f60>1</span>;<span style=color:#09f;font-style:italic>//&#34;网络连接关闭，读取数据失败&#34;;
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>         }
</span></span><span style=display:flex><span>         <span style=color:#09f;font-style:italic>//读取成功, 则返回读取到的数据的大小
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>         m_wRecvSize <span style=color:#555>+=</span> iRetCode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         <span style=color:#09f;font-style:italic>//在tcp数据中, 增加包的大小, 用来校验是否读取完毕;
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>         TCP_Head <span style=color:#555>*</span> pHead <span style=color:#555>=</span> (TCP_Head <span style=color:#555>*</span>)m_cbRecvBuf;
</span></span><span style=display:flex><span>         WORD wPacketSize <span style=color:#555>=</span> pHead<span style=color:#555>-&gt;</span>TCPInfo.wPacketSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>         <span style=color:#09f;font-style:italic>// //数据包大小校验
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>         <span style=color:#069;font-weight:700>if</span> (wPacketSize <span style=color:#555>&gt;</span> (SOCKET_TCP_BUFFER <span style=color:#555>+</span> <span style=color:#069;font-weight:700>sizeof</span>(TCP_Head)))
</span></span><span style=display:flex><span>         {
</span></span><span style=display:flex><span>             <span style=color:#09f;font-style:italic>//当发生错误时候, 缓冲区置位
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>             ZeroMemory(m_cbRecvBuf, <span style=color:#069;font-weight:700>sizeof</span>(m_cbRecvBuf));
</span></span><span style=display:flex><span>             m_wRecvSize <span style=color:#555>=</span> <span style=color:#f60>0</span>;
</span></span><span style=display:flex><span>             <span style=color:#069;font-weight:700>return</span> <span style=color:#f60>3</span>;<span style=color:#09f;font-style:italic>//&#34;数据包太大&#34;;
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>             }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             <span style=color:#09f;font-style:italic>//解析数据
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>             <span style=color:#069;font-weight:700>if</span> (m_wRecvSize <span style=color:#555>==</span> wPacketSize)  <span style=color:#09f;font-style:italic>//数据全部接受完毕之后 再解析
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>             {
</span></span><span style=display:flex><span>                 <span style=color:#09f;font-style:italic>//拷贝数据
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                 BYTE cbDataBuffer[SOCKET_TCP_BUFFER<span style=color:#555>+</span><span style=color:#069;font-weight:700>sizeof</span>(TCP_Head)];
</span></span><span style=display:flex><span>                 CopyMemory(cbDataBuffer, m_cbRecvBuf, wPacketSize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                 <span style=color:#09f;font-style:italic>//置位缓冲信息 -- 缓冲区中只保存一条tcp信息
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                 m_wRecvSize <span style=color:#555>=</span> <span style=color:#f60>0</span>;
</span></span><span style=display:flex><span>                 ZeroMemory(m_cbRecvBuf, <span style=color:#069;font-weight:700>sizeof</span>(m_cbRecvBuf));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                 <span style=color:#09f;font-style:italic>//解密数据
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                 WORD wRealySize <span style=color:#555>=</span> CrevasseBuffer(cbDataBuffer, wPacketSize);
</span></span><span style=display:flex><span>                 <span style=color:#069;font-weight:700>if</span>(wRealySize <span style=color:#555>&lt;</span> <span style=color:#069;font-weight:700>sizeof</span>(TCP_Head)) <span style=color:#069;font-weight:700>return</span> <span style=color:#f60>4</span>; <span style=color:#09f;font-style:italic>//解析后的数据错误
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span>                 <span style=color:#09f;font-style:italic>//获得TCP_Head
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                 TCP_Command Command <span style=color:#555>=</span> ((TCP_Head <span style=color:#555>*</span>)cbDataBuffer)<span style=color:#555>-&gt;</span>CommandInfo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                 <span style=color:#09f;font-style:italic>//获得实际的数据
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                 <span style=color:#078;font-weight:700>void</span> <span style=color:#555>*</span> pDataBuffer <span style=color:#555>=</span> cbDataBuffer <span style=color:#555>+</span> <span style=color:#069;font-weight:700>sizeof</span>(TCP_Head); <span style=color:#09f;font-style:italic>//实际的数据
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                 WORD wRealDataSize <span style=color:#555>=</span> wRealySize <span style=color:#555>-</span> <span style=color:#069;font-weight:700>sizeof</span>(TCP_Head);   <span style=color:#09f;font-style:italic>//实际的数据大小
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>
</span></span><span style=display:flex><span>                 <span style=color:#09f;font-style:italic>//内核命令
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                 <span style=color:#069;font-weight:700>if</span> (Command.wMainCmdID <span style=color:#555>==</span> MDM_KN_COMMAND)
</span></span><span style=display:flex><span>                 {
</span></span><span style=display:flex><span>                 <span style=color:#069;font-weight:700>switch</span> (Command.wSubCmdID)
</span></span><span style=display:flex><span>                 {
</span></span><span style=display:flex><span>                     <span style=color:#069;font-weight:700>case</span> <span style=color:#99f>SUB_KN_DETECT_SOCKET</span>:	<span style=color:#09f;font-style:italic>//网络检测
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                     {
</span></span><span style=display:flex><span>                         <span style=color:#09f;font-style:italic>//发送数据
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                         SendData(MDM_KN_COMMAND, SUB_KN_DETECT_SOCKET, pDataBuffer, wRealDataSize);
</span></span><span style=display:flex><span>                         <span style=color:#069;font-weight:700>break</span>;
</span></span><span style=display:flex><span>                     }
</span></span><span style=display:flex><span>                 }
</span></span><span style=display:flex><span>                 <span style=color:#069;font-weight:700>continue</span>;
</span></span><span style=display:flex><span>                 }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>                 <span style=color:#09f;font-style:italic>//处理数据
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>                 <span style=color:#078;font-weight:700>bool</span> bSuccess <span style=color:#555>=</span> m_QueueServiceEvent.PostTCPSocketReadEvent(m_wServiceID, Command, pDataBuffer, wRealDataSize);
</span></span><span style=display:flex><span>                 <span style=color:#069;font-weight:700>if</span> (bSuccess <span style=color:#555>==</span> <span style=color:#366>false</span>) <span style=color:#069;font-weight:700>return</span> <span style=color:#f60>5</span>;<span style=color:#09f;font-style:italic>//&#34;网络数据包处理失败&#34;;
</span></span></span><span style=display:flex><span><span style=color:#09f;font-style:italic></span>             };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>             <span style=color:#069;font-weight:700>return</span> <span style=color:#f60>0</span>;
</span></span><span style=display:flex><span>}</span></span></code></pre></div><h2 id=ipv4>ipv4<a class=anchor href=#ipv4>#</a></h2><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>系统文件在/proc/sys/net/ipv4下面</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ip_local_port_range # 用户端口范围, [n, m)
</span></span><span style=display:flex><span>tcp_timestamp       # 针对TIME_WAIT状态的tcp连接; 0关闭,1开启
</span></span><span style=display:flex><span>tcp_tw_recycle      # 是否快速回收+ linux内核已删除该字段
</span></span><span style=display:flex><span>tcp_tw_reuse        # TIME_WAIT状态的tcp的port是否可以复用;0关闭,1开启
</span></span><span style=display:flex><span>                    # 需要开启tcp_timestamp;
</span></span><span style=display:flex><span>		      # 这是针对cli的设计,而非svr
</span></span><span style=display:flex><span>tcp_rmem            # tcp read缓冲区
</span></span><span style=display:flex><span>tcp_wmem            # tcp write缓冲区</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=background-color:#f0f3f3;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ip_forward               0禁止ip转发, 1打开;
</span></span><span style=display:flex><span>ip_default_ttl           数据报的生存周期(time to live), 即最多经过多少路由器
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ip_no_pmtu_disc          关闭路径MTU探测
</span></span><span style=display:flex><span>min_pmtu                 最小路径MTU的大小
</span></span><span style=display:flex><span>mtu_expires              PMTU信息缓存多长时间</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"><div></div><div></div></div><div class="flex flex-wrap justify-between"><span><a href=/blog/docs/os/os/dll/ class="flex align-center"><img src=/blog/icons/backward.svg class=book-icon alt=Previous title=library>
<span>library</span>
</a></span><span><a href=/blog/docs/os/socket/asio/ class="flex align-center"><span>asio</span>
<img src=/blog/icons/forward.svg class=book-icon alt=Next title=asio></a></span></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script><div class=book-comments></div></footer><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#基本概念>基本概念</a><ul><li><a href=#socket>socket</a></li><li><a href=#socket问题>socket问题</a></li><li><a href=#i-o模型>I/O模型</a></li><li><a href=#epoll使用>epoll使用</a></li></ul></li><li><a href=#socket属性>socket属性</a><ul><li><a href=#keep-live机制>keep live机制</a></li></ul></li><li><a href=#编程实例>编程实例</a><ul><li><a href=#原始socket模型-recv中处理分包粘包>原始socket模型, recv()中处理分包粘包</a></li></ul></li><li><a href=#ipv4>ipv4</a></li></ul></nav></div></aside></main></body></html>