<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="socket相关网络编程 "><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://www.wcq.life/docs/os/socket/socket/"><meta property="og:site_name" content="飘"><meta property="og:title" content="socket base"><meta property="og:description" content="socket相关网络编程 "><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2024-01-18T19:13:00+00:00"><meta property="article:modified_time" content="2024-05-29T10:15:04+00:00"><title>socket base | 飘</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://www.wcq.life/docs/os/socket/socket/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.9f03ad42ec2c498926481d25f69b31aa168a88321da7af724fe77c156e687a05.js integrity="sha256-nwOtQuwsSYkmSB0l9psxqhaKiDIdp69yT+d8FW5oegU=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>飘</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-b352899f7eb963a33da348c348027b65 class=toggle checked>
<label for=section-b352899f7eb963a33da348c348027b65 class="flex justify-between"><a role=button>os</a></label><ul><li><a href=/docs/os/linux/>linux</a></li><li><a href=/docs/os/mac/>mac</a></li><li><a href=/docs/os/dll/>静态库 && 动态库</a></li><li><input type=checkbox id=section-0bd5f096bee3fdfea967307d0cc58cea class=toggle checked>
<label for=section-0bd5f096bee3fdfea967307d0cc58cea class="flex justify-between"><a role=button>socket</a></label><ul><li><a href=/docs/os/socket/socket/ class=active>socket base</a></li><li><a href=/docs/os/socket/asio/>asio</a></li></ul></li></ul></li><li><input type=checkbox id=section-6caca07a3711ff73965120347814c88e class=toggle>
<label for=section-6caca07a3711ff73965120347814c88e class="flex justify-between"><a role=button>emacs</a></label><ul><li><a href=/docs/emacs/emacs/>emacs</a></li><li><input type=checkbox id=section-fa106d5e2f4637bb0d3f0b2bb0c8a4cf class=toggle>
<label for=section-fa106d5e2f4637bb0d3f0b2bb0c8a4cf class="flex justify-between"><a role=button>org && gtd</a></label><ul><li><a href=/docs/emacs/org/org/>org</a></li><li><a href=/docs/emacs/org/gtd/>gtd</a></li><li><a href=/docs/emacs/org/org_gtd/>org && gtd</a></li><li><a href=/docs/emacs/org/org_export/>org exprot && ox-hugo</a></li></ul></li><li><input type=checkbox id=section-2ef79c58172b5bdd730d4a37c8089150 class=toggle>
<label for=section-2ef79c58172b5bdd730d4a37c8089150 class="flex justify-between"><a role=button>常用扩展</a></label><ul><li><a href=/docs/emacs/lisp/eshell/>eshell</a></li><li><a href=/docs/emacs/lisp/tramp/>tramp</a></li><li><a href=/docs/emacs/lisp/graph/>artist && plantuml</a></li><li><a href=/docs/emacs/lisp/mail/>mail</a></li><li><a href=/docs/emacs/lisp/gdb/>gdb && gud</a></li><li><a href=/docs/emacs/lisp/ai/>AI</a></li></ul></li></ul></li><li><input type=checkbox id=section-322c9b2e26449b2d642bd024a319aad8 class=toggle>
<label for=section-322c9b2e26449b2d642bd024a319aad8 class="flex justify-between"><a role=button>prog language</a></label><ul><li><input type=checkbox id=section-e4498ecbfd376ac8cbe8a22c1359c593 class=toggle>
<label for=section-e4498ecbfd376ac8cbe8a22c1359c593 class="flex justify-between"><a role=button>c++</a></label><ul><li><a href=/docs/prog_language/c++/c++/>c++历史</a></li><li><a href=/docs/prog_language/c++/stl/>C && C++ 常见库</a></li></ul></li><li><a href=/docs/prog_language/elisp/>elisp</a></li><li><a href=/docs/prog_language/shell/>shell</a></li></ul></li><li><input type=checkbox id=section-f082414e628ebd4ba49cf710b10f2cac class=toggle>
<label for=section-f082414e628ebd4ba49cf710b10f2cac class="flex justify-between"><a role=button>prog lsp</a></label><ul><li><a href=/docs/prog_lsp/global/>global</a></li></ul></li><li><input type=checkbox id=section-9506911cebe3ca5fe735e779d9771ba7 class=toggle>
<label for=section-9506911cebe3ca5fe735e779d9771ba7 class="flex justify-between"><a role=button>prog compile</a></label><ul><li><a href=/docs/prog_compile/autotools/>autotools</a></li><li><a href=/docs/prog_compile/make/>make</a></li><li><a href=/docs/prog_compile/cmake/>cmake</a></li><li><a href=/docs/prog_compile/gcc/>gcc</a></li></ul></li><li><input type=checkbox id=section-6dca8e12616d77bf2830415095ece5f8 class=toggle>
<label for=section-6dca8e12616d77bf2830415095ece5f8 class="flex justify-between"><a role=button>prog debug</a></label><ul><li><a href=/docs/prog_debug/gdb/>gdb</a></li><li><a href=/docs/prog_debug/valgrind/>valgrind</a></li></ul></li><li><input type=checkbox id=section-5beae40dbc5c42d8fea85f4bace3cf21 class=toggle>
<label for=section-5beae40dbc5c42d8fea85f4bace3cf21 class="flex justify-between"><a role=button>prog vc</a></label><ul><li><a href=/docs/prog_vc/git/>git</a></li></ul></li><li><input type=checkbox id=section-20aa46c2af4c93307791bb24c1eee293 class=toggle>
<label for=section-20aa46c2af4c93307791bb24c1eee293 class="flex justify-between"><a role=button>prog base</a></label><ul><li><a href=/docs/prog_base/algorithm/>数据结构与算法分析</a></li></ul></li><li><input type=checkbox id=section-c668332d51475947ad4001c53594cdb9 class=toggle>
<label for=section-c668332d51475947ad4001c53594cdb9 class="flex justify-between"><a role=button>tools</a></label><ul><li><a href=/docs/tool/docker/>docker</a></li><li><a href=/docs/tool/k8s/>k8s</a></li><li><a href=/docs/tool/monitor/>monitor</a></li><li><a href=/docs/tool/hugo/>hugo</a></li><li><a href=/docs/tool/redis/>redis</a></li><li><a href=/docs/tool/sql/>数据库</a></li><li><a href=/docs/tool/protocol/>乱七八糟的协议合集</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>socket base</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#基本概念>基本概念</a><ul><li><a href=#socket>socket</a></li><li><a href=#socket问题>socket问题</a></li><li><a href=#i-o模型>I/O模型</a></li><li><a href=#epoll使用>epoll使用</a></li></ul></li><li><a href=#socket属性>socket属性</a><ul><li><a href=#keep-live机制>keep live机制</a></li></ul></li><li><a href=#编程实例>编程实例</a><ul><li><a href=#原始socket模型-recv中处理分包粘包>原始socket模型, recv()中处理分包粘包</a></li></ul></li><li><a href=#ipv4>ipv4</a></li></ul></nav></aside></header><article class="markdown book-article"><p>socket相关网络编程<br></p><h2 id=基本概念>基本概念
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5>#</a></h2><h3 id=socket>socket
<a class=anchor href=#socket>#</a></h3><p>socket是 [应用层] 与 [传输层, 网络层] 之间的一个抽象层<br>它的出现是为了简化网络进程通信<br></p><h4 id=linux头文件>linux头文件
<a class=anchor href=#linux%e5%a4%b4%e6%96%87%e4%bb%b6>#</a></h4><ol><li>usr/include/x86_64-linux-gnu/sys/socket.h<br>结构体<br>sockaddr<br>函数<br>socket() connect() send() recv() shutdown()<br>socket() bind() lisent() accept() recv() send() shutdown()<br>g++的默认目录中已经包含了sys/的上层目录<br></li><li>usr/include/netinet/in.h<br>结构体<br>AF_INET 中的 sockaddr_in<br>AF_INET6 中的 sockaddr_in6<br>AF_UNIx 中的 sockaddr_un<br></li><li>user/include/arpa/inet.h<br>函数<br>htons()<br>inet_addr()<br></li><li>unistd.h<br>函数<br>close()<br></li></ol><h4 id=socket函数>socket函数
<a class=anchor href=#socket%e5%87%bd%e6%95%b0>#</a></h4><ol><li><p>socket(domain, socket_type, protol)<br>domain<br>socket_type<br>protol<br>socket()本质是创建了一个进程文件表, 返回的值为指向进程文件表的指针的索引.<br></p></li><li><p>bind(fd, sockaddr*, len)<br>fd: socket()中的文件表指针的索引<br>sockaddr: 地址, 端口<br>len: sockaddr的长度<br>&lt;1> 比较有意思的是sockaddr根据family的不同, 可以与不同的结构体互转<br>比如<br>AF_INET sockaddr_in<br>AF_INET6 sockaddr_in6<br>AF_UNIX sockaddr_un<br>这几种结构体都与sockaddr可互转(字节对齐blabla)<br>bind()本质是在补充socket()创建的文件表. socket()时候该文件表很多值都是空的, bind()来补充<br>因为client 在connect的时候, 系统会自动分配端口,以及绑定本机ip, 所以client的socket一般不必要<br>使用bind()<br></p></li><li><p>connet(fd, sockaddr*, len)<br>连接到其他scokaddr<br></p></li><li><p>listen(fd, iMaxNum)<br></p><pre><code class=language-text>iMaxNum是队列中的最大数, 并不是指可连接的socket数目
</code></pre><p>一般只在server开启listen(), 监听指定的端口信息<br></p></li><li><p>accept()<br>accept()会造成阻塞.<br>它会将listen()中的sockaddr进行处理<br>处理流程是 accept()会创建一个新的fd_connet, 此fd_connet公用server socket() fd的端口和地址<br>但是fd_connect仅仅是用来传输数据的<br></p></li><li><p>recv(fd, msg) send(fd, msg)<br>至accetp()时候, 一切操作就和在本地上操作一样,<br>所以这里的recv() 和 send()操作与本机上的文件操作是一样的<br></p></li><li><p>close(fd) shutdown(fd, type)<br>linux一切皆是file原则, fd可以关闭<br></p></li></ol><h4 id=ip-port-相关函数>[ip, port]相关函数
<a class=anchor href=#ip-port-%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0>#</a></h4><pre><code class=language-text>点分十进制ip 是以字符串形式存储的
网络字节序 即 32位的二进制
</code></pre><pre><code class=language-text>//in_addr
struct in_addr 
{
　　in_addr_t s_addr;
};

//in_addr_t
typedef unsigned long  in_addr_t
</code></pre><ol><li><p>函数原型: in_addr_t inet_addr(const char* strptr);<br>若字符串有效, 则将点分十进制IP字符串转换为网络字节序地址，否则为INADDR_NONE<br></p></li><li><p>函数原型：int inet_aton(const char *IP, struct in_addr *addr);<br>将点分十进制IP地址转换为网络字节序存储在addr中，并且返回该网络字节序表示的无符号整数<br></p></li><li><p>函数原型：char *inet_ntoa(struct in_addr in);<br>将网络字节序的IP地址（也就是结构体in_addr类型变量）转化为点分十进制的IP地址（字符串)<br></p></li></ol><h4 id=socket-fd本质>socket fd本质
<a class=anchor href=#socket-fd%e6%9c%ac%e8%b4%a8>#</a></h4><p>socket本质是维护了fd进程文件表, 如下:<br></p><table><thead><tr><th>名称</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>fd</td><td>文件描述符, 表的索引</td><td></td></tr><tr><td>host</td><td>1. 域名(DNS /etc/hosts) 2. ip地址</td><td>兼容Ipv4 Ipv6是难点</td></tr><tr><td>服务</td><td>1. 服务名称(/etc/services) 2. 端口</td><td></td></tr><tr><td>协议</td><td>1. 传输层(/etc/protol) 2. 网络层</td><td>链路层用到的比较少</td></tr><tr><td>网络</td><td>1. 网络名称?(DNS /etc/networks) 2. ip地址</td><td>谁会使用到这些信息??</td></tr></tbody></table><p>期间用到的函数主要有<br></p><pre><code class=language-text>尽量使用ipv4, ipv6通用的函数
</code></pre><ol><li>流程函数<br>socket() bind() listen() connect() accept()等<br></li><li>字节处理函数<br>处理大小字节序 htons() htonl() ntohs() ntohl()<br>处理域名与十分数字 getaddrinfo() getnameinfo()<br></li><li>处理sockaddr结构体的函数<br>getsockname() 返回local fd<br>getpeername() 返回remote fd<br></li></ol><h3 id=socket问题>socket问题
<a class=anchor href=#socket%e9%97%ae%e9%a2%98>#</a></h3><ol><li><p>阻塞<br></p><pre><code class=language-text>影响并发, 多路复用
</code></pre><p>解决方案:<br></p><ol><li>使用非阻塞模型, 比如select, poll, epoll(linux下特有), IOCP(windows下特有)<br></li><li>多线程 &ndash; 不推荐使用<br></li><li>多进程 &ndash; 不推荐使用<br></li></ol></li><li><p>粘包<br>解决方案:<br></p><ol><li>限制发送大小<br></li><li>每个消息增加长度标识<br></li></ol></li></ol><h3 id=i-o模型>I/O模型
<a class=anchor href=#i-o%e6%a8%a1%e5%9e%8b>#</a></h3><p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1565671711&amp;ver=1787&amp;signature=-mLkqQr803XDHb4f3aj9Lf1dJl8uVOV9fCCMMTzs0zSuOYH-qof7nsYCdgho1XLdPQYQP6QL5-WHtI6g-MD9xIsJcuxzdH*idpCZqtzl85r9D4C3XRRuOcCXqLKDzi-i&amp;new=1">强烈建议阅读</a><br>(链接过期, 直接搜狗搜索epoll, &ldquo;epoll本质"即是)<br></p><ol><li>阻塞式<br></li><li>非阻塞<br></li><li>select<br></li><li>poll<br></li><li>epoll (linux特有)<br></li><li>IOCP (windows特有)<br></li></ol><h3 id=epoll使用>epoll使用
<a class=anchor href=#epoll%e4%bd%bf%e7%94%a8>#</a></h3><h4 id=epoll本身为我们处理了什么>epoll本身为我们处理了什么
<a class=anchor href=#epoll%e6%9c%ac%e8%ba%ab%e4%b8%ba%e6%88%91%e4%bb%ac%e5%a4%84%e7%90%86%e4%ba%86%e4%bb%80%e4%b9%88>#</a></h4><ol><li>之前socket::recv()时, 导致我们的进程阻塞<br></li><li>现在socket::recv()时, 使epoll阻塞; epoll中断时, 告之进程<br></li></ol><h4 id=有了epoll我们还需要处理什么>有了epoll我们还需要处理什么
<a class=anchor href=#%e6%9c%89%e4%ba%86epoll%e6%88%91%e4%bb%ac%e8%bf%98%e9%9c%80%e8%a6%81%e5%a4%84%e7%90%86%e4%bb%80%e4%b9%88>#</a></h4><ol><li>创建epoll对象<br></li><li>添加检视的fd对象 &ndash; op, epoll_event<br></li><li>检测是否有中断, 然后处理<br></li></ol><h2 id=socket属性>socket属性
<a class=anchor href=#socket%e5%b1%9e%e6%80%a7>#</a></h2><h3 id=keep-live机制>keep live机制
<a class=anchor href=#keep-live%e6%9c%ba%e5%88%b6>#</a></h3><p>当socket服务端开启keep live之后,<br>服务器检测到 <span class=underline>一定时间内</span> socket不活动的时候,<br>就会每隔 <span class=underline>固定时间</span> 向该sockt发送 <span class=underline>固定次数</span> 的查询.<br>如果一直没有回应, 服务端则关闭该socket<br></p><p>对应的字段为:<br></p><pre><code class=language-text>tcp_keepalive_time（开启keepalive的闲置时长） 
tcp_keepalive_intvl（keepalive探测包的发送间隔） 
tcp_keepalive_probes （如果对方不予应答，探测包的发送次数）
</code></pre><h2 id=编程实例>编程实例
<a class=anchor href=#%e7%bc%96%e7%a8%8b%e5%ae%9e%e4%be%8b>#</a></h2><h3 id=原始socket模型-recv中处理分包粘包>原始socket模型, recv()中处理分包粘包
<a class=anchor href=#%e5%8e%9f%e5%a7%8bsocket%e6%a8%a1%e5%9e%8b-recv%e4%b8%ad%e5%a4%84%e7%90%86%e5%88%86%e5%8c%85%e7%b2%98%e5%8c%85>#</a></h3><p>原始socket模型, 考虑到tcp分包<br></p><pre><code class=language-C++>//网络读取 -- 系统检测到网络I/O事件时, 调用该函数
LRESULT CTCPSocketService::OnSocketNotifyRead(WPARAM wParam, LPARAM lParam)
{
    //读取数据
    //使用中间量m+cbRecvbuf来当做缓冲区
    //使用中间量m_wRecvsize来记录当前缓冲区中已读数据大小
    int iRetCode = recv(m_hSocket, (char *)m_cbRecvBuf + m_wRecvSize, sizeof(m_cbRecvBuf) - m_wRecvSize, 0);
    //读取失败, 则返回SOCKET_ERROR
    if (iRetCode == SOCKET_ERROR)
    {
        ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf));
        m_wRecvSize = 0;
        return 1;//&quot;网络连接关闭，读取数据失败&quot;;
    }
    //读取成功, 则返回读取到的数据的大小
    m_wRecvSize += iRetCode;

    //在tcp数据中, 增加包的大小, 用来校验是否读取完毕;
    TCP_Head * pHead = (TCP_Head *)m_cbRecvBuf;
    WORD wPacketSize = pHead-&gt;TCPInfo.wPacketSize;

    // //数据包大小校验
    if (wPacketSize &gt; (SOCKET_TCP_BUFFER + sizeof(TCP_Head)))
    {
        //当发生错误时候, 缓冲区置位
        ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf));
        m_wRecvSize = 0;
        return 3;//&quot;数据包太大&quot;;
        }

        //解析数据
        if (m_wRecvSize == wPacketSize)  //数据全部接受完毕之后 再解析
        {		
            //拷贝数据
            BYTE cbDataBuffer[SOCKET_TCP_BUFFER+sizeof(TCP_Head)];		
            CopyMemory(cbDataBuffer, m_cbRecvBuf, wPacketSize);

            //置位缓冲信息 -- 缓冲区中只保存一条tcp信息
            m_wRecvSize = 0;
            ZeroMemory(m_cbRecvBuf, sizeof(m_cbRecvBuf));		

            //解密数据
            WORD wRealySize = CrevasseBuffer(cbDataBuffer, wPacketSize);
            if(wRealySize &lt; sizeof(TCP_Head)) return 4; //解析后的数据错误

            //获得TCP_Head
            TCP_Command Command = ((TCP_Head *)cbDataBuffer)-&gt;CommandInfo;

            //获得实际的数据
            void * pDataBuffer = cbDataBuffer + sizeof(TCP_Head); //实际的数据
            WORD wRealDataSize = wRealySize - sizeof(TCP_Head);   //实际的数据大小

            //内核命令
            if (Command.wMainCmdID == MDM_KN_COMMAND)
            {
            switch (Command.wSubCmdID)
            {
                case SUB_KN_DETECT_SOCKET:	//网络检测
                {
                    //发送数据
                    SendData(MDM_KN_COMMAND, SUB_KN_DETECT_SOCKET, pDataBuffer, wRealDataSize);
                    break;
                }
            }
            continue;
            }

            //处理数据
            bool bSuccess = m_QueueServiceEvent.PostTCPSocketReadEvent(m_wServiceID, Command, pDataBuffer, wRealDataSize);
            if (bSuccess == false) return 5;//&quot;网络数据包处理失败&quot;;
        };

        return 0;
}
</code></pre><h2 id=ipv4>ipv4
<a class=anchor href=#ipv4>#</a></h2><pre><code class=language-text>系统文件在/proc/sys/net/ipv4下面
</code></pre><pre><code class=language-text>ip_local_port_range # 用户端口范围, [n, m)
tcp_timestamp       # 针对TIME_WAIT状态的tcp连接; 0关闭,1开启
tcp_tw_recycle      # 是否快速回收+ linux内核已删除该字段
tcp_tw_reuse        # TIME_WAIT状态的tcp的port是否可以复用;0关闭,1开启
                    # 需要开启tcp_timestamp;
		    # 这是针对cli的设计,而非svr
tcp_rmem            # tcp read缓冲区
tcp_wmem            # tcp write缓冲区
</code></pre><pre><code class=language-text>ip_forward               0禁止ip转发, 1打开;
ip_default_ttl           数据报的生存周期(time to live), 即最多经过多少路由器

ip_no_pmtu_disc          关闭路径MTU探测
min_pmtu                 最小路径MTU的大小
mtu_expires              PMTU信息缓存多长时间
</code></pre></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#基本概念>基本概念</a><ul><li><a href=#socket>socket</a></li><li><a href=#socket问题>socket问题</a></li><li><a href=#i-o模型>I/O模型</a></li><li><a href=#epoll使用>epoll使用</a></li></ul></li><li><a href=#socket属性>socket属性</a><ul><li><a href=#keep-live机制>keep live机制</a></li></ul></li><li><a href=#编程实例>编程实例</a><ul><li><a href=#原始socket模型-recv中处理分包粘包>原始socket模型, recv()中处理分包粘包</a></li></ul></li><li><a href=#ipv4>ipv4</a></li></ul></nav></div></aside></main></body></html>