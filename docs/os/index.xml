<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>os on 飘</title><link>https://clay9.github.io/blog/docs/os/</link><description>Recent content in os on 飘</description><generator>Hugo</generator><language>en</language><lastBuildDate>Thu, 06 Jun 2024 10:24:30 +0000</lastBuildDate><atom:link href="https://clay9.github.io/blog/docs/os/index.xml" rel="self" type="application/rss+xml"/><item><title>linux</title><link>https://clay9.github.io/blog/docs/os/linux/</link><pubDate>Fri, 31 May 2024 10:36:00 +0000</pubDate><guid>https://clay9.github.io/blog/docs/os/linux/</guid><description>&lt;p>linux常用命令&amp;amp;&amp;amp;工具 &lt;br/>&lt;/p></description></item><item><title>mac</title><link>https://clay9.github.io/blog/docs/os/mac/</link><pubDate>Tue, 04 Jun 2024 14:36:00 +0000</pubDate><guid>https://clay9.github.io/blog/docs/os/mac/</guid><description>mac初步整理 # 界面的整理 # launchpad图标大小整理 每一列图标数量 defaults write com.apple.dock springboard-rows -int 7 每一行图标数量 defaults write com.apple.dock springboard-columns -int 7 重启Launchpad defaults write com.apple.dock ResetLaunchPad -bool TRUE;killall Dock 该指令重启launchpad的时候, 也会使launchpad的排序恢复默认值!!! 添加空白到Dock栏 空白能使Dock中的程序更好的归类. 按住Option可以拖动 defaults write com.apple.dock persistent-apps -array-add '{&amp;quot;tile-type&amp;quot;=&amp;quot;spacer-tile&amp;quot;;}'; killall Dock 状态栏调整 # 按住Command之后, 鼠标可以拖动状态栏图标 mac自带输入法 &amp;ndash; 简体拼音 # 记录一下常用快捷键 &amp;amp;&amp;amp; 配置 TAB &amp;ndash; 短按切换ABC与简体中文, 长按大小写 建议设置选词为竖屏, 横屏容易遮挡输入 不舒服的地方 输入的时候无法使用shift来切换为英文, 必须使用Fn+TAB 候选词为横屏的时候, 会遮挡住输入区域 关闭内置键盘 # 苹果内置键盘不好用, 但是触控板非常好用. 习惯把HHKB放在苹果键盘上, 这样可以使用HHKB+苹果触控版 # For newer versions on MacOS / alternative solution: # List loaded kexts for keyboard kextstat | grep Keyboard # It's going to output something like: # 81 0 0xffffff7f833c5000 0xb000 0xb000 com.</description></item><item><title>静态库 &amp;&amp; 动态库</title><link>https://clay9.github.io/blog/docs/os/dll/</link><pubDate>Thu, 18 Jan 2024 18:55:00 +0000</pubDate><guid>https://clay9.github.io/blog/docs/os/dll/</guid><description>linux下静态库 &amp;amp;&amp;amp; 动态库 差异区别 # 编译连接静态库时, 会copy一份静态库镜像到目标文件; 编译连接动态库时, 不会copy 程序运行时, 无须再去访问原静态库; 程序运行时, 要能访问到动态库文件 静态库 .a 动态库 .so (shared object) 生成方式 # 静态库 A.由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表 B.ar命令将很多.o转换成.a，生成文静态库 动态库 A.gcc 加特定参数 编译 fPIC生成动态的.o文件; shared把动态.o文件打包为动态库 gcc -fPIC file1.c -c //这一步生成file1.o gcc -shared file1.o -o libtest.so //把.o文件打包为动态库(.o文件必须是 fPIC生成) 常见问题 # 运行时候找不到动态库, 处理方式 （1) 最直接最简单的方法就是把so拉到/usr/lib或/lib中去，但这好像有点污染环境吧？ （2）export LD_LIBRARY_PATH=$(pwd) （3）可以在/etc/ld.so.conf文件里加入我们生成的库的目录，然后/sbin/ldconfig 加载动态库 函数原型：void *dlopen(const char *libname,int flag); 参数中的libname一般是库的全路径，这样dlopen会直接装载该文件； 如果只是指定了库名称，在dlopen在查找库的过程中会按照如下路径进行搜索： a.根据环境变量LD_LIBRARY_PATH查找 b.根据/etc/ld.so.cache查找 c.查找依次在/lib和/usr/lib目录查找。 flag参数表示处理未定义函数的方式，可以使用RTLD_LAZY或RTLD_NOW。 RTLD_LAZY表示暂时不去处理未定义函数，先把库装载到内存，等用到没定义的函数再说； RTLD_NOW表示马上检查是否存在未定义的函数，若存在，则dlopen以失败告终。 动态库再认知 # 结论 # 动态库允许延迟定义, 但是在连接为可执行文件时, 所有动态库的声明必须有定义 测试 # A 依赖libbase.</description></item></channel></rss>