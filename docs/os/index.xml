<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>os on 飘</title><link>https://www.wcq.life/docs/os/</link><description>Recent content in os on 飘</description><generator>Hugo</generator><language>en</language><lastBuildDate>Wed, 29 May 2024 08:45:11 +0000</lastBuildDate><atom:link href="https://www.wcq.life/docs/os/index.xml" rel="self" type="application/rss+xml"/><item><title>linux</title><link>https://www.wcq.life/docs/os/linux/</link><pubDate>Thu, 18 Jan 2024 18:56:00 +0000</pubDate><guid>https://www.wcq.life/docs/os/linux/</guid><description>linux常用命令&amp;amp;&amp;amp;工具 查看系统信息 # linux 发行版 # cat /etc/issue 内核信息查看 # cat /proc/version uname -a debian系 已安装的包 # apt list &amp;ndash;installed cpu # cat /proc/cpuinfo| grep &amp;ldquo;physical id&amp;rdquo;| sort| uniq| wc -l cat /proc/cpuinfo| grep &amp;ldquo;cpu cores&amp;rdquo;| uniq cat /proc/cpuinfo| grep &amp;ldquo;processor&amp;rdquo;| wc -l cat /proc/cpuinfo | grep name | cut -f2 -d: | uniq -c 查看库 (动态库, 静态库)的封装信息 # readelf nm objdump fd # 查询 # 所有进程允许打开的最大fd数量。查询语句： /proc/sys/fs/file-max 所有进程已经打开的fd数量及允许的最大数量。查询语句： /proc/sys/fs/file-nr 单个进程允许打开的最大fd数量.</description></item><item><title>mac</title><link>https://www.wcq.life/docs/os/mac/</link><pubDate>Thu, 18 Jan 2024 18:57:00 +0000</pubDate><guid>https://www.wcq.life/docs/os/mac/</guid><description>&lt;p>mac 记录 &lt;br/>&lt;/p></description></item><item><title>静态库 &amp;&amp; 动态库</title><link>https://www.wcq.life/docs/os/dll/</link><pubDate>Thu, 18 Jan 2024 18:55:00 +0000</pubDate><guid>https://www.wcq.life/docs/os/dll/</guid><description>linux下静态库 &amp;amp;&amp;amp; 动态库 差异区别 # 编译连接静态库时, 会copy一份静态库镜像到目标文件; 编译连接动态库时, 不会copy 程序运行时, 无须再去访问原静态库; 程序运行时, 要能访问到动态库文件 静态库 .a 动态库 .so (shared object) 生成方式 # 静态库 A.由源文件编译生成一堆.o，每个.o里都包含这个编译单元的符号表 B.ar命令将很多.o转换成.a，生成文静态库 动态库 A.gcc 加特定参数 编译 fPIC生成动态的.o文件; shared把动态.o文件打包为动态库 gcc -fPIC file1.c -c //这一步生成file1.o gcc -shared file1.o -o libtest.so //把.o文件打包为动态库(.o文件必须是 fPIC生成) 常见问题 # 运行时候找不到动态库, 处理方式 （1) 最直接最简单的方法就是把so拉到/usr/lib或/lib中去，但这好像有点污染环境吧？ （2）export LD_LIBRARY_PATH=$(pwd) （3）可以在/etc/ld.so.conf文件里加入我们生成的库的目录，然后/sbin/ldconfig 加载动态库 函数原型：void *dlopen(const char *libname,int flag); 参数中的libname一般是库的全路径，这样dlopen会直接装载该文件； 如果只是指定了库名称，在dlopen在查找库的过程中会按照如下路径进行搜索： a.根据环境变量LD_LIBRARY_PATH查找 b.根据/etc/ld.so.cache查找 c.查找依次在/lib和/usr/lib目录查找。 flag参数表示处理未定义函数的方式，可以使用RTLD_LAZY或RTLD_NOW。 RTLD_LAZY表示暂时不去处理未定义函数，先把库装载到内存，等用到没定义的函数再说； RTLD_NOW表示马上检查是否存在未定义的函数，若存在，则dlopen以失败告终。 动态库再认知 # 结论 # 动态库允许延迟定义, 但是在连接为可执行文件时, 所有动态库的声明必须有定义 测试 # A 依赖libbase.</description></item></channel></rss>