<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="通过C++历史, 更好的了解C++特性 "><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:url" content="https://www.wcq.life/docs/prog_language/c++/c++/"><meta property="og:site_name" content="飘"><meta property="og:title" content="c++历史"><meta property="og:description" content="通过C++历史, 更好的了解C++特性 "><meta property="og:locale" content="en"><meta property="og:type" content="article"><meta property="article:section" content="docs"><meta property="article:published_time" content="2024-01-18T19:06:00+00:00"><meta property="article:modified_time" content="2024-05-30T13:31:00+00:00"><title>c++历史 | 飘</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=canonical href=https://www.wcq.life/docs/prog_language/c++/c++/><link rel=stylesheet href=/book.min.309b7ed028807cdb68d8d61e26d609f48369c098dbf5e4d8c0dcf4cdf49feafc.css integrity="sha256-MJt+0CiAfNto2NYeJtYJ9INpwJjb9eTYwNz0zfSf6vw=" crossorigin=anonymous><script defer src=/fuse.min.js></script><script defer src=/en.search.min.b5ceea6caded6f6c518b7a5c8640a394beb6c6900e6674adc21a12f67cb4b475.js integrity="sha256-tc7qbK3tb2xRi3pchkCjlL62xpAOZnStwhoS9ny0tHU=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>飘</span></a></h2><div class="book-search hidden"><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><script>document.querySelector(".book-search").classList.remove("hidden")</script><ul><li><input type=checkbox id=section-b352899f7eb963a33da348c348027b65 class=toggle>
<label for=section-b352899f7eb963a33da348c348027b65 class="flex justify-between"><a role=button>os</a></label><ul><li><a href=/docs/os/linux/>linux</a></li><li><a href=/docs/os/mac/>mac</a></li><li><input type=checkbox id=section-fdd1425db5172488eb2e50bb0694ce90 class=toggle>
<label for=section-fdd1425db5172488eb2e50bb0694ce90 class="flex justify-between"><a role=button>os</a></label><ul><li><a href=/docs/os/os/memory_01/>memory 01</a></li></ul></li><li><a href=/docs/os/dll/>静态库 && 动态库</a></li><li><input type=checkbox id=section-0bd5f096bee3fdfea967307d0cc58cea class=toggle>
<label for=section-0bd5f096bee3fdfea967307d0cc58cea class="flex justify-between"><a role=button>socket</a></label><ul><li><a href=/docs/os/socket/socket/>socket base</a></li><li><a href=/docs/os/socket/asio/>asio</a></li></ul></li></ul></li><li><input type=checkbox id=section-6caca07a3711ff73965120347814c88e class=toggle>
<label for=section-6caca07a3711ff73965120347814c88e class="flex justify-between"><a role=button>emacs</a></label><ul><li><a href=/docs/emacs/emacs/>emacs</a></li><li><input type=checkbox id=section-fa106d5e2f4637bb0d3f0b2bb0c8a4cf class=toggle>
<label for=section-fa106d5e2f4637bb0d3f0b2bb0c8a4cf class="flex justify-between"><a role=button>org && gtd</a></label><ul><li><a href=/docs/emacs/org/org/>org</a></li><li><a href=/docs/emacs/org/gtd/>gtd</a></li><li><a href=/docs/emacs/org/org_gtd/>org && gtd</a></li><li><a href=/docs/emacs/org/org_export/>org exprot && ox-hugo</a></li></ul></li><li><input type=checkbox id=section-2ef79c58172b5bdd730d4a37c8089150 class=toggle>
<label for=section-2ef79c58172b5bdd730d4a37c8089150 class="flex justify-between"><a role=button>常用扩展</a></label><ul><li><a href=/docs/emacs/lisp/eshell/>eshell</a></li><li><a href=/docs/emacs/lisp/tramp/>tramp</a></li><li><a href=/docs/emacs/lisp/graph/>artist && plantuml</a></li><li><a href=/docs/emacs/lisp/mail/>mail</a></li><li><a href=/docs/emacs/lisp/gdb/>gdb && gud</a></li><li><a href=/docs/emacs/lisp/ai/>AI</a></li></ul></li></ul></li><li><input type=checkbox id=section-322c9b2e26449b2d642bd024a319aad8 class=toggle checked>
<label for=section-322c9b2e26449b2d642bd024a319aad8 class="flex justify-between"><a role=button>prog language</a></label><ul><li><input type=checkbox id=section-e4498ecbfd376ac8cbe8a22c1359c593 class=toggle checked>
<label for=section-e4498ecbfd376ac8cbe8a22c1359c593 class="flex justify-between"><a role=button>c++</a></label><ul><li><a href=/docs/prog_language/c++/c++/ class=active>c++历史</a></li><li><a href=/docs/prog_language/c++/stl/>C && C++ 常见库</a></li></ul></li><li><a href=/docs/prog_language/elisp/>elisp</a></li><li><a href=/docs/prog_language/shell/>shell</a></li></ul></li><li><input type=checkbox id=section-f082414e628ebd4ba49cf710b10f2cac class=toggle>
<label for=section-f082414e628ebd4ba49cf710b10f2cac class="flex justify-between"><a role=button>prog lsp</a></label><ul><li><a href=/docs/prog_lsp/global/>global</a></li></ul></li><li><input type=checkbox id=section-9506911cebe3ca5fe735e779d9771ba7 class=toggle>
<label for=section-9506911cebe3ca5fe735e779d9771ba7 class="flex justify-between"><a role=button>prog compile</a></label><ul><li><a href=/docs/prog_compile/autotools/>autotools</a></li><li><a href=/docs/prog_compile/make/>make</a></li><li><a href=/docs/prog_compile/cmake/>cmake</a></li><li><a href=/docs/prog_compile/gcc/>gcc</a></li></ul></li><li><input type=checkbox id=section-6dca8e12616d77bf2830415095ece5f8 class=toggle>
<label for=section-6dca8e12616d77bf2830415095ece5f8 class="flex justify-between"><a role=button>prog debug</a></label><ul><li><a href=/docs/prog_debug/gdb/>gdb</a></li><li><a href=/docs/prog_debug/valgrind/>valgrind</a></li></ul></li><li><input type=checkbox id=section-5beae40dbc5c42d8fea85f4bace3cf21 class=toggle>
<label for=section-5beae40dbc5c42d8fea85f4bace3cf21 class="flex justify-between"><a role=button>prog vc</a></label><ul><li><a href=/docs/prog_vc/git/>git</a></li></ul></li><li><input type=checkbox id=section-20aa46c2af4c93307791bb24c1eee293 class=toggle>
<label for=section-20aa46c2af4c93307791bb24c1eee293 class="flex justify-between"><a role=button>prog base</a></label><ul><li><a href=/docs/prog_base/algorithm/>数据结构与算法分析</a></li></ul></li><li><input type=checkbox id=section-c668332d51475947ad4001c53594cdb9 class=toggle>
<label for=section-c668332d51475947ad4001c53594cdb9 class="flex justify-between"><a role=button>tools</a></label><ul><li><a href=/docs/tool/docker/>docker</a></li><li><a href=/docs/tool/k8s/>k8s</a></li><li><a href=/docs/tool/monitor/>monitor</a></li><li><a href=/docs/tool/hugo/>hugo</a></li><li><a href=/docs/tool/redis/>redis</a></li><li><a href=/docs/tool/sql/>数据库</a></li><li><a href=/docs/tool/protocol/>乱七八糟的协议合集</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>c++历史</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#演变>演变</a><ul><li><a href=#1979-诞生>1979 诞生</a></li><li><a href=#1983-改名c-plus-plus>1983 改名C++</a></li><li><a href=#1985-发布第一版>1985 发布第一版<span class=org-target id=org-target--C--------></span></a></li><li><a href=#1989-发布release-2-dot-0>1989 发布Release 2.0</a></li><li><a href=#1990-出版了-标准化基础>1990 出版了<span class=org-target id=org-target--The-Annotated-C---Reference-Manual></span> 标准化基础</a></li><li><a href=#1998-c-plus-plus-98-第一个c-plus-plus-标准>1998 C++98 第一个C++标准</a></li><li><a href=#2003-c-plus-plus-03-第二个c-plus-plus-标准>2003 C++03 第二个C++标准</a></li><li><a href=#2006-c-plus-plus-性能技术报告>2006 C++性能技术报告</a></li><li><a href=#2007-c-plus-plus-技术报告-库扩展>2007 C++技术报告: 库扩展</a></li><li><a href=#2010-数学函数扩展>2010 数学函数扩展</a></li><li><a href=#2011-c-plus-plus-11-第三个c-plus-plus-标准>2011 C++11 第三个C++标准</a></li><li><a href=#2011-十进制浮点数扩展>2011 十进制浮点数扩展</a></li><li><a href=#2014-c-plus-plus-14-第四个c-plus-plus-标准>2014 C++14 第四个C++标准</a></li><li><a href=#2015-文件系统>2015 文件系统</a></li><li><a href=#2015-用于并行计算的扩展>2015 用于并行计算的扩展</a></li><li><a href=#2015-事务性内存操作>2015 事务性内存操作</a></li><li><a href=#2015-概念库-用于优化编译期信息>2015 概念库, 用于优化编译期信息</a></li><li><a href=#2016-用于并行计算的扩展>2016 用于并行计算的扩展</a></li><li><a href=#2017-标准库扩展>2017 标准库扩展</a></li><li><a href=#2017-提供范围机制>2017 提供范围机制</a></li><li><a href=#2017-协程库扩展>2017 协程库扩展</a></li><li><a href=#2017-c-plus-plus-17-第五个c-plus-plus-标准>2017 C++17 第五个C++标准</a></li><li><a href=#2018-网络库>2018 网络库</a></li><li><a href=#2018-并行扩展>2018 并行扩展</a></li><li><a href=#2018-模块>2018 模块</a></li><li><a href=#2020-c-plus-plus-20-第五个c-plus-plus-标准>2020 C++20 第五个C++标准</a></li></ul></li><li><a href=#设计原则>设计原则</a></li><li><a href=#待学习>待学习</a></li></ul></nav></aside></header><article class="markdown book-article"><p>通过C++历史, 更好的了解C++特性<br></p><h2 id=演变>演变
<a class=anchor href=#%e6%bc%94%e5%8f%98>#</a></h2><h3 id=1979-诞生>1979 诞生
<a class=anchor href=#1979-%e8%af%9e%e7%94%9f>#</a></h3><p>刚开始叫做New C, 后改名C with Classes<br>诞生目的: 便于大型软件开发 && 运行效率<br>过 程: 增强C语言特性 (选C原因: C用途广, 快速, 可移植性)<br>新增特性:<br></p><ol><li>类别<br></li><li>衍生类别<br></li><li>存储类型检查<br></li><li>内联<br></li><li>缺省参数<br></li></ol><h3 id=1983-改名c-plus-plus>1983 改名C++
<a class=anchor href=#1983-%e6%94%b9%e5%90%8dc-plus-plus>#</a></h3><p>新增特性:<br></p><ol><li>虚拟函数<br></li><li>函数名<br></li><li>运算子多载<br></li><li>参考 ???<br></li><li>常数<br></li><li>使用者可控制的自由空间存储区控制<br></li><li>改良的型别检查<br></li><li>单行注释 //<br></li></ol><h3 id=1985-发布第一版>1985 发布第一版<span class=org-target id=org-target--C--------></span>
<a class=anchor href=#1985-%e5%8f%91%e5%b8%83%e7%ac%ac%e4%b8%80%e7%89%88>#</a></h3><p>非官方发布 ?? 这时候有官方了???<br></p><h3 id=1989-发布release-2-dot-0>1989 发布Release 2.0
<a class=anchor href=#1989-%e5%8f%91%e5%b8%83release-2-dot-0>#</a></h3><p>新增特性:<br></p><ol><li>多重继承<br></li><li>抽象类别<br></li><li>静态成员函数<br></li><li>常数成员函数<br></li><li>成员保护<br></li></ol><h3 id=1990-出版了-标准化基础>1990 出版了<span class=org-target id=org-target--The-Annotated-C---Reference-Manual></span> 标准化基础
<a class=anchor href=#1990-%e5%87%ba%e7%89%88%e4%ba%86-%e6%a0%87%e5%87%86%e5%8c%96%e5%9f%ba%e7%a1%80>#</a></h3><p>??哪一年??稍后还引入了模板例外处理、命名空间、新的强制类型转换，以及布林类型<br></p><h3 id=1998-c-plus-plus-98-第一个c-plus-plus-标准>1998 C++98 第一个C++标准
<a class=anchor href=#1998-c-plus-plus-98-%e7%ac%ac%e4%b8%80%e4%b8%aac-plus-plus-%e6%a0%87%e5%87%86>#</a></h3><p>标准分为 核心语言 && C++标准程序库<br>C++标准程序库主要包含 STL && C标准库的稍加修改版<br></p><p>语言特性:<br></p><ol><li>classes 相关<br><ol><li>构造 && 析构<br></li><li>friend<br></li><li>继承<br></li><li>多态<br></li><li>静态成员<br></li></ol></li><li>new delete<br></li><li>高级概念 ?? 高级在哪?? 需要对比当时的环境<br><ol><li>模板<br></li><li>命名空间<br></li><li>异常<br></li><li>类型转换<br>隐式转换 && 显式转换<br></li></ol></li></ol><p>stl:<br></p><ol><li>异常 &lt;exception><br></li><li>类型检查 &lt;typeinfo><br></li><li>输入输出 &lt;iostream><br></li></ol><h3 id=2003-c-plus-plus-03-第二个c-plus-plus-标准>2003 C++03 第二个C++标准
<a class=anchor href=#2003-c-plus-plus-03-%e7%ac%ac%e4%ba%8c%e4%b8%aac-plus-plus-%e6%a0%87%e5%87%86>#</a></h3><p>C++03 主要是在C++98基础上针对实现方的一些问题进行了修复，从而在各个实现间达到一致、保持了可移植性。<br>该版本共涉及 92 项核心语言缺陷报告、125 项库缺陷报告，所提供的新特性只有一项：值初始化（value initialization）<br></p><pre><code class=language-text>实现方是指编译器 ??需要重点看一下当时的编译器有哪些??
对于使用者(程序员)来说, C++03与C++98差异不大(只有一条 值初始化)
</code></pre><h3 id=2006-c-plus-plus-性能技术报告>2006 C++性能技术报告
<a class=anchor href=#2006-c-plus-plus-%e6%80%a7%e8%83%bd%e6%8a%80%e6%9c%af%e6%8a%a5%e5%91%8a>#</a></h3><h3 id=2007-c-plus-plus-技术报告-库扩展>2007 C++技术报告: 库扩展
<a class=anchor href=#2007-c-plus-plus-%e6%8a%80%e6%9c%af%e6%8a%a5%e5%91%8a-%e5%ba%93%e6%89%a9%e5%b1%95>#</a></h3><h3 id=2010-数学函数扩展>2010 数学函数扩展
<a class=anchor href=#2010-%e6%95%b0%e5%ad%a6%e5%87%bd%e6%95%b0%e6%89%a9%e5%b1%95>#</a></h3><h3 id=2011-c-plus-plus-11-第三个c-plus-plus-标准>2011 C++11 第三个C++标准
<a class=anchor href=#2011-c-plus-plus-11-%e7%ac%ac%e4%b8%89%e4%b8%aac-plus-plus-%e6%a0%87%e5%87%86>#</a></h3><p>先前被称作C++0x, 本预计2000-2009间会发布, 结果一直拖到了2011年. 因此改名C++11. <a href=https://zh.wikipedia.org/wiki/C%2B%2B11>参考资料</a><br></p><p>相比于C++03，C++11标准包含核心语言的新机能，<br>而且扩展C++标准程序库，并入了大部分的C++ Technical Report 1程序库（数学的特殊函数除外)<br></p><h4 id=设计原则>设计原则
<a class=anchor href=#%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99>#</a></h4><ol><li>维持稳定性和与C++98，可能的话还有C之间的兼容性；<br></li><li>尽可能不透过核心语言的扩展，而是透过标准程序库来引进新的特性；<br></li><li>能够演进编程技术的变更优先；<br></li><li>改进C++以帮助系统以及库设计，而不是引进只针对特别应用的新特性；<br></li><li>增进类别安全，提供对现行不安全的技术更安全的替代方案；<br></li><li>增进直接对硬件工作的能力与表现；<br></li><li>提供现实世界中问题的适当解决方案；<br></li><li>实行“zero-overhead”原则（某些功能要求的额外支持只有在该功能被使用时才能使用）；<br></li><li>使C++易于教授与学习<br></li></ol><h4 id=语言变更>语言变更
<a class=anchor href=#%e8%af%ad%e8%a8%80%e5%8f%98%e6%9b%b4>#</a></h4><p>C++委员会的主要作用之一是改善语言核心。核心语言将被大幅改善的领域包括<br></p><ul><li>多线程支持<br></li><li>泛型编程<br></li><li>统一的初始化<br></li><li>以及性能表现的加强<br></li></ul><p>在此分成4个区块来讨论核心语言的特色以及变更:<br>执行期表现强化、构造期表现强化、可用性强化，还有新的功能。<br>某些特性可能会同时属于多个区块，但在此仅于其最具代表性的区块描述<br></p><ul><li><p>执行期表现强化</p><p>提升某些性能表现, 像是内存或者速度上的提升<br></p><ul><li><p>右值引用 && std::move && std::forward</p><pre><code class=language-text>右值引用是语言特性,  std::move &amp;&amp; std::forward是stl中新增的函数 (头文件&lt;utility&gt;)
符合设计原则2, 使用stl补充语言特性
</code></pre><p>右值引用的本质是为了解决C++之前版本的深度copy问题. <a href=https://zh.wikipedia.org/wiki/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8>wiki参考资料</a><br></p><pre><code class=language-text>template &lt;typename T, typename Arg&gt;
shared_ptr&lt;T&gt; factory(Arg arg)
{
return shared_ptr&lt;T&gt;( new T(arg));
}
</code></pre><pre><code class=language-text>template &lt;typename T, typename Arg&gt;
shared_ptr&lt;T&gt; factory(Arg&amp; arg)
{
return shared_ptr&lt;T&gt;( new T(arg));
}
</code></pre><pre><code class=language-text>template&lt; typename T, typename Arg&gt;
shared_ptr&lt;T&gt; factory(const Arg&amp; arg)
{
//无法修改arg对象
return shared_ptr&lt;T&gt;( new T(arg));
}
</code></pre><pre><code class=language-text>template&lt;typename T, typename Arg&gt;
shared_ptr&lt;T&gt; factory(Arg&amp;&amp; arg)
{
return shared_ptr&lt;T&gt;(new T(std::forward&lt;Arg&gt;(arg)));
}

/*
调用时候, 参数如果是左值, 只需要std::move()获取对应的右值
*/
</code></pre><pre><code class=language-text>//两者都在&lt;utility&gt;头文件
//std::move(arg)       可以获取左值的右值引用
//                     因为右值引用是将原对象的内容移动到新对象, 所以原对象移动后不应再使用
//std::forward&lt;T&gt;(arg) 可以获取arg的T属性.
//                     T如果为int,  则使用arg的右值
//                     T若果为int&amp;, 则使用arg的左值
</code></pre><p>右值引用使用场景:<br></p><ol><li><p>上面的exp所展示的<br></p></li><li><p>就是在以传值方式传递对象时隐式发生的耗时且不必要的深度拷贝。<br>举例而言，std::vector&lt;T>本质上是一个C-style数组及其大小的封装，<br>如果一个std::vector&lt;T>的临时对象是在函数内部或者函数返回时创建，<br>要将其存储就只能透过生成新的std::vector&lt;T>并且把该临时对象所有的资料复制过去<br>然后该临时对象会被析构，其使用的内存会被释放<br></p><pre><code class=language-text>std::vector&lt;int&gt; test(){
  std::vector&lt;int&gt; vec_data;
   //一些操作
   //...
   //返回vec_data实际是
   //1.创建了一个新的std::vector&lt;int&gt; 临时对象
   //2.把vec_data对象深度copy给 临时对象
   //3.返回临时对象
   //4.销毁vec_data对象
   //
   // 其中深度copy会造成非常大的开销, 导致性能低下
   return vec_data;
}
</code></pre><pre><code class=language-text>std::vector&lt;int&gt; test(){
  std::vector&lt;int&gt; vec_data;
  //一些操作
  //...
  //
  //1.创建一个新的std::vector&lt;int&gt; 临时对象
  //2.把vec_data对象移动到 临时对象
  //3.返回临时对象
  //4.销毁vec_data对象
  //
  //对比旧版本, 这里少了深度copy这一层
  return std::vector&lt;int&gt; (std::move(vec_data) );
}
</code></pre></li></ol><p>注意事项<br></p><ol><li>对象被右值引用后, 再操作会导致不可预知的问题(内存相关信息已被置为null)<br></li><li>并非所有情形都合适. 应该使用在避免深度copy的场合<br></li></ol></li></ul><ul><li><p>constexpr 泛化的常量表达式</p><p>constexpr确保对象在编译期完成初始化操作, 因此加快运行期的效率<br></p><pre><code class=language-text>//const 与 constexpr 均表示该表达式(对象或函数)被声明为常量
//const     不保证对象经历哪种类型的初始化, 可能是编译器初始化, 也可能是运行期初始化
//constexpr 保证对象使用编译器初始化

//const演示
int get_number(){ return 5; }
const int mx = get_number();  //mx是常量对象, 但在运行期获得初始化
int arr[mx] ; //错误. 因为mx是在运行期获得初始化; 而int[]需要编译器的常量

//constexpr演示
constexpr int get_number(){ return 5; }
int arr[get_number()]; //正确. 因为constexpr保证函数get_number调用在编译器初始化
</code></pre><pre><code class=language-text>//修饰函数表达式
//函数主体必须是非虚拟的，并且除了 typedef 和静态断言之外，仅包含一个 return 语句
constexpr int max() { return 4; } // ok
constexpr long long_max() { return 23423424; } //ok
constexpr bool get_val(){
  bool res = false;
  return res;
} //error: body只能有一个return statement


//修饰变量
//与const类似


//修饰构造函数
//构造函数可以有一个成员初始化列表, 但body必须是空的
//constexpr构造函数 允许编译器在编译时初始化对象, 前提是构造函数的参数都是常量表达式
struct complex
{
  constexpr complex(double r, double i) : re(r), im(i) { } // ok
  double re;
  double im;
}

constexpr complex cx0(0.0, 1.0); //ok. 编译期初始化

double x = 1.0;
constexpr complex cx1(x, 0); //error: x不是常量表达式
const     complex cx2(x, 0); //ok. 运行期初始化

constexpr double xx = 1.0;
constexpr complex cx3(xx, 0); //ok 编译期初始化

complex cx4(1.0, 2.0); //ok 运行期初始化
</code></pre></li></ul><ul><li><p>对POD定义的修正</p><p>?? 这是什么, 完全没有看懂 ??<br></p></li></ul></li></ul><ul><li><p>构造期表现强化</p><ul><li><p>外部模版</p><p>在标准C++中，只要在编译单元内遇到被完整定义的模板，编译器都必须将其实例化（instantiate）<br>这会大大增加编译时间，特别是模板在许多编译单元内使用相同的参数实例化。<br></p><p>C++11之前, 可以告诉编译器在特定位置开始实例化, 但无法告诉编译器不要引发模板实例化<br></p><pre><code class=language-text>template class std::vector&lt;MyClass&gt;;
</code></pre><p>C++11增加了 阻止编译器在编译期间引发模板实例化<br></p><pre><code class=language-text>extern template class std::vector&lt;MyClass&gt;;
</code></pre></li></ul></li></ul><ul><li><p>可用性的加强</p><ul><li><p>初始化列表</p><p>初始化列表的构想是 结构(或数组)的成员依据定义的顺序 由一串形参产生.<br></p><pre><code class=language-text>struct Test{
  int a;
  double b;
  int c;
}

//给予 Test一串形参,  Test的成员根据位置,自动获得初始化
//Test成员a, b, c根据自己在Test结构中定义的顺序, 自动与形参1, 2.0, 3获得匹配的初始化
//即a=1, b=2.0, c=3
Test t1{1, 2.0, 3};
</code></pre><pre><code class=language-text>//C++11 增加了初始化列表构造函数 std::initializer_list&lt;&gt;
class Test{
public:
  Test(std::initializer_list&lt;int&gt; list); //初始化列表构造函数
}
Test test{1, 2, 3, 4}; //允许Test对象可以像这样初始化


//初始化列表构造函数的优先级大于普通的构造函数
class Test{
public:
  Test(std::initializer_list&lt;int&gt; list); //初始化列表构造函数
  Test(int i): m_i(i) { };               //普通构造函数
private:
  int m_i;
}
//当初始化列表构造函数 与 普通构造函数形参一致的时候,
//如果使用{}初始化, 将调用的是初始化列表构造函数
//比如下面调用的是 Test(std::initializer_list&lt;int&gt; list);
Test test{1};

//如果想调用普通构造函数, 应该使用标准的构造函数语法
//调用的是 Test(init i);
Test test(1);
</code></pre><pre><code class=language-text>//std::initializer_list除了可以在构造函数中使用, 也可用于普通函数
void Fun(std::initializer_list&lt;int&gt; list);
Fun(1, 2, 3);
</code></pre></li></ul><ul><li><p>统一的初始化</p><pre><code class=language-text>struct BasicStruct{
  int x;
  float y;
}

struct AltStruct{
  AltStruct(int _x, float _y): x(_x), y(_y) {}
private:
  int x;
  float y;
}

//两者都可以采用一样的初始化样式
BasicStruct val1 {5, 2.1f};
AltStruct   val2 {2, 2.1f};
</code></pre></li></ul><ul><li><p>auto && decltype</p><p>C++03使用参数必须明确的指出其类别.<br>然而随着模板类别的出现以及模板元编程的技巧, 某物的类别, 特被是函数定义明确的返回类别, 不容易表示.<br>C++11提供了auto 自动类别推导, 来解决该问题<br></p><p>有被明确初始化的参数可以使用auto.<br>对于指针类型, 使用auto 和 auto*是一样的.<br>对于引用类型, 必须使用auto&. 因为auto总是推断出非引用类型<br></p></li></ul><ul><li><p>基于范围的for循环</p><p>简化了for循环. 可以使用在C型数组, 初始化列表, 和任何定义了begin(), end()的类型<br></p><pre><code class=language-text>int my_array[5] {1, 2, 3, 4, 5};
//每个元素 * 2
//注意这里是auto&amp;, 而非auto
for (auto&amp; x : my_array){
  x *= 2;
}
</code></pre></li></ul><ul><li>lambda函数表达式</li></ul><ul><li><p>返回类别后置的函数声明</p><p>?? 看样子, 主要用于模板中函数的返回类别 ??<br></p></li></ul><ul><li><p>class对象构造改良</p><pre><code class=language-text>//C++11之前, 构造函数不允许调用其他构造函数
//C++11, 取消了该限制, 允许构造函数调用其他构造函数, 这种做法称为委托构造
class SomeType{
public:
  SomeType() : SomeType(0, &quot;hahah&quot;) {}
  SomeType(int i) : SomeType(i, &quot;haha222&quot;) {}
  SomeType(string&amp; s) : SomeType(1, s) { test(); }

private:
  SomeType(int i, string&amp; s): m_i(i), m_s(s) {}

  int m_i;
  string m_s;
};
</code></pre><pre><code class=language-text>//C++03 基类的构造函数不能直接作为派生类的构造函数, 每个派生类必须实现自己的构造函数
//C++11 取消了该限制. 编译器可以使用基类的构造函数完成派生类的构造
//而将基类的构造函数带入派生类的动作. 无法选择性的部分带入.
//要么全部带入, 要么一个都不带入
class BaseClass{
public:
  BaseClass(int v);
};

class DerivedClass :public BaseClass {
public:
  using BaseClass::BaseClass; //使用基类的构造函数
};
</code></pre><pre><code class=language-text>//C++03 class 成员变量只能在构造函数中被初始化
//C++11 取消了该限制, 使其可以在声明的地方初始化
class SomeClass{
public:
  SomeClass() {}   //当构造函数中未初始化m_val时, 使用定义的值45
  SomeClass(int i) : m_val(i) {} //如果构造函数中初始化了m_val, 则使用构造函数中的值
private:
  int m_val = 45;
  int m_test {45}; //也可以使用列表初始化的样式
};
</code></pre></li></ul><ul><li><p>显示虚函数重载</p><pre><code class=language-text>struct Base{
  virtual void func(int);
};

struct Derived : Base{
  virtual void func(int) override;    //ok 显示重载
  virtual void func(float) override;  //error: struct Base中没有对应的虚函数
};
</code></pre><pre><code class=language-text>struct Base{
  virtual void func(int) final;
};

struct Derived : Base{
  virtual void func(int);  //error: struct Base:func 禁止重载
};
</code></pre></li></ul><ul><li><p>空指针</p><pre><code class=language-text>//C++11之前, 使用NULL来表示0和空指针 ( C的做法 )
//但是在函数重载时候, 就容易引发歧义
void foo (char*);
void foo (int);
void foo (nullptr_t);
//调用的实际是 void foo(int);  而非void foo(nullptr_t)
foo(NULL)

//C++11引入了nullptr 用来表示指针
//这样调用的就是 void foo(nullptr_t)
foo(nullptr)
</code></pre></li></ul><ul><li><p>强类型枚举</p><p>?? 不是很明白 这个的意义在哪 ??<br>?? 枚举不和int比较, 不会很限制使用场景吗 ??<br></p></li></ul><ul><li><p>角括号</p><p>C++03的分析器一律把 >> 视为右移运算符. 为了避免, 编码时候不能把>>连着写. 尤其在模板编码中<br>C++11变更了分析器规则, 使其更加智能<br></p></li></ul><ul><li><p>显式类别转换 explicit</p><p>?? 完全没有印象 ??<br></p></li></ul><ul><li><p>模板的别名</p><p>?? 对模板 完全不熟悉 ??<br></p></li></ul><ul><li>模板参数的缺省值</li></ul><ul><li><p>无限制的unions</p><p>?? 需要详细了解一下 ??<br></p></li></ul></li></ul><ul><li><p>能力的提升</p><p>这些特性让C++语言能够做一些以前做不到的，或者极其复杂的，或者需求一些不可移植的库的事情。<br></p><ul><li><p>可变参数模板</p><p>?? 又是模板&mldr; ??<br></p></li></ul><ul><li><p>字符串字面值</p><pre><code class=language-text>//C++03 提供了两种字符串字面值
&quot;abc&quot;   //产生以空字符\0结尾的 const char 数组
L&quot;abc&quot;  //产生以空字符\0结尾的 const wchat_t数组

//C++11加强了对Unicode的支持,
//类别char的定义被修改为其大小至少能够存储UTF-8的8位编码, 并且能够容纳编译器的基本字符集的任何成员
//新增char16_t, char32_t, 分别对应UTF-16, UTF-32
u8&quot;I'm a UTF-8 string.&quot;
u&quot;I'm a UTF-16 string.&quot;
U&quot;I'm a UTF-32 string.&quot;
//并且允许直接在字符串内插入unicode codepoints
// \u之后的是16 bits的十六进制数值;
// \U之后的是32 bits的十六进制数值
u8&quot;This is a Unicode Character: \u2018.&quot;
u&quot;This is a bigger Unicode Character: \u2018.&quot;
u8&quot;This is a Unicode Character: \U00002018.&quot;
</code></pre><pre><code class=language-text>R&quot;(The String Data \ Stuff &quot; )&quot; //()中的内容不会被转义

//R 可以和 u8/u/U组合使用
u8R&quot;(I'm a &quot;raw UTF-8&quot; string.)&quot;
</code></pre></li></ul><ul><li><p>用户定义字面值</p><p>C++11开放用户定义新的字面修饰符（literal modifier），利用自定义的修饰符完成由字面值构造对象。<br></p><p>字面值转换可以定义为两个阶段：原始与转换后（raw与cooked)<br>原始字面值指特定类型的字符序列，而转换后的字面值则代表另一种类别。<br>如字面值1234，原始字面值是'1&rsquo;, &lsquo;2&rsquo;, &lsquo;3&rsquo;, &lsquo;4&rsquo;的字符序列；<br>而转换后的字面值是整数值1234。另外，字面值0xA转换前是序列'0&rsquo;, &lsquo;x&rsquo;, &lsquo;A&rsquo;；转换后代表整数值10。<br></p><p>?? 如何使用 ??<br></p></li></ul><ul><li><p>多线程编程支持</p><p>C++标准委员会计划统一对多线程编程的支持. 这将涉及两个部分：<br></p><ol><li>设计一个可以使多个线程在一个进程中共存的内存模型；<br></li><li>为线程之间的交互提供支持. 这部分将由程序库提供支持<br></li></ol><p>在多个线程可能会访问相同内存的情形下，由一个内存模型对它们进行调度是非常有必要的。<br>遵守模型规则的程序是被保证正确运行的，<br>但违反规则的程序会发生不可预料的行为，这些行为依赖于编译器的优化和内存一致性的问题。<br></p><p>虽然C++11会在语言的定义上提供一个内存模型以支持线程，但线程的使用主要将以C++11标准库的方式呈现。<br>C++11标准库会提供类别thread（std::thread）。若要执行一个线程，可以创建一个类别thread的实体，其初始参数为一个函数对象，以及该函数对象所需要的参数。透过成员函数std::thread::join()对线程会合的支持，一个线程可以暂停直到其它线程执行完毕。若有底层平台支持，成员函数std::thread::native_handle()将可提供对原生线程对象执行平台特定的操作。<br>对于线程间的同步，标准库将会提供适当的互斥锁（像是std::mutex，std::recursive_mutex等等）和条件参数（std::condition_variable和std::condition_variable_any）。前述同步机制将会以RAII锁（std::lock_guard和std::unique_lock）和锁相关算法的方式呈现，以方便程序员使用。<br>对于要求高性能，或是极底层的工作，有时或甚至是必须的，我们希望线程间的通信能避免互斥锁使用上的开销。以原子操作来访问内存可以达成此目的。针对不同情况，我们可以透过显性的内存屏障改变该访问内存动作的可见性。<br>对于线程间异步的传输，C++11标准库加入了以及std::packaged_task用来包装一个会传回异步结果的函数调用。因为缺少结合数个future的功能，和无法判定一组promise集合中的某一个promise是否完成，futures此一提案因此而受到了批评。<br>更高级的线程支持，如线程池，已经决定留待在未来的Technical Report加入此类支持。更高级的线程支持不会是C++11的一部分，但设想是其最终实现将创建在目前已有的线程支持之上。<br>std::async提供了一个简便方法以用来执行线程，并将线程绑定在std::future。用户可以选择一个工作是要多个线程上异步的执行，或是在一个线程上执行并等待其所需要的资料。默认的情况，实现可以根据底层硬件选择前面两个选项的其中之一。另外在较简单的使用情形下，实现也可以利用线程池提供支持。<br></p><p>?? 后期重点查看 ??<br></p></li></ul><ul><li>thread-local的存储期限</li></ul><ul><li><p>使用或禁用对象的默认函数</p><pre><code class=language-text>//C++03中, 用户无法精确控制class的默认函数, 比如默认构造函数, 默认复制构造函数, 默认赋值运算符等
//比方说, 要让class不能被copy, 必须将复制构造函数 与 赋值运算符声明为private, 并不去定义他们.
//        这样尝试使用这些为定义的函数会导致编译期或连接器错误
//        但这种手法一点也不理想
//
//C++11允许显示的声明采用或禁用编译器提供的内置函数
//
struct SomeType{
  SomeType() = default; //使用默认的构造函数
};

//
struct NonCopyable{
  //禁用复制构造函数 &amp;&amp; 赋值运算符
  NonCopyable &amp; operator=(const NonCopyable&amp; ) = delete;
  NonCopyable (const NonCopyable&amp; ) = delete;

  NonCopyable () = default;
}
</code></pre></li></ul><ul><li><p>long long int类型</p><p>在32位系统上，一个long long int是保有至少64个有效比特的整数类别。<br>C99将这个类别引入了标准C中，目前大多数的C++编译器也支持这种类别。<br>C++11将把这种类别添加到标准C++中。<br></p></li></ul><ul><li>静态assertion</li></ul><ul><li><p>sizeof运算符可以作用于class的所有成员</p><pre><code class=language-text>//C++11之前, sizeof运算符只能用于class的静态成员
//C++11修改为均可使用
struct SomeType{
  OtherType member;
};

sizeof(SomeType::member); //传回OtherType的大小
//?? 如果成员是vector数组, 会是什么样 ??
</code></pre></li></ul><ul><li><p>垃圾回收机制</p><p>?? 没明白&mldr; ??<br></p></li></ul></li></ul><h4 id=stl变更>stl变更
<a class=anchor href=#stl%e5%8f%98%e6%9b%b4>#</a></h4><ul><li><p>stl组件上的升级</p><p>基于C++11新特性, 实现stl的更优<br></p><ol><li>右值引用和其相关的move支持<br></li><li>支持UTF-16编码，和UTF-32字符集<br></li><li>变长参数模板（与右值引用搭配可以达成完美转发（perfect forwarding））<br></li><li>编译期常量表达式<br></li><li>Decltype<br></li><li>显式类别转换子<br></li><li>使用或禁用对象的默认函数<br></li></ol></li></ul><ul><li>线程支持</li></ul><ul><li>多元组类别</li></ul><ul><li>散列表</li></ul><ul><li>正则表达式</li></ul><ul><li>通用智能指针</li></ul><ul><li><p>可扩展的随机数功能</p><p>?? C++版本的 也太麻烦了把 &mldr; ??<br></p></li></ul><ul><li><p>包装引用</p><p>?? 与模板有关 ??<br></p></li></ul><ul><li>对函数对象的包装</li></ul><ul><li><p>用于元编程的类别属性</p><p>?? ?? ??<br></p></li></ul><ul><li>用于计算函数对象返回类型的统一方法</li></ul><ul><li><p>itoa函数</p><p>iota 函数可将给定区间的值设定为从某值开始的连续值，<br>例如将连续十个整数设定为从 1 开始的连续整数（即 1、2、3、4、5、6、7、8、9、10）。<br></p><pre><code class=language-text>#include &lt;iostream&gt;
#include &lt;array&gt;
#include &lt;numeric&gt;

std::array&lt;int, 10&gt; ai;
std::iota(ai.begin(), ai.end(), 1);
for(int i: ai){
  std::cout&lt;&lt;i&lt;&lt;&quot; &quot;;//1 2 3 4 5 6 7 8 9 10
}
</code></pre><p>?? 貌似 作用不大呀 ??<br></p></li></ul><h3 id=2011-十进制浮点数扩展>2011 十进制浮点数扩展
<a class=anchor href=#2011-%e5%8d%81%e8%bf%9b%e5%88%b6%e6%b5%ae%e7%82%b9%e6%95%b0%e6%89%a9%e5%b1%95>#</a></h3><h3 id=2014-c-plus-plus-14-第四个c-plus-plus-标准>2014 C++14 第四个C++标准
<a class=anchor href=#2014-c-plus-plus-14-%e7%ac%ac%e5%9b%9b%e4%b8%aac-plus-plus-%e6%a0%87%e5%87%86>#</a></h3><p>C++14旨在作为C++11的一个小扩展, 主要提供漏洞修复和小的改进. <a href=https://zh.wikipedia.org/wiki/C%2B%2B14>参考资料</a><br></p><h4 id=语言特性变更>语言特性变更
<a class=anchor href=#%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7%e5%8f%98%e6%9b%b4>#</a></h4><ul><li><p>泛型的lambda</p><p>?? 这是什么玩意 ??<br></p><pre><code class=language-text>//C++11中, lambda函数的形参必须被声明为具体的类型
//C++14 放宽了这个要求
auto lambda = [](auto x, auto y) { return x + y; }
</code></pre></li></ul><ul><li><p>lambda捕获部分中使用表达式</p><p>C++11的lambda函数允许通过 [值copy 或 引用] 捕获已在外层作用域声明的变量.<br>C++14允许lambda成员用任意的被捕获表达式初始化.意味着:<br></p><ol><li>允许 capture by value-move<br></li><li>允许任意声明的lambda成员, 而不需要外层作用域有一个具有相应名字的变量.这称为广义捕获.<br>即使在闭包区域中存在相同的变量也会被新变量覆盖(只是在lambda中被覆盖).<br>新变量类型由他的初始化表达式推导, 类似与auto<br></li></ol><pre><code class=language-text>//val新变量不需要特意声明类型, 会根据auto自动推导
//lambda的返回值为1, 说明新变量val成功被初始化
auto lambda = [val = 1]{ return val; }


//另一个例子
auto x = 1;
//lambda捕获中, r是x(外部x)的引用; x是新变量(会在lambda中覆盖外部变量x)
//此处的新变量r为1; 新变量x为10
auto f = [&amp;r=x, x=x*10]{
  ++ r;
  return r + x;
}
//结果是外部变量x被设置为2;  f()返回12
f();
</code></pre></li></ul><ul><li><p>函数返回类型推导</p><p>C++11允许lambda函数根据return语句的表达式类型推断返回类型;<br>C++14为一般的函数也提供了这个功能.<br></p><p>?? 真的完全想不通这种不易阅读的特性 到底有什么用 ??<br></p></li></ul><ul><li><p>decltype(auto)</p><pre><code class=language-text>const int x = 0;
auto x1 = x; //x1为int类型
decltype(auto) x2 = x; //x2为const int类型

int y =0;
int&amp; y1 = y;
auto y2 = y1; //int类型
decltype(auto) y3=y1; //int&amp;

int&amp;&amp; z =0;
auto z1 = std::move(z); //int
decltype(auto) z2 = std::move(z); //int&amp;&amp;
</code></pre><pre><code class=language-text>//函数返回类型为int
auto f (const int&amp; i) { return i; }

//函数返回类型为const int&amp;
decltype(auto) g (const int&amp; i) { return i; }
</code></pre></li></ul><ul><li><p>constexpr函数放宽限制</p><p>C++11对constexpr函数做了严格的限制, 允许的语句非常少(基本就是一条return语句&mldr;)<br>C++14放宽了该限制. 允许constexpr有以下内容:<br></p><ol><li>任何声明, 除了<br><ul><li>static 或 thread_local变量<br></li><li>没有初始化的变量声明<br></li></ul></li><li>条件分支语句 if && switch<br></li><li>所有的循环语句, 包含range for 循环<br></li><li>表达式可以改变一个对象的值<br>需要该对象的生命期在声明为constexpr的函数内部开始, 包括对有constexpr声明的任何非const非静态成员函数的调用.<br></li></ol><p>此外，C++11指出，所有被声明为constexpr的非静态成员函数也隐含声明为const（即函数不能修改*this的值）<br>C++14中这点已经被删除，非静态成员函数可以为非const<br></p></li></ul><ul><li><p>变量模板</p><p>C++14之前模板可以是函数模板或类模板<br>C++14中引入了变量模板<br></p></li></ul><ul><li><p>class对象构造优化 (聚合类的成员初始化)</p><p>C++11中class的成员变量可以在声明的地方初始化. 但是如果构造函数中未定义该变量, 那么该class就不允许使用聚合初始化;<br>C++14中放松了这一限制<br></p><pre><code class=language-text>struct Test{
  int m_x;
  int m_y = 40;

  Test(int x) : m_x(x) {}
};

Test t1{1}; //在C++11中是不允许的, 因为Test的构造函数Test(int x)中未初始化m_y

Test t2{1}; //在C++14中是合法的. m_y会使用默认值40
</code></pre></li></ul><ul><li><p>二进制字面量</p><p>C++14的数字允许使用二进制形式指定.使用前缀0b或0B.<br></p></li></ul><ul><li><p>数字分位符</p><p>C++14引入单引号 &rsquo; 作为数字分位符号, 使得数值型的字母量更好的可读性.<br></p><pre><code class=language-text>auto integer_literal = 100'0000;
auto floating_point_literal = 1.797'693'134'862'315'7E+308;
auto binary_literal = 0b0100'1100'0110;
auto silly_example = 1'0'0'000'00;
</code></pre></li></ul><ul><li><p>deprecated属性</p><p>deprecated属性允许标记不推荐使用的实体，该实体仍然能合法使用，<br>但会让用户注意到使用它是不受欢迎的，并且可能会导致在编译期间输出警告消息。<br>deprecated可以有一个可选的字符串文字作为参数，以解释弃用的原因和/或建议替代者。<br></p><pre><code class=language-text>[[deprecated]] void f();

[[deprecated(&quot;g() is unsafe, use h() instead&quot;)]]
void g();

void test(){
  f(); //warnning: f()已被弃用
  g(); //warnning: g() is unsafe, use h() instead
}
</code></pre></li></ul><h4 id=stl变更>stl变更
<a class=anchor href=#stl%e5%8f%98%e6%9b%b4>#</a></h4><ul><li><p>共享的互斥体和锁</p><p>C++14增加了一类共享的互斥体和相应的共享锁<br>起初选择的名字是std::shared_mutex，但由于后来增加了与std::timed_mutex相似的特性，std::shared_timed_mutex成为了更适合的名字<br></p></li></ul><ul><li>元函数的别名</li></ul><ul><li><p>关联容器中的异构查找</p><p>C++标准库定义了四个关联容器类。<br>set和multiset允许用户根据一个值在容器中查找对应的的同类型的值。<br>map和multimap容器允许用户指定键（key）和值（value）的类型，根据键进行查找并返回对应的值。<br>然而，查找只能接受指定类型的参数，在map和multimap中是键的类型，而在set和multiset容器中就是值本身的类型。<br></p><p>C++14允许通过其他类型进行查找，只需要这个类型和实际的键类型之间可以进行比较操作。[<br>这允许std::set&lt;std::string>使用const char*，或任何可以通过operator&lt; 与std::string比较的类型作为查找的参数。<br></p><p>为保证向后兼容性，这种异构查找只在提供给关联容器的比较器允许的情况下有效。<br>标准库的泛型比较器，如std::less&lt;>与std::greater&lt;>允许异构查找<br></p></li></ul><ul><li><p>stl自定义字面量</p><p>C++11增加了自定义字面量的语言特性. C++14的stl中利用了这个特性<br>C++14 stl定义了如下字面量后缀<br></p><ol><li>s 创建各种std::basic_string类型<br></li><li>h, min, s, ms, us, ns 创建相应的std::chrono::duration时间间隔<br></li><li>if, i, il 创建std::complex&lt;float>, std::complex&lt;double>, std::complex&lt;long double>复数类型<br></li></ol><p>这些字面量可以用于编译时的constexpr<br></p><pre><code class=language-text>//两个s互补干扰, 表示std::basic_string的s只能对字符串字面量操作, 而表示秒的只针对数字.
auto str = &quot;hello world&quot;s;
auto dur = 60s;
auto z   = 99i;
</code></pre></li></ul><ul><li><p>通过类型寻址多元组</p><p>C++11引入的std::tuple类型允许不同类型的值的聚合体用编译期整型常数索引。<br>C++14还允许使用类型代替常数索引，从多元组中获取对象。<br>若多元组含有多于一个这个类型的对象，将会产生一个编译错误<br></p><pre><code class=language-text>tuple&lt;string, string, int&gt; t(&quot;foo&quot;, &quot;bar&quot;, 7);
int i = get&lt;2&gt;(t);    //i = 7; C++11
int j = get&lt;int&gt;(t);  //j = 7; C++14新增
string s = get&lt;string&gt;(t); //编译错误, 歧义
</code></pre></li></ul><ul><li><p>较小的标准库特性</p><ol><li>std::make_unique可以像std::make_shared一样使用, 用于产生std::unique_str对象<br></li><li>std::is_finale用于识别一个class类型是否禁止被继承<br></li><li>std::integral_constant增加了一个返回常量值的operator()<br></li><li>全局std::begin/std::end函数之外, 增加了std::cbegin/std::cend函数, 用于返回常量迭代器 constant iterators<br></li></ol></li></ul><h3 id=2015-文件系统>2015 文件系统
<a class=anchor href=#2015-%e6%96%87%e4%bb%b6%e7%b3%bb%e7%bb%9f>#</a></h3><h3 id=2015-用于并行计算的扩展>2015 用于并行计算的扩展
<a class=anchor href=#2015-%e7%94%a8%e4%ba%8e%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97%e7%9a%84%e6%89%a9%e5%b1%95>#</a></h3><h3 id=2015-事务性内存操作>2015 事务性内存操作
<a class=anchor href=#2015-%e4%ba%8b%e5%8a%a1%e6%80%a7%e5%86%85%e5%ad%98%e6%93%8d%e4%bd%9c>#</a></h3><h3 id=2015-概念库-用于优化编译期信息>2015 概念库, 用于优化编译期信息
<a class=anchor href=#2015-%e6%a6%82%e5%bf%b5%e5%ba%93-%e7%94%a8%e4%ba%8e%e4%bc%98%e5%8c%96%e7%bc%96%e8%af%91%e6%9c%9f%e4%bf%a1%e6%81%af>#</a></h3><h3 id=2016-用于并行计算的扩展>2016 用于并行计算的扩展
<a class=anchor href=#2016-%e7%94%a8%e4%ba%8e%e5%b9%b6%e8%a1%8c%e8%ae%a1%e7%ae%97%e7%9a%84%e6%89%a9%e5%b1%95>#</a></h3><h3 id=2017-标准库扩展>2017 标准库扩展
<a class=anchor href=#2017-%e6%a0%87%e5%87%86%e5%ba%93%e6%89%a9%e5%b1%95>#</a></h3><h3 id=2017-提供范围机制>2017 提供范围机制
<a class=anchor href=#2017-%e6%8f%90%e4%be%9b%e8%8c%83%e5%9b%b4%e6%9c%ba%e5%88%b6>#</a></h3><h3 id=2017-协程库扩展>2017 协程库扩展
<a class=anchor href=#2017-%e5%8d%8f%e7%a8%8b%e5%ba%93%e6%89%a9%e5%b1%95>#</a></h3><h3 id=2017-c-plus-plus-17-第五个c-plus-plus-标准>2017 C++17 第五个C++标准
<a class=anchor href=#2017-c-plus-plus-17-%e7%ac%ac%e4%ba%94%e4%b8%aac-plus-plus-%e6%a0%87%e5%87%86>#</a></h3><p>C++17旨在作为大型扩展. <a href=https://zh.wikipedia.org/wiki/C%2B%2B17>参考资料</a><br></p><h4 id=新功能>?? 新功能 ??
<a class=anchor href=#%e6%96%b0%e5%8a%9f%e8%83%bd>#</a></h4><ul><li>static_assert无需提供出错信息</li></ul><ul><li>具有模板形式的模板参数允许使用typename (之前只能使用class)</li></ul><ul><li>std::uncaught_excepitions取代std::uncaught_exception</li></ul><ul><li>变长参数模板的Folding运算</li></ul><ul><li>容器访问操作表示方法的统一化</li></ul><ul><li>连续迭代器</li></ul><ul><li>新增特殊数学函数</li></ul><h4 id=语言特性>语言特性
<a class=anchor href=#%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7>#</a></h4><ul><li><p>u8字面量</p><pre><code class=language-text>//C++11的时候, u8可以修饰字符串
//C++17新增了u8可以修饰单个字符
char x = u8'x';
</code></pre></li></ul><ul><li><p>使noexcept成为系统的一部分</p><p>?? 需要再仔细的查看 ??<br>noexcept在C++11中首次加入, 作用是抛出异常, 取代throw ?? 为什么取代throw ??<br></p><p>C++17中使其成为了系统的一部分 ??什么意思??<br></p></li></ul><ul><li><p>{}列表初始化的自动推导规则</p><p>具体详见C++11中的说明 <a href=#%e5%88%9d%e5%a7%8b%e5%8c%96%e5%88%97%e8%a1%a8>初始化列表</a><br></p><pre><code class=language-text>//C++11中会被推导为 std::initializer_list&lt;int&gt;
//C++17中推导为 int
auto x {3};
</code></pre></li></ul><ul><li><p>lambda函数按值捕获this指针</p><p>C++17之前, lambda只能按引用捕获this指针<br>C++17允许使用*this捕获对象的副本<br></p></li></ul><ul><li><p>class 构造函数</p><p>?? 完全没有概念 ??<br></p><ol><li>编译时 if constexpr<br></li><li>构造函数lambda<br></li></ol></li></ul><ul><li><p>内联变量 inline</p><p>过去inline用于函数声明, 现在也可以用于变量声明, 表示函数或定义可定义多次(内容必须完全相同)<br>这允许在头文件中定义一个内联变量<br></p></li></ul><ul><li><p>结构化绑定</p><p>变量定义初始化时, 允许形如auto [x,y,z] = expr;<br>其中expr的 元组类似的对象包括 std::tuple, std::pair, std::array等聚合结构<br></p><pre><code class=language-text>//例子1
using Coordinate = std::pair&lt;int, int&gt;;
Coordinate origin() { return Coordinate{1,2}; }
const auto [x, y] = origin(); //x=1; y=2

//例子2
std::unordered_map&lt;std::string, int&gt; mapping{
  {&quot;a&quot;, 1},
  {&quot;b&quot;, 2},
  {&quot;c&quot;, 3},
};
for (const auto&amp; [key, value] : mapping:){
   //do something
}
</code></pre></li></ul><ul><li><p>if/switch选择语句可以带初始化</p><pre><code class=language-text>//例子1
//之前需要放到语句块中限制锁的范围
{
  std::lock_guard&lt;std::mutex&gt; lk(mx);
  if (v.empty()) v.push_back(val);
}
//现在可以直接放到if中
if (std::lock_guard&lt;std::mutex&gt; lk(mx); v.empty()) {
  v.push_back(val);
}


//例子2
//更好的限制了变量的作用域
Foo gadget(args);
switch (auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
}
//vs.现在
switch (Foo gadget(args); auto s = gadget.status()) {
  case OK: gadget.zip(); break;
  case Bad: throw BadFoo(s.message());
}
</code></pre></li></ul><ul><li><p>嵌套的namespace</p><pre><code class=language-text>//C++17以前
namespace A{
  namespace B{
    namespace C{
      int i;
    }
  }
}

//C++17简化了
namespace A::B::C{
  int i;
}
</code></pre></li></ul><ul><li><p>fallthrough, nodiscard, maybe_unused特性</p><p>C++17中新增<br></p></li></ul><h4 id=stl>stl
<a class=anchor href=#stl>#</a></h4><ul><li>std::variant</li></ul><ul><li>std::optional</li></ul><ul><li>std::any</li></ul><ul><li>std::string_view</li></ul><ul><li>std::filesystem</li></ul><ul><li>std::invoke</li></ul><ul><li>std::apply</li></ul><ul><li>std::byte</li></ul><ul><li>maps && sets更优效率的移动节点</li></ul><ul><li><p>并行算法</p><p>许多stl算法, 如copy, find和sort支持并行执行策略<br></p></li></ul><h3 id=2018-网络库>2018 网络库
<a class=anchor href=#2018-%e7%bd%91%e7%bb%9c%e5%ba%93>#</a></h3><h3 id=2018-并行扩展>2018 并行扩展
<a class=anchor href=#2018-%e5%b9%b6%e8%a1%8c%e6%89%a9%e5%b1%95>#</a></h3><h3 id=2018-模块>2018 模块
<a class=anchor href=#2018-%e6%a8%a1%e5%9d%97>#</a></h3><h3 id=2020-c-plus-plus-20-第五个c-plus-plus-标准>2020 C++20 第五个C++标准
<a class=anchor href=#2020-c-plus-plus-20-%e7%ac%ac%e4%ba%94%e4%b8%aac-plus-plus-%e6%a0%87%e5%87%86>#</a></h3><p>C++20是一项非常大的改动. <a href="https://zhuanlan.zhihu.com/p/137646370?utm_id=0">参考资料</a><br></p><h4 id=语言特性>语言特性
<a class=anchor href=#%e8%af%ad%e8%a8%80%e7%89%b9%e6%80%a7>#</a></h4><ul><li><p>新增关键字</p><ol><li>concept<br></li><li>requires<br></li><li>constinit<br></li><li>consteval<br></li><li>co_await<br></li><li>co_return<br></li><li>co_yield<br></li><li>char8_t<br></li></ol></li></ul><ul><li><p>新增标识符</p><ol><li>import<br></li><li>module<br></li></ol></li></ul><ul><li><p>modules 模块</p><p>优点:<br></p><ol><li>没有头文件<br></li><li>声明实现仍然可以分离, 但非必要<br></li><li>可以显示指定哪些导出(类, 函数等)<br></li><li>不需要头文件重复引入宏 include<br></li><li>模块之间名称可以相同 不会冲突<br></li><li>模块只处理一次, 编译更快 (头文件每次引入都需要处理)<br></li><li>预处理宏只在模块内有效<br></li><li>模块引入顺序无关紧要 (头文件引入顺序不同,可能发生不同结果)<br></li></ol><pre><code class=language-text>//创建模块
//export导出模块; 模块的名字是cppcon
export module cppcon;
namespace CppCon{
  auto GetWelcomeHelper() { return &quot;Hello World&quot;; }
  export auto GetWelcome() { return GetWelcomehelper(); }
}

//引用模块
import cppcon;
int main(){
  std::cout &lt;&lt; CppCon::GetWelcome();
}
</code></pre></li></ul><ul><li><p>import头文件</p><pre><code class=language-text>//隐式的将 iostream 转换为模块
//加速构建, 因为iosteam只会处理一次
//和预编译PCH具有相似的效果 ?? PCH是什么 ??
import &lt;iostream&gt;
</code></pre></li></ul><ul><li><p>Ranges</p><p>Range代表一串元素或者一串元素中的一段<br>意义:<br></p><ol><li>简化语法, 方便使用<br></li><li>防止begin/end不配对<br></li><li>使变换/过滤等串联操作成为可能<br></li></ol><pre><code class=language-text>vector&lt;int&gt; data{11, 22, 33};
sort(begin(data), end(data));
sort(data); //使用Ranges
</code></pre><pre><code class=language-text>//View: 延迟计算, 不持有, 不改写
//Actions: 即时处理, 改写
//Algorithms: 所有接受begin/end对的算法都可以使用
//View和Ations使用管道符 | 串联

//例子1 串联view
vector&lt;int&gt; data{1,2,3,4,5,6,7,8,9,10};
auto result = data |
              views::remove_if([] (int i) { return i % 2 == 1;}) |
              views::transform([])(int i) { return to_string(i);});
//result = {&quot;2&quot;,&quot;4&quot;,&quot;6&quot;,&quot;8&quot;,&quot;10&quot;};
//注意 以上操作被延迟, 只有便利result的时候才触发


//例子2 串联actions
//排序然后去重
//操作会原地对data进行更改, 然后返回
vector&lt;int&gt; data{4, 3, 4, 1, 8, 0, 8};
vector&lt;int&gt; result = data| actions::sort | actions::unique;


//例子3 过滤和变换
//所有的计算延迟到accumulate累加遍历的时候发生
int total = accumulate( view::ints(1) |  //产生一个无限对整型数列
                        view::transform([] (int i) { return i * i;}) | //平方
                        view::take(10), //取前10个元素
                        0); //累加
</code></pre></li></ul><ul><li><p>协程</p><p>意义:<br></p><ol><li>异步I/O<br></li><li>延迟计算<br></li><li>事件驱动的程序<br></li><li>generator<br></li></ol><pre><code class=language-text>//co_wait    挂起协程, 等待其他计算完成
//co_return  从协程返回 (协程禁用return)
//co_yield   弹出一个值, 挂起协程, 下一次调用继续协程的运行
//for co_await 循环体
</code></pre></li></ul><ul><li><p>Concepts</p><p>?? 模板相关 ??<br></p></li></ul><ul><li><p>lambda</p><ol><li>需要显示捕获this变量<br>C++20之前 [=] 隐式捕获this<br>C++20开始 需要显示捕获this [=, this]<br></li><li>模板形式的lambda表达式<br></li><li>lambda表达式捕获 支持打包展开<br></li></ol></li></ul><ul><li>constexpr 更新</li></ul><ul><li><p>原子智能指针 Atomic</p><p>智能指针对于数据读写并非线程安全.<br>C++20之前, 多线程中使用智能指针, 需要使用mutex控制访问.<br>C++20新增 atomic&lt;shared_ptr&lt;T>>, atomic&lt;weak_ptr&lt;T>><br></p></li></ul><ul><li><p>class 指定初始化</p><pre><code class=language-text>struct Data{
  int m_x = 0;
  std::string m_s;
};

Data d{.m_s = &quot;Hellow&quot;};
</code></pre></li></ul><ul><li><p>&lt;=> 运算符</p><p>三路比较运算符<br></p><pre><code class=language-text>//类似C的strcmp函数返回-1, 0, 1
//但实际&lt;=&gt;返回的并非int类型, 而是&lt;compare&gt;头中的对象
(a &lt;=&gt; b ) &lt; 0 //如果a&lt;b为true
(a &lt;=&gt; b ) == 0 //如果a==b为true
(a &lt;=&gt; b ) &gt; 0 //如果a&gt;b为true
</code></pre></li></ul><ul><li><p>范围for循环语句 支持初始化语句</p><p>C++17 if, switch语句支持了初始化语句<br>C++20 新增for循环语句的支持<br></p><pre><code class=language-text>for (auto data = GetData(); auto&amp; value : data){
  //do something
}
</code></pre></li></ul><ul><li><p>特性测试宏</p><p>__has_cpp_attribute(fallthrough)<br>__cpp_binary_literals<br>__cpp_chart_t<br>__cpp_coroutines<br></p></li></ul><ul><li><p>consteval</p><p>constexpr函数可能编译期执行, 也可以在运行期执行;<br>consteval只能在编译期执行<br></p></li></ul><ul><li><p>constinit</p><p>强制指定以常量方式初始化<br></p><pre><code class=language-text>const char* GetStringDyn() {
  return &quot;dynamic init&quot;;
}
constexpr const char* GetString(bool constInit) {
  return constInit ?
    &quot;constant init&quot; :
    GetStringDyn();
}
constinit const char* a = GetString(true); // ✔
constinit const char* b = GetString(false); // ❌
</code></pre></li></ul><ul><li><p>用using引用enum类型</p><pre><code class=language-text>enum class CardTypeSuit {
  Clubs,
  Diamonds,
  Hearts,
  Spades
};
//C++20之前
std::string_view GetString(const CardTypeSuit cardTypeSuit) {
switch (cardTypeSuit) {
case CardTypeSuit::Clubs:
  return &quot;Clubs&quot;;
case CardTypeSuit::Diamonds:
  return &quot;Diamonds&quot;;
case CardTypeSuit::Hearts:
   return &quot;Hearts&quot;;
case CardTypeSuit::Spades:
   return &quot;Spades&quot;;
  }
}
//C++20
std::string_view GetString(const CardTypeSuit cardTypeSuit) {
switch (cardTypeSuit) {
   using enum CardTypeSuit; // 这里
   case Clubs: return &quot;Clubs&quot;;
   case Diamonds: return &quot;Diamonds&quot;;
   case Hearts: return &quot;Hearts&quot;;
   case Spades: return &quot;Spades&quot;;
  }
}
</code></pre></li></ul><h4 id=stl>stl
<a class=anchor href=#stl>#</a></h4><ul><li>choron 增加日历和时区的支持</li></ul><ul><li><p>std::span</p><p>某段连续数据的视图<br>不持有数据, 不分配和销毁数据<br>copy非常快<br>不支持数据跨步<br>可通过运行期确定长度, 也可编译期确定长度<br></p></li></ul><ul><li><p>特性测试宏</p><p>__cpp_lib_conceps<br>__cpp_lib_ranges<br>__cpp_lib_scoped_lock<br></p></li></ul><ul><li><p>&lt;version></p><p>包含c++标准库版本, 发布日期, 版权证书, 特性宏等<br></p></li></ul><ul><li><p>std::format</p><p>?? C++ 也有format了 &mldr;. ??<br></p></li></ul><h2 id=设计原则>设计原则
<a class=anchor href=#%e8%ae%be%e8%ae%a1%e5%8e%9f%e5%88%99>#</a></h2><ol><li>C++设计成直接的和广泛的支援多种程式设计风格（过程化程式设计、数据抽象、物件导向程式设计、泛型程式设计）。<br></li><li>C++设计成给程式设计者更多的选择，即使可能导致程式设计者选择错误。<br></li><li>C++设计成尽可能与C相容，借此提供一个从C到C++的平滑过渡。<br></li><li>C++避免平台限定或没有普遍用途的特性。<br></li><li>C++不使用会带来额外开销的特性。<br></li><li>C++设计成无需复杂的程式设计环境。<br></li></ol><h2 id=待学习>待学习
<a class=anchor href=#%e5%be%85%e5%ad%a6%e4%b9%a0>#</a></h2><ol><li>stl<br>C++中很重要的功能, 必须要尽快了解常用的<br></li><li>新的概念<br>C++20中增加了很多新概念<br></li><li>新的语言特性<br>只需要学习常用的特性, 有些特性是为了配合模板而来的, 暂时不需要学习<br></li><li>其他常用的库<br>比如网络库Asio, 格式库protobuf<br></li><li>模板<br>模板的作用 更多的是用在stl的编写上, 日常开发使用的比较少, 可以暂时先不学习<br></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#演变>演变</a><ul><li><a href=#1979-诞生>1979 诞生</a></li><li><a href=#1983-改名c-plus-plus>1983 改名C++</a></li><li><a href=#1985-发布第一版>1985 发布第一版<span class=org-target id=org-target--C--------></span></a></li><li><a href=#1989-发布release-2-dot-0>1989 发布Release 2.0</a></li><li><a href=#1990-出版了-标准化基础>1990 出版了<span class=org-target id=org-target--The-Annotated-C---Reference-Manual></span> 标准化基础</a></li><li><a href=#1998-c-plus-plus-98-第一个c-plus-plus-标准>1998 C++98 第一个C++标准</a></li><li><a href=#2003-c-plus-plus-03-第二个c-plus-plus-标准>2003 C++03 第二个C++标准</a></li><li><a href=#2006-c-plus-plus-性能技术报告>2006 C++性能技术报告</a></li><li><a href=#2007-c-plus-plus-技术报告-库扩展>2007 C++技术报告: 库扩展</a></li><li><a href=#2010-数学函数扩展>2010 数学函数扩展</a></li><li><a href=#2011-c-plus-plus-11-第三个c-plus-plus-标准>2011 C++11 第三个C++标准</a></li><li><a href=#2011-十进制浮点数扩展>2011 十进制浮点数扩展</a></li><li><a href=#2014-c-plus-plus-14-第四个c-plus-plus-标准>2014 C++14 第四个C++标准</a></li><li><a href=#2015-文件系统>2015 文件系统</a></li><li><a href=#2015-用于并行计算的扩展>2015 用于并行计算的扩展</a></li><li><a href=#2015-事务性内存操作>2015 事务性内存操作</a></li><li><a href=#2015-概念库-用于优化编译期信息>2015 概念库, 用于优化编译期信息</a></li><li><a href=#2016-用于并行计算的扩展>2016 用于并行计算的扩展</a></li><li><a href=#2017-标准库扩展>2017 标准库扩展</a></li><li><a href=#2017-提供范围机制>2017 提供范围机制</a></li><li><a href=#2017-协程库扩展>2017 协程库扩展</a></li><li><a href=#2017-c-plus-plus-17-第五个c-plus-plus-标准>2017 C++17 第五个C++标准</a></li><li><a href=#2018-网络库>2018 网络库</a></li><li><a href=#2018-并行扩展>2018 并行扩展</a></li><li><a href=#2018-模块>2018 模块</a></li><li><a href=#2020-c-plus-plus-20-第五个c-plus-plus-标准>2020 C++20 第五个C++标准</a></li></ul></li><li><a href=#设计原则>设计原则</a></li><li><a href=#待学习>待学习</a></li></ul></nav></div></aside></main></body></html>