<!doctype html><html lang=en dir=ltr><head><meta charset=UTF-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="socket相关网络编程 "><meta name=theme-color media="(prefers-color-scheme: light)" content="#ffffff"><meta name=theme-color media="(prefers-color-scheme: dark)" content="#343a40"><meta name=color-scheme content="light dark"><meta property="og:title" content="socket base"><meta property="og:description" content="socket相关网络编程 "><meta property="og:type" content="article"><meta property="og:url" content="https://www.wcq.life/docs/socket/socket/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2024-01-18T19:13:00+00:00"><meta property="article:modified_time" content="2024-01-18T11:35:25+00:00"><title>socket base | 飘</title>
<link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png><link rel=stylesheet href=/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz+OQteg=" crossorigin=anonymous><script defer src=/flexsearch.min.js></script><script defer src=/en.search.min.4e5c732c5da2f2860ddb3871b5ec7afcb8c7a6418d50f27a8f34fff8864557f3.js integrity="sha256-TlxzLF2i8oYN2zhxtex6/LjHpkGNUPJ6jzT/+IZFV/M=" crossorigin=anonymous></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a class="flex align-center" href=/><span>飘</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><input type=checkbox id=section-708f0dc81b7f5419c74b48a85bd8146c class=toggle>
<label for=section-708f0dc81b7f5419c74b48a85bd8146c class="flex justify-between"><a role=button>os</a></label><ul><li><input type=checkbox id=section-79330aa2b633081416a3292066b69060 class=toggle>
<label for=section-79330aa2b633081416a3292066b69060 class="flex justify-between"><a href=/docs/os/linux/>linux</a></label></li><li><input type=checkbox id=section-bc761361f475fd69bbc73d5bf460a7c6 class=toggle>
<label for=section-bc761361f475fd69bbc73d5bf460a7c6 class="flex justify-between"><a href=/docs/os/mac/>mac</a></label></li><li><a href=/docs/os/dll/>静态库 && 动态库</a></li></ul></li><li><input type=checkbox id=section-26e54d0210cc81265d821ec3190ad630 class=toggle>
<label for=section-26e54d0210cc81265d821ec3190ad630 class="flex justify-between"><a role=button>emacs</a></label><ul><li><a href=/docs/emacs/emacs/>emacs</a></li><li><input type=checkbox id=section-a2752377452f4bca58ff853486780e25 class=toggle>
<label for=section-a2752377452f4bca58ff853486780e25 class="flex justify-between"><a role=button>org && gtd</a></label><ul><li><a href=/docs/emacs/org/org/>org</a></li><li><a href=/docs/emacs/org/gtd/>gtd</a></li><li><a href=/docs/emacs/org/org_gtd/>org && gtd</a></li></ul></li><li><input type=checkbox id=section-b057268f183bbbd8fd2b51c0f08a3d89 class=toggle>
<label for=section-b057268f183bbbd8fd2b51c0f08a3d89 class="flex justify-between"><a role=button>常用扩展</a></label><ul><li><a href=/docs/emacs/lisp/eshell/>eshell</a></li><li><a href=/docs/emacs/lisp/elisp/>elisp</a></li><li><a href=/docs/emacs/lisp/tramp/>tramp</a></li><li><a href=/docs/emacs/lisp/graph/>artist && plantuml</a></li><li><a href=/docs/emacs/lisp/mail/>mail</a></li><li><a href=/docs/emacs/lisp/gdb/>gdb && gud</a></li><li><a href=/docs/emacs/lisp/ai/>AI</a></li></ul></li></ul></li><li><input type=checkbox id=section-42c81085db59b939687e384dc1a68b89 class=toggle checked>
<label for=section-42c81085db59b939687e384dc1a68b89 class="flex justify-between"><a role=button>socket</a></label><ul><li><a href=/docs/socket/socket/ class=active>socket base</a></li><li><a href=/docs/socket/asio/>asio</a></li></ul></li><li><input type=checkbox id=section-67300b3ac7f08e26e6051c28bff48862 class=toggle>
<label for=section-67300b3ac7f08e26e6051c28bff48862 class="flex justify-between"><a role=button>prog language</a></label><ul><li><a href=/docs/prog_language/c++/>c++历史</a></li><li><input type=checkbox id=section-8ed743bf8ec9fea857c815b046c50755 class=toggle>
<label for=section-8ed743bf8ec9fea857c815b046c50755 class="flex justify-between"><a href=/docs/prog_language/stl/>C && C++ 常见库</a></label></li><li><a href=/docs/prog_language/shell/>shell</a></li></ul></li><li><input type=checkbox id=section-dcb54a6e72bd2dde7f84b9f427340e6a class=toggle>
<label for=section-dcb54a6e72bd2dde7f84b9f427340e6a class="flex justify-between"><a role=button>prog lsp</a></label><ul><li><a href=/docs/prog_lsp/global/>global</a></li></ul></li><li><input type=checkbox id=section-f5995d6b6281914977a4b415fe409237 class=toggle>
<label for=section-f5995d6b6281914977a4b415fe409237 class="flex justify-between"><a role=button>prog compile</a></label><ul><li><a href=/docs/prog_compile/autotools/>autotools</a></li><li><a href=/docs/prog_compile/make/>make</a></li><li><a href=/docs/prog_compile/cmake/>cmake</a></li><li><a href=/docs/prog_compile/gcc/>gcc</a></li></ul></li><li><input type=checkbox id=section-0a19098373105935c99097cc21a739f2 class=toggle>
<label for=section-0a19098373105935c99097cc21a739f2 class="flex justify-between"><a role=button>debug</a></label><ul><li><a href=/docs/prog_debug/gdb/>gdb</a></li><li><a href=/docs/prog_debug/valgrind/>valgrind</a></li></ul></li><li><input type=checkbox id=section-eda0a8fcd7e426fd95136363a63238ac class=toggle>
<label for=section-eda0a8fcd7e426fd95136363a63238ac class="flex justify-between"><a role=button>tools</a></label><ul><li><a href=/docs/tool/docker/>docker</a></li><li><a href=/docs/tool/k8s/>k8s</a></li><li><a href=/docs/tool/monitor/>monitor</a></li><li><a href=/docs/tool/hugo/>hugo</a></li><li><a href=/docs/tool/redis/>redis</a></li><li><a href=/docs/tool/sql/>数据库</a></li><li><a href=/docs/tool/protocol/>乱七八糟的协议合集</a></li></ul></li><li><input type=checkbox id=section-ae64cb93934d0a7c04532d36100c8658 class=toggle>
<label for=section-ae64cb93934d0a7c04532d36100c8658 class="flex justify-between"><a role=button>prog vc</a></label><ul><li><a href=/docs/prog_vc/git/>git</a></li></ul></li></ul></nav><script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu>
</label><strong>socket base</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents><ul><li><a href=#基本概念>基本概念</a><ul><li><a href=#socket>socket</a></li><li><a href=#socket问题>socket问题</a></li><li><a href=#i-o模型>I/O模型</a></li><li><a href=#epoll使用>epoll使用</a></li></ul></li><li><a href=#socket属性>socket属性</a><ul><li><a href=#keep-live机制>keep live机制</a></li></ul></li><li><a href=#编程实例>编程实例</a><ul><li><a href=#原始socket模型-recv中处理分包粘包>原始socket模型, recv()中处理分包粘包</a></li></ul></li><li><a href=#ipv4>ipv4</a></li></ul></nav></aside></header><article class="markdown book-article"><p>socket相关网络编程<br></p><h2 id=基本概念>基本概念
<a class=anchor href=#%e5%9f%ba%e6%9c%ac%e6%a6%82%e5%bf%b5>#</a></h2><h3 id=socket>socket
<a class=anchor href=#socket>#</a></h3><p>socket是 [应用层] 与 [传输层, 网络层] 之间的一个抽象层<br><br>它的出现是为了简化网络进程通信<br></p><h4 id=linux头文件>linux头文件
<a class=anchor href=#linux%e5%a4%b4%e6%96%87%e4%bb%b6>#</a></h4><ol><li>usr/include/x86_64-linux-gnu/sys/socket.h<br>结构体<br><br>sockaddr<br><br>函数<br><br>socket() connect() send() recv() shutdown()<br><br>socket() bind() lisent() accept() recv() send() shutdown()<br><br>g++的默认目录中已经包含了sys/的上层目录<br></li><li>usr/include/netinet/in.h<br>结构体<br><br>AF_INET 中的 sockaddr_in<br><br>AF_INET6 中的 sockaddr_in6<br><br>AF_UNIx 中的 sockaddr_un<br></li><li>user/include/arpa/inet.h<br>函数<br><br>htons()<br><br>inet_addr()<br></li><li>unistd.h<br>函数<br><br>close()<br></li></ol><h4 id=socket函数>socket函数
<a class=anchor href=#socket%e5%87%bd%e6%95%b0>#</a></h4><ol><li><p>socket(domain, socket_type, protol)<br>domain<br><br>socket_type<br><br>protol<br><br>socket()本质是创建了一个进程文件表, 返回的值为指向进程文件表的指针的索引.<br></p></li><li><p>bind(fd, sockaddr*, len)<br>fd: socket()中的文件表指针的索引<br><br>sockaddr: 地址, 端口<br><br>len: sockaddr的长度<br><br>&lt;1> 比较有意思的是sockaddr根据family的不同, 可以与不同的结构体互转<br><br>比如<br><br>AF_INET sockaddr_in<br><br>AF_INET6 sockaddr_in6<br><br>AF_UNIX sockaddr_un<br><br>这几种结构体都与sockaddr可互转(字节对齐blabla)<br><br>bind()本质是在补充socket()创建的文件表. socket()时候该文件表很多值都是空的, bind()来补充<br><br>因为client 在connect的时候, 系统会自动分配端口,以及绑定本机ip, 所以client的socket一般不必要<br><br>使用bind()<br></p></li><li><p>connet(fd, sockaddr*, len)<br>连接到其他scokaddr<br></p></li><li><p>listen(fd, iMaxNum)</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>iMaxNum是队列中的最大数, 并不是指可连接的socket数目
</span></span></code></pre></div><p>一般只在server开启listen(), 监听指定的端口信息<br></p></li><li><p>accept()<br>accept()会造成阻塞.<br><br>它会将listen()中的sockaddr进行处理<br><br>处理流程是 accept()会创建一个新的fd_connet, 此fd_connet公用server socket() fd的端口和地址<br><br>但是fd_connect仅仅是用来传输数据的<br></p></li><li><p>recv(fd, msg) send(fd, msg)<br>至accetp()时候, 一切操作就和在本地上操作一样,<br><br>所以这里的recv() 和 send()操作与本机上的文件操作是一样的<br></p></li><li><p>close(fd) shutdown(fd, type)<br>linux一切皆是file原则, fd可以关闭<br></p></li></ol><h4 id=ip-port-相关函数>[ip, port]相关函数
<a class=anchor href=#ip-port-%e7%9b%b8%e5%85%b3%e5%87%bd%e6%95%b0>#</a></h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>点分十进制ip 是以字符串形式存储的
</span></span><span style=display:flex><span>网络字节序 即 32位的二进制
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>//in_addr
</span></span><span style=display:flex><span>struct in_addr 
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>　　in_addr_t s_addr;
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>//in_addr_t
</span></span><span style=display:flex><span>typedef unsigned long  in_addr_t
</span></span></code></pre></div><ol><li><p>函数原型: in_addr_t inet_addr(const char* strptr);<br>若字符串有效, 则将点分十进制IP字符串转换为网络字节序地址，否则为INADDR_NONE<br></p></li><li><p>函数原型：int inet_aton(const char *IP, struct in_addr *addr);<br>将点分十进制IP地址转换为网络字节序存储在addr中，并且返回该网络字节序表示的无符号整数<br></p></li><li><p>函数原型：char *inet_ntoa(struct in_addr in);<br>将网络字节序的IP地址（也就是结构体in_addr类型变量）转化为点分十进制的IP地址（字符串)<br></p></li></ol><h4 id=socket-fd本质>socket fd本质
<a class=anchor href=#socket-fd%e6%9c%ac%e8%b4%a8>#</a></h4><p>socket本质是维护了fd进程文件表, 如下:<br></p><table><thead><tr><th>名称</th><th>说明</th><th>备注</th></tr></thead><tbody><tr><td>fd</td><td>文件描述符, 表的索引</td><td></td></tr><tr><td>host</td><td>1. 域名(DNS /etc/hosts) 2. ip地址</td><td>兼容Ipv4 Ipv6是难点</td></tr><tr><td>服务</td><td>1. 服务名称(/etc/services) 2. 端口</td><td></td></tr><tr><td>协议</td><td>1. 传输层(/etc/protol) 2. 网络层</td><td>链路层用到的比较少</td></tr><tr><td>网络</td><td>1. 网络名称?(DNS /etc/networks) 2. ip地址</td><td>谁会使用到这些信息??</td></tr></tbody></table><p>期间用到的函数主要有<br></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>尽量使用ipv4, ipv6通用的函数
</span></span></code></pre></div><ol><li>流程函数<br>socket() bind() listen() connect() accept()等<br></li><li>字节处理函数<br>处理大小字节序 htons() htonl() ntohs() ntohl()<br><br>处理域名与十分数字 getaddrinfo() getnameinfo()<br></li><li>处理sockaddr结构体的函数<br>getsockname() 返回local fd<br><br>getpeername() 返回remote fd<br></li></ol><h3 id=socket问题>socket问题
<a class=anchor href=#socket%e9%97%ae%e9%a2%98>#</a></h3><ol><li><p>阻塞</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>影响并发, 多路复用
</span></span></code></pre></div><p>解决方案:<br></p><ol><li>使用非阻塞模型, 比如select, poll, epoll(linux下特有), IOCP(windows下特有)</li><li>多线程 &ndash; 不推荐使用</li><li>多进程 &ndash; 不推荐使用</li></ol></li><li><p>粘包<br>解决方案:<br></p><ol><li>限制发送大小</li><li>每个消息增加长度标识</li></ol></li></ol><h3 id=i-o模型>I/O模型
<a class=anchor href=#i-o%e6%a8%a1%e5%9e%8b>#</a></h3><p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1565671711&amp;ver=1787&amp;signature=-mLkqQr803XDHb4f3aj9Lf1dJl8uVOV9fCCMMTzs0zSuOYH-qof7nsYCdgho1XLdPQYQP6QL5-WHtI6g-MD9xIsJcuxzdH*idpCZqtzl85r9D4C3XRRuOcCXqLKDzi-i&amp;new=1">强烈建议阅读</a><br><br>(链接过期, 直接搜狗搜索epoll, &ldquo;epoll本质"即是)<br></p><ol><li>阻塞式</li><li>非阻塞</li><li>select</li><li>poll</li><li>epoll (linux特有)</li><li>IOCP (windows特有)</li></ol><h3 id=epoll使用>epoll使用
<a class=anchor href=#epoll%e4%bd%bf%e7%94%a8>#</a></h3><h4 id=epoll本身为我们处理了什么>epoll本身为我们处理了什么
<a class=anchor href=#epoll%e6%9c%ac%e8%ba%ab%e4%b8%ba%e6%88%91%e4%bb%ac%e5%a4%84%e7%90%86%e4%ba%86%e4%bb%80%e4%b9%88>#</a></h4><ol><li>之前socket::recv()时, 导致我们的进程阻塞</li><li>现在socket::recv()时, 使epoll阻塞; epoll中断时, 告之进程</li></ol><h4 id=有了epoll我们还需要处理什么>有了epoll我们还需要处理什么
<a class=anchor href=#%e6%9c%89%e4%ba%86epoll%e6%88%91%e4%bb%ac%e8%bf%98%e9%9c%80%e8%a6%81%e5%a4%84%e7%90%86%e4%bb%80%e4%b9%88>#</a></h4><ol><li>创建epoll对象</li><li>添加检视的fd对象 &ndash; op, epoll_event</li><li>检测是否有中断, 然后处理</li></ol><h2 id=socket属性>socket属性
<a class=anchor href=#socket%e5%b1%9e%e6%80%a7>#</a></h2><h3 id=keep-live机制>keep live机制
<a class=anchor href=#keep-live%e6%9c%ba%e5%88%b6>#</a></h3><p>当socket服务端开启keep live之后,<br><br>服务器检测到 <span class=underline>一定时间内</span> socket不活动的时候,<br><br>就会每隔 <span class=underline>固定时间</span> 向该sockt发送 <span class=underline>固定次数</span> 的查询.<br><br>如果一直没有回应, 服务端则关闭该socket<br></p><p>对应的字段为:<br></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>tcp_keepalive_time（开启keepalive的闲置时长） 
</span></span><span style=display:flex><span>tcp_keepalive_intvl（keepalive探测包的发送间隔） 
</span></span><span style=display:flex><span>tcp_keepalive_probes （如果对方不予应答，探测包的发送次数）
</span></span></code></pre></div><h2 id=编程实例>编程实例
<a class=anchor href=#%e7%bc%96%e7%a8%8b%e5%ae%9e%e4%be%8b>#</a></h2><h3 id=原始socket模型-recv中处理分包粘包>原始socket模型, recv()中处理分包粘包
<a class=anchor href=#%e5%8e%9f%e5%a7%8bsocket%e6%a8%a1%e5%9e%8b-recv%e4%b8%ad%e5%a4%84%e7%90%86%e5%88%86%e5%8c%85%e7%b2%98%e5%8c%85>#</a></h3><p>原始socket模型, 考虑到tcp分包<br></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C++ data-lang=C++><span style=display:flex><span><span style=color:#75715e>//网络读取 -- 系统检测到网络I/O事件时, 调用该函数
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>LRESULT CTCPSocketService<span style=color:#f92672>::</span>OnSocketNotifyRead(WPARAM wParam, LPARAM lParam)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//读取数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//使用中间量m+cbRecvbuf来当做缓冲区
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#75715e>//使用中间量m_wRecvsize来记录当前缓冲区中已读数据大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>int</span> iRetCode <span style=color:#f92672>=</span> recv(m_hSocket, (<span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>)m_cbRecvBuf <span style=color:#f92672>+</span> m_wRecvSize, <span style=color:#66d9ef>sizeof</span>(m_cbRecvBuf) <span style=color:#f92672>-</span> m_wRecvSize, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#75715e>//读取失败, 则返回SOCKET_ERROR
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (iRetCode <span style=color:#f92672>==</span> SOCKET_ERROR)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	ZeroMemory(m_cbRecvBuf, <span style=color:#66d9ef>sizeof</span>(m_cbRecvBuf));
</span></span><span style=display:flex><span>	m_wRecvSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>1</span>;<span style=color:#75715e>//&#34;网络连接关闭，读取数据失败&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>    <span style=color:#75715e>//读取成功, 则返回读取到的数据的大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    m_wRecvSize <span style=color:#f92672>+=</span> iRetCode;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在tcp数据中, 增加包的大小, 用来校验是否读取完毕;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    TCP_Head <span style=color:#f92672>*</span> pHead <span style=color:#f92672>=</span> (TCP_Head <span style=color:#f92672>*</span>)m_cbRecvBuf;
</span></span><span style=display:flex><span>    WORD wPacketSize <span style=color:#f92672>=</span> pHead<span style=color:#f92672>-&gt;</span>TCPInfo.wPacketSize;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// //数据包大小校验
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span> (wPacketSize <span style=color:#f92672>&gt;</span> (SOCKET_TCP_BUFFER <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(TCP_Head)))
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>	<span style=color:#75715e>//当发生错误时候, 缓冲区置位
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	ZeroMemory(m_cbRecvBuf, <span style=color:#66d9ef>sizeof</span>(m_cbRecvBuf));
</span></span><span style=display:flex><span>	m_wRecvSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>3</span>;<span style=color:#75715e>//&#34;数据包太大&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#75715e>//解析数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	<span style=color:#66d9ef>if</span> (m_wRecvSize <span style=color:#f92672>==</span> wPacketSize)  <span style=color:#75715e>//数据全部接受完毕之后 再解析
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	{		
</span></span><span style=display:flex><span>	    <span style=color:#75715e>//拷贝数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    BYTE cbDataBuffer[SOCKET_TCP_BUFFER<span style=color:#f92672>+</span><span style=color:#66d9ef>sizeof</span>(TCP_Head)];		
</span></span><span style=display:flex><span>	    CopyMemory(cbDataBuffer, m_cbRecvBuf, wPacketSize);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>//置位缓冲信息 -- 缓冲区中只保存一条tcp信息
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    m_wRecvSize <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>	    ZeroMemory(m_cbRecvBuf, <span style=color:#66d9ef>sizeof</span>(m_cbRecvBuf));		
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>//解密数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    WORD wRealySize <span style=color:#f92672>=</span> CrevasseBuffer(cbDataBuffer, wPacketSize);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>if</span>(wRealySize <span style=color:#f92672>&lt;</span> <span style=color:#66d9ef>sizeof</span>(TCP_Head)) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>4</span>; <span style=color:#75715e>//解析后的数据错误
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>//获得TCP_Head
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    TCP_Command Command <span style=color:#f92672>=</span> ((TCP_Head <span style=color:#f92672>*</span>)cbDataBuffer)<span style=color:#f92672>-&gt;</span>CommandInfo;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>//获得实际的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#66d9ef>void</span> <span style=color:#f92672>*</span> pDataBuffer <span style=color:#f92672>=</span> cbDataBuffer <span style=color:#f92672>+</span> <span style=color:#66d9ef>sizeof</span>(TCP_Head); <span style=color:#75715e>//实际的数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    WORD wRealDataSize <span style=color:#f92672>=</span> wRealySize <span style=color:#f92672>-</span> <span style=color:#66d9ef>sizeof</span>(TCP_Head);   <span style=color:#75715e>//实际的数据大小
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>//内核命令
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#66d9ef>if</span> (Command.wMainCmdID <span style=color:#f92672>==</span> MDM_KN_COMMAND)
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>switch</span> (Command.wSubCmdID)
</span></span><span style=display:flex><span>	    {
</span></span><span style=display:flex><span>		<span style=color:#66d9ef>case</span> SUB_KN_DETECT_SOCKET:	<span style=color:#75715e>//网络检测
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		{
</span></span><span style=display:flex><span>		    <span style=color:#75715e>//发送数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>		    SendData(MDM_KN_COMMAND, SUB_KN_DETECT_SOCKET, pDataBuffer, wRealDataSize);
</span></span><span style=display:flex><span>		    <span style=color:#66d9ef>break</span>;
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>	    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	    <span style=color:#75715e>//处理数据
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	    <span style=color:#66d9ef>bool</span> bSuccess <span style=color:#f92672>=</span> m_QueueServiceEvent.PostTCPSocketReadEvent(m_wServiceID, Command, pDataBuffer, wRealDataSize);
</span></span><span style=display:flex><span>	    <span style=color:#66d9ef>if</span> (bSuccess <span style=color:#f92672>==</span> false) <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>5</span>;<span style=color:#75715e>//&#34;网络数据包处理失败&#34;;
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>	};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	<span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=ipv4>ipv4
<a class=anchor href=#ipv4>#</a></h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>系统文件在/proc/sys/net/ipv4下面
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ip_local_port_range # 用户端口范围, [n, m)
</span></span><span style=display:flex><span>tcp_timestamp       # 针对TIME_WAIT状态的tcp连接; 0关闭,1开启
</span></span><span style=display:flex><span>tcp_tw_recycle      # 是否快速回收+ linux内核已删除该字段
</span></span><span style=display:flex><span>tcp_tw_reuse        # TIME_WAIT状态的tcp的port是否可以复用;0关闭,1开启
</span></span><span style=display:flex><span>                    # 需要开启tcp_timestamp;
</span></span><span style=display:flex><span>		    # 这是针对cli的设计,而非svr
</span></span><span style=display:flex><span>tcp_rmem            # tcp read缓冲区
</span></span><span style=display:flex><span>tcp_wmem            # tcp write缓冲区
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ip_forward               0禁止ip转发, 1打开;
</span></span><span style=display:flex><span>ip_default_ttl           数据报的生存周期(time to live), 即最多经过多少路由器
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>ip_no_pmtu_disc          关闭路径MTU探测
</span></span><span style=display:flex><span>min_pmtu                 最小路径MTU的大小
</span></span><span style=display:flex><span>mtu_expires              PMTU信息缓存多长时间
</span></span></code></pre></div></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents><ul><li><a href=#基本概念>基本概念</a><ul><li><a href=#socket>socket</a></li><li><a href=#socket问题>socket问题</a></li><li><a href=#i-o模型>I/O模型</a></li><li><a href=#epoll使用>epoll使用</a></li></ul></li><li><a href=#socket属性>socket属性</a><ul><li><a href=#keep-live机制>keep live机制</a></li></ul></li><li><a href=#编程实例>编程实例</a><ul><li><a href=#原始socket模型-recv中处理分包粘包>原始socket模型, recv()中处理分包粘包</a></li></ul></li><li><a href=#ipv4>ipv4</a></li></ul></nav></div></aside></main></body></html>